<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NLT - Neo Legacy Title Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: #2d2d2d;
            color: #e0e0e0;
            overflow: hidden;
            height: 100vh;
        }

        /* メインコンテナ */
        .main-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        /* 上部ツールバー */
        .toolbar {
            background: #1e1e1e;
            padding: 8px 12px;
            border-bottom: 1px solid #000;
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .tool-btn {
            width: 32px;
            height: 32px;
            background: #3a3a3a;
            border: 1px solid #555;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #aaa;
            font-size: 18px;
            transition: all 0.2s;
        }

        .tool-btn:hover {
            background: #4a4a4a;
            color: #fff;
        }

        .tool-btn.active {
            background: #0066cc;
            color: #fff;
            border-color: #0077ee;
        }

        .toolbar-separator {
            width: 1px;
            height: 24px;
            background: #555;
            margin: 0 4px;
        }

        /* コンテンツエリア */
        .content-area {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        /* キャンバスエリア */
        .canvas-area {
            flex: 1;
            background: #141414;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        #canvas {
            background: repeating-conic-gradient(
                #2a2a2a 0% 25%,
                #1e1e1e 0% 50%
            ) 50% / 16px 16px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            cursor: crosshair;
            max-width: 100%;
            max-height: 100%;
        }

        #canvas.selection-mode {
            cursor: default;
        }

        /* 右側プロパティパネル */
        .properties-panel {
            width: 280px;
            background: #252525;
            border-left: 1px solid #000;
            overflow-y: auto;
            padding: 12px;
        }

        .property-section {
            margin-bottom: 16px;
            background: #2d2d2d;
            border-radius: 4px;
            overflow: hidden;
        }

        .property-section-header {
            background: #1e1e1e;
            padding: 8px 12px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
            cursor: pointer;
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .property-section-header:hover {
            background: #252525;
        }

        .property-section-header::after {
            content: '▼';
            font-size: 8px;
            transition: transform 0.2s;
        }

        .property-section-header.collapsed::after {
            transform: rotate(-90deg);
        }

        .property-section-content {
            padding: 12px;
            display: block;
        }

        .property-section-content.hidden {
            display: none;
        }

        .property-row {
            margin-bottom: 10px;
        }

        .property-row label {
            display: block;
            font-size: 11px;
            color: #aaa;
            margin-bottom: 4px;
        }

        .property-row input,
        .property-row select {
            width: 100%;
            padding: 6px 8px;
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 3px;
            color: #fff;
            font-size: 12px;
        }

        .property-row input:focus,
        .property-row select:focus {
            outline: none;
            border-color: #0066cc;
        }

        .property-row input[type="color"] {
            height: 32px;
            padding: 2px;
            cursor: pointer;
        }

        .property-row input[type="range"] {
            padding: 0;
            accent-color: #0066cc;
        }

        .property-row input[type="checkbox"] {
            width: auto;
            margin-right: 6px;
            accent-color: #0066cc;
        }

        .property-grid-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .property-grid-3 {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 6px;
        }

        .btn {
            width: 100%;
            padding: 8px;
            background: #3a3a3a;
            border: 1px solid #555;
            border-radius: 4px;
            color: #e0e0e0;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn:hover {
            background: #4a4a4a;
        }

        .btn-primary {
            background: #0066cc;
            border-color: #0077ee;
            color: #fff;
        }

        .btn-primary:hover {
            background: #0077ee;
        }

        .value-display {
            font-size: 10px;
            color: #666;
            margin-top: 2px;
        }

        /* ツールチップ */
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 11px;
            pointer-events: none;
            z-index: 1000;
            display: none;
        }

        /* 隠しIME入力フィールド */
        #imeInput {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 10px;
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid #007acc;
            border-radius: 4px;
            font-size: 16px;
            color: #000;
            z-index: 10000;
            min-width: 300px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            display: none;
        }

        #imeInput.active {
            display: block;
        }

        /* スクロールバーのスタイル */
        ::-webkit-scrollbar {
            width: 12px;
        }

        ::-webkit-scrollbar-track {
            background: #1a1a1a;
        }

        ::-webkit-scrollbar-thumb {
            background: #4a4a4a;
            border-radius: 6px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #5a5a5a;
        }

        /* テキストオブジェクトの選択ハンドル */
        .text-selection-box {
            position: absolute;
            border: 2px solid #0066cc;
            pointer-events: none;
            z-index: 100;
        }

        .resize-handle {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #fff;
            border: 1px solid #0066cc;
            pointer-events: all;
            cursor: nwse-resize;
        }

        .resize-handle.nw { top: -4px; left: -4px; cursor: nw-resize; }
        .resize-handle.ne { top: -4px; right: -4px; cursor: ne-resize; }
        .resize-handle.sw { bottom: -4px; left: -4px; cursor: sw-resize; }
        .resize-handle.se { bottom: -4px; right: -4px; cursor: se-resize; }
    </style>
</head>
<body>
    <div class="main-container">
        <!-- 上部ツールバー -->
        <div class="toolbar">
            <div class="tool-btn active" id="selectTool" title="選択ツール (V)">
                ➤
            </div>
            <div class="tool-btn" id="textTool" title="テキストツール (T)">
                T
            </div>
            <div class="tool-btn" id="rectangleTool" title="長方形ツール (R)">
                ▭
            </div>
            <div class="tool-btn" id="ellipseTool" title="円/楕円ツール (E)">
                ○
            </div>
            <div class="tool-btn" id="lineTool" title="ラインツール (L)">
                ╱
            </div>
            <div class="toolbar-separator"></div>
            <span style="font-size: 11px; color: #888;">解像度:</span>
            <input type="number" id="canvasWidth" value="1920" min="1" style="width: 70px; padding: 4px; background: #3a3a3a; border: 1px solid #555; border-radius: 3px; color: #fff; font-size: 11px;">
            <span style="font-size: 11px; color: #888;">×</span>
            <input type="number" id="canvasHeight" value="1080" min="1" style="width: 70px; padding: 4px; background: #3a3a3a; border: 1px solid #555; border-radius: 3px; color: #fff; font-size: 11px;">
            <div class="toolbar-separator"></div>
            <div class="tool-btn" onclick="zoomIn()" title="拡大 (Ctrl++)">
                +
            </div>
            <div class="tool-btn" onclick="zoomOut()" title="縮小 (Ctrl+-)">
                −
            </div>
            <div class="tool-btn" onclick="fitToScreen()" title="画面に合わせる (Ctrl+0)">
                ⊡
            </div>
            <div class="tool-btn" onclick="resetView()" title="ビューリセット (Ctrl+R)">
                ⟲
            </div>
            <div class="toolbar-separator"></div>
            <div class="tool-btn" onclick="alignCenter()" title="中央揃え（横）">
                ⬌
            </div>
            <div class="tool-btn" onclick="alignMiddle()" title="中央揃え（縦）">
                ⬍
            </div>
            <div class="toolbar-separator"></div>
            <button class="btn btn-primary" onclick="exportPRTL()" style="width: auto; padding: 6px 12px;">PRTL書き出し</button>
        </div>

        <!-- コンテンツエリア -->
        <div class="content-area">
            <!-- キャンバスエリア -->
            <div class="canvas-area">
                <canvas id="canvas" width="1920" height="1080"></canvas>
            </div>

            <!-- 右側プロパティパネル -->
            <div class="properties-panel">
                <h3 style="font-size: 12px; margin-bottom: 12px; color: #0066cc;">プロパティ</h3>

                <!-- キャンバス設定セクション -->
                <div class="property-section">
                    <div class="property-section-header">キャンバス設定</div>
                    <div class="property-section-content">
                        <h4 style="font-size: 10px; color: #888; margin: 8px 0 4px;">セーフマージン</h4>
                        <div class="property-row">
                            <label><input type="checkbox" id="safeMarginEnabled" checked onchange="render()">表示</label>
                        </div>
                        <div class="property-grid-2">
                            <div class="property-row">
                                <label>アクション %</label>
                                <input type="number" id="actionSafeMargin" min="0" max="20" value="5" onchange="render()">
                            </div>
                            <div class="property-row">
                                <label>タイトル %</label>
                                <input type="number" id="titleSafeMargin" min="0" max="20" value="10" onchange="render()">
                            </div>
                        </div>
                        <div class="property-grid-2">
                            <div class="property-row">
                                <label>色</label>
                                <input type="color" id="safeMarginColor" value="#ffffff" onchange="render()">
                            </div>
                            <div class="property-row">
                                <label>不透明度 %</label>
                                <input type="number" id="safeMarginOpacity" min="0" max="100" value="50" onchange="render()">
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 変形セクション -->
                <div class="property-section">
                    <div class="property-section-header">変形</div>
                    <div class="property-section-content">
                        <div class="property-grid-2">
                            <div class="property-row">
                                <label>X座標</label>
                                <input type="number" id="prop_x" value="960" step="0.1">
                            </div>
                            <div class="property-row">
                                <label>Y座標</label>
                                <input type="number" id="prop_y" value="540" step="0.1">
                            </div>
                        </div>
                        <div class="property-grid-2">
                            <div class="property-row">
                                <label>幅</label>
                                <input type="number" id="prop_width" value="500" step="0.1" readonly>
                            </div>
                            <div class="property-row">
                                <label>高さ</label>
                                <input type="number" id="prop_height" value="100" step="0.1" readonly>
                            </div>
                        </div>
                        <div class="property-row">
                            <label>回転 (度)</label>
                            <input type="number" id="prop_rotation" value="0" step="0.1">
                        </div>
                    </div>
                </div>

                <!-- プロパティセクション -->
                <div class="property-section">
                    <div class="property-section-header">フォント</div>
                    <div class="property-section-content">
                        <div class="property-row">
                            <label>フォントファミリー</label>
                            <select id="prop_fontFamily">
                                <option value="Yu Gothic UI">Yu Gothic UI</option>
                                <option value="Arial">Arial</option>
                                <option value="Meiryo">Meiryo</option>
                                <option value="MS Gothic">MS Gothic</option>
                                <option value="Hiragino Sans">Hiragino Sans</option>
                            </select>
                        </div>
                        <div class="property-row">
                            <label>フォントスタイル</label>
                            <select id="prop_fontStyle">
                                <option value="Regular">Regular</option>
                                <option value="Bold">Bold</option>
                                <option value="Italic">Italic</option>
                            </select>
                        </div>
                        <div class="property-row">
                            <label>フォントサイズ</label>
                            <input type="number" id="prop_fontSize" value="72" min="1" max="500">
                        </div>
                        <div class="property-row">
                            <label>縦横比 (%)</label>
                            <input type="range" id="prop_scaleX" value="100" min="10" max="200" step="1">
                            <div class="value-display" id="scaleXValue">100%</div>
                        </div>
                        <div class="property-row">
                            <label>カーニング</label>
                            <input type="number" id="prop_kerning" value="0" step="1">
                        </div>
                        <div class="property-row">
                            <label>トラッキング</label>
                            <input type="number" id="prop_tracking" value="0" step="1">
                        </div>
                        <div class="property-row">
                            <label>ベースラインシフト</label>
                            <input type="number" id="prop_baselineShift" value="0" step="1">
                        </div>
                        <div class="property-row">
                            <label><input type="checkbox" id="prop_vertical">縦書き</label>
                        </div>
                    </div>
                </div>

                <!-- 塗りセクション -->
                <div class="property-section">
                    <div class="property-section-header">塗り</div>
                    <div class="property-section-content">
                        <div class="property-row">
                            <label><input type="checkbox" id="fill_enabled" checked>有効</label>
                        </div>
                        <div class="property-row">
                            <label>塗りタイプ</label>
                            <select id="fill_type">
                                <option value="solid">ベタ塗り</option>
                                <option value="gradient-linear">線形グラデーション</option>
                                <option value="gradient-radial">円形グラデーション</option>
                                <option value="sheen">光沢</option>
                            </select>
                        </div>
                        <div id="solidFillControls">
                            <div class="property-grid-2">
                                <div class="property-row">
                                    <label>カラー</label>
                                    <input type="color" id="fill_color" value="#fdff00">
                                </div>
                                <div class="property-row">
                                    <label>不透明度 (%)</label>
                                    <input type="number" id="fill_opacity" value="100" min="0" max="100">
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- ストロークセクション -->
                <div class="property-section">
                    <div class="property-section-header">ストローク</div>
                    <div class="property-section-content">
                        <div class="property-row">
                            <label><input type="checkbox" id="stroke1_enabled">ストローク1</label>
                        </div>
                        <div class="property-grid-3">
                            <div class="property-row">
                                <label>サイズ</label>
                                <input type="number" id="stroke1_size" value="8" min="0" max="200">
                            </div>
                            <div class="property-row" style="grid-column: span 2;">
                                <label>カラー</label>
                                <input type="color" id="stroke1_color" value="#000000">
                            </div>
                        </div>

                        <div class="property-row" style="margin-top: 12px;">
                            <label><input type="checkbox" id="stroke2_enabled">ストローク2</label>
                        </div>
                        <div class="property-grid-3">
                            <div class="property-row">
                                <label>サイズ</label>
                                <input type="number" id="stroke2_size" value="38" min="0" max="200">
                            </div>
                            <div class="property-row" style="grid-column: span 2;">
                                <label>カラー</label>
                                <input type="color" id="stroke2_color" value="#ffffff">
                            </div>
                        </div>

                        <div class="property-row" style="margin-top: 12px;">
                            <label><input type="checkbox" id="stroke3_enabled">ストローク3</label>
                        </div>
                        <div class="property-grid-3">
                            <div class="property-row">
                                <label>サイズ</label>
                                <input type="number" id="stroke3_size" value="68" min="0" max="200">
                            </div>
                            <div class="property-row" style="grid-column: span 2;">
                                <label>カラー</label>
                                <input type="color" id="stroke3_color" value="#000000">
                            </div>
                        </div>

                        <div class="property-row" style="margin-top: 12px;">
                            <label><input type="checkbox" id="stroke4_enabled">ストローク4</label>
                        </div>
                        <div class="property-grid-3">
                            <div class="property-row">
                                <label>サイズ</label>
                                <input type="number" id="stroke4_size" value="78" min="0" max="200">
                            </div>
                            <div class="property-row" style="grid-column: span 2;">
                                <label>カラー</label>
                                <input type="color" id="stroke4_color" value="#000000">
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 影セクション -->
                <div class="property-section">
                    <div class="property-section-header">影</div>
                    <div class="property-section-content">
                        <div class="property-row">
                            <label><input type="checkbox" id="shadow_enabled">有効</label>
                        </div>
                        <div class="property-grid-2">
                            <div class="property-row">
                                <label>カラー</label>
                                <input type="color" id="shadow_color" value="#000000">
                            </div>
                            <div class="property-row">
                                <label>不透明度 (%)</label>
                                <input type="number" id="shadow_opacity" value="50" min="0" max="100">
                            </div>
                        </div>
                        <div class="property-grid-2">
                            <div class="property-row">
                                <label>距離</label>
                                <input type="number" id="shadow_distance" value="10" min="0" max="100">
                            </div>
                            <div class="property-row">
                                <label>角度 (度)</label>
                                <input type="number" id="shadow_angle" value="-45" min="-180" max="180">
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 隠しIME入力用 -->
    <input type="text" id="imeInput" autocomplete="off">

    <script>
        // グローバル変数
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let currentTool = 'select'; // 'select', 'text', 'rectangle', 'ellipse', 'line'
        let textObjects = []; // { text, x, y, fontSize, fontFamily, scaleX, ... }
        let shapeObjects = []; // { type, x, y, width, height, ... }
        let selectedObject = null;
        let isTyping = false;
        let cursorPosition = 0;
        let selectionStart = 0;
        let selectionEnd = 0;

        // ビューポート制御
        let viewportScale = 1;
        let viewportOffsetX = 0;
        let viewportOffsetY = 0;

        // カーソル点滅用
        let cursorVisible = true;
        setInterval(() => {
            cursorVisible = !cursorVisible;
            if (isTyping) render();
        }, 530);

        // ツール切り替え
        document.getElementById('selectTool').addEventListener('click', () => {
            switchTool('select');
        });

        document.getElementById('textTool').addEventListener('click', () => {
            switchTool('text');
        });

        document.getElementById('rectangleTool').addEventListener('click', () => {
            switchTool('rectangle');
        });

        document.getElementById('ellipseTool').addEventListener('click', () => {
            switchTool('ellipse');
        });

        document.getElementById('lineTool').addEventListener('click', () => {
            switchTool('line');
        });

        function switchTool(tool) {
            currentTool = tool;

            // 全ツールのactiveクラスを削除
            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));

            // 選択されたツールをアクティブに
            if (tool === 'select') {
                document.getElementById('selectTool').classList.add('active');
                canvas.classList.add('selection-mode');
                canvas.style.cursor = 'default';
            } else if (tool === 'text') {
                document.getElementById('textTool').classList.add('active');
                canvas.classList.remove('selection-mode');
                canvas.style.cursor = 'crosshair';
            } else if (tool === 'rectangle') {
                document.getElementById('rectangleTool').classList.add('active');
                canvas.classList.remove('selection-mode');
                canvas.style.cursor = 'crosshair';
            } else if (tool === 'ellipse') {
                document.getElementById('ellipseTool').classList.add('active');
                canvas.classList.remove('selection-mode');
                canvas.style.cursor = 'crosshair';
            } else if (tool === 'line') {
                document.getElementById('lineTool').classList.add('active');
                canvas.classList.remove('selection-mode');
                canvas.style.cursor = 'crosshair';
            }
        }

        // キャンバス解像度変更
        document.getElementById('canvasWidth').addEventListener('change', function() {
            canvas.width = parseInt(this.value);
            render();
        });

        document.getElementById('canvasHeight').addEventListener('change', function() {
            canvas.height = parseInt(this.value);
            render();
        });

        // 縦横比スライダーの値表示
        document.getElementById('prop_scaleX').addEventListener('input', function() {
            document.getElementById('scaleXValue').textContent = this.value + '%';
            if (selectedObject) {
                selectedObject.scaleX = parseInt(this.value);
                render();
            }
        });

        // プロパティ変更時のリアルタイム更新
        const propertyInputs = [
            'prop_x', 'prop_y', 'prop_fontSize', 'prop_fontFamily',
            'prop_kerning', 'prop_tracking', 'prop_rotation', 'prop_vertical',
            'fill_color', 'fill_opacity', 'fill_enabled',
            'stroke1_enabled', 'stroke1_size', 'stroke1_color',
            'stroke2_enabled', 'stroke2_size', 'stroke2_color',
            'stroke3_enabled', 'stroke3_size', 'stroke3_color',
            'stroke4_enabled', 'stroke4_size', 'stroke4_color',
            'shadow_enabled', 'shadow_color', 'shadow_opacity', 'shadow_distance', 'shadow_angle'
        ];

        propertyInputs.forEach(id => {
            const el = document.getElementById(id);
            if (el) {
                el.addEventListener('input', updateSelectedObjectFromProperties);
                el.addEventListener('change', updateSelectedObjectFromProperties);
            }
        });

        function updateSelectedObjectFromProperties() {
            if (!selectedObject) return;

            selectedObject.x = parseFloat(document.getElementById('prop_x').value) || 0;
            selectedObject.y = parseFloat(document.getElementById('prop_y').value) || 0;
            selectedObject.fontSize = parseInt(document.getElementById('prop_fontSize').value) || 72;
            selectedObject.fontFamily = document.getElementById('prop_fontFamily').value;
            selectedObject.scaleX = parseInt(document.getElementById('prop_scaleX').value) || 100;
            selectedObject.kerning = parseInt(document.getElementById('prop_kerning').value) || 0;
            selectedObject.tracking = parseInt(document.getElementById('prop_tracking').value) || 0;
            selectedObject.rotation = parseFloat(document.getElementById('prop_rotation').value) || 0;
            selectedObject.vertical = document.getElementById('prop_vertical').checked;

            selectedObject.fill = {
                enabled: document.getElementById('fill_enabled').checked,
                color: document.getElementById('fill_color').value,
                opacity: parseInt(document.getElementById('fill_opacity').value) || 100
            };

            selectedObject.strokes = [
                {
                    enabled: document.getElementById('stroke1_enabled').checked,
                    size: parseInt(document.getElementById('stroke1_size').value) || 0,
                    color: document.getElementById('stroke1_color').value
                },
                {
                    enabled: document.getElementById('stroke2_enabled').checked,
                    size: parseInt(document.getElementById('stroke2_size').value) || 0,
                    color: document.getElementById('stroke2_color').value
                },
                {
                    enabled: document.getElementById('stroke3_enabled').checked,
                    size: parseInt(document.getElementById('stroke3_size').value) || 0,
                    color: document.getElementById('stroke3_color').value
                },
                {
                    enabled: document.getElementById('stroke4_enabled').checked,
                    size: parseInt(document.getElementById('stroke4_size').value) || 0,
                    color: document.getElementById('stroke4_color').value
                }
            ];

            selectedObject.shadow = {
                enabled: document.getElementById('shadow_enabled').checked,
                color: document.getElementById('shadow_color').value,
                opacity: parseInt(document.getElementById('shadow_opacity').value) || 50,
                distance: parseInt(document.getElementById('shadow_distance').value) || 10,
                angle: parseInt(document.getElementById('shadow_angle').value) || -45
            };

            render();
        }

        // マウスイベント処理
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let dragTarget = null; // 'object' or 'handle-nw', 'handle-ne', etc.
        let dragStartObjX = 0;
        let dragStartObjY = 0;
        let dragStartWidth = 0;
        let dragStartHeight = 0;
        let isCreatingShape = false;
        let currentShape = null;

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (canvas.width / rect.width);
            const y = (e.clientY - rect.top) * (canvas.height / rect.height);

            dragStartX = x;
            dragStartY = y;

            if (currentTool === 'text') {
                // 新しいテキストオブジェクトを作成
                const newText = {
                    text: '',
                    x: x,
                    y: y,
                    fontSize: 72,
                    fontFamily: 'Yu Gothic UI',
                    scaleX: 100,
                    kerning: 0,
                    tracking: 0,
                    rotation: 0,
                    vertical: false,
                    fill: {
                        enabled: true,
                        color: '#fdff00',
                        opacity: 100
                    },
                    strokes: [
                        { enabled: false, size: 8, color: '#000000' },
                        { enabled: false, size: 38, color: '#ffffff' },
                        { enabled: false, size: 68, color: '#000000' },
                        { enabled: false, size: 78, color: '#000000' }
                    ],
                    shadow: {
                        enabled: false,
                        color: '#000000',
                        opacity: 50,
                        distance: 10,
                        angle: -45
                    }
                };

                textObjects.push(newText);
                selectedObject = newText;
                updatePropertiesPanel();
                startTyping();
            } else if (currentTool === 'rectangle' || currentTool === 'ellipse' || currentTool === 'line') {
                // 図形またはライン作成開始
                isCreatingShape = true;
                currentShape = {
                    type: currentTool,
                    x: x,
                    y: y,
                    width: 0,
                    height: 0,
                    fill: {
                        enabled: true,
                        color: '#ffffff',
                        opacity: 100
                    },
                    stroke: {
                        enabled: true,
                        size: 3,
                        color: '#000000'
                    }
                };
            } else if (currentTool === 'select') {
                // ハンドルクリックチェック
                const handle = getHandleAt(x, y);
                if (handle && selectedObject) {
                    isDragging = true;
                    dragTarget = handle;
                    dragStartObjX = selectedObject.x;
                    dragStartObjY = selectedObject.y;
                    const metrics = measureText(selectedObject);
                    dragStartWidth = metrics.width;
                    dragStartHeight = metrics.height;
                } else if (selectObjectAt(x, y)) {
                    // オブジェクト選択成功、ドラッグ開始
                    isDragging = true;
                    dragTarget = 'object';
                    dragStartObjX = selectedObject.x;
                    dragStartObjY = selectedObject.y;
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (canvas.width / rect.width);
            const y = (e.clientY - rect.top) * (canvas.height / rect.height);

            if (isCreatingShape && currentShape) {
                // 図形のサイズを更新
                currentShape.width = x - currentShape.x;
                currentShape.height = y - currentShape.y;
                render();
            } else if (isDragging && selectedObject) {
                const dx = x - dragStartX;
                const dy = y - dragStartY;

                if (dragTarget === 'object') {
                    // オブジェクトを移動
                    selectedObject.x = dragStartObjX + dx;
                    selectedObject.y = dragStartObjY + dy;
                    updatePropertiesPanel();
                    render();
                } else if (dragTarget && dragTarget.startsWith('handle-')) {
                    // リサイズ処理
                    const handleType = dragTarget.replace('handle-', '');
                    resizeObject(handleType, dx, dy);
                }
            } else {
                // カーソル形状を更新
                if (currentTool === 'select' && selectedObject) {
                    const handle = getHandleAt(x, y);
                    if (handle) {
                        const handleType = handle.replace('handle-', '');
                        if (handleType === 'nw' || handleType === 'se') {
                            canvas.style.cursor = 'nwse-resize';
                        } else if (handleType === 'ne' || handleType === 'sw') {
                            canvas.style.cursor = 'nesw-resize';
                        }
                    } else {
                        // オブジェクト上かチェック
                        const metrics = measureText(selectedObject);
                        if (x >= selectedObject.x - 10 && x <= selectedObject.x + metrics.width + 10 &&
                            y >= selectedObject.y - metrics.height && y <= selectedObject.y + 10) {
                            canvas.style.cursor = 'move';
                        } else {
                            canvas.style.cursor = 'default';
                        }
                    }
                }
            }
        });

        canvas.addEventListener('mouseup', () => {
            if (isCreatingShape && currentShape) {
                // 図形を確定
                if (Math.abs(currentShape.width) > 5 || Math.abs(currentShape.height) > 5) {
                    shapeObjects.push(currentShape);
                }
                isCreatingShape = false;
                currentShape = null;
                render();
            }

            isDragging = false;
            dragTarget = null;
        });

        canvas.addEventListener('dblclick', (e) => {
            if (currentTool === 'select' && selectedObject) {
                // ダブルクリックでテキスト編集モード
                startTyping();
            }
        });

        function getHandleAt(x, y) {
            if (!selectedObject) return null;

            const metrics = measureText(selectedObject);
            const handleSize = 6;
            const handles = {
                'handle-nw': [selectedObject.x - 2, selectedObject.y - 2],
                'handle-ne': [selectedObject.x + metrics.width + 2, selectedObject.y - 2],
                'handle-sw': [selectedObject.x - 2, selectedObject.y + metrics.height + 2],
                'handle-se': [selectedObject.x + metrics.width + 2, selectedObject.y + metrics.height + 2]
            };

            for (const [name, [hx, hy]] of Object.entries(handles)) {
                if (Math.abs(x - hx) <= handleSize && Math.abs(y - hy) <= handleSize) {
                    return name;
                }
            }

            return null;
        }

        function resizeObject(handleType, dx, dy) {
            if (!selectedObject) return;

            const newFontSize = selectedObject.fontSize;

            // フォントサイズを変更してリサイズ
            if (handleType === 'se' || handleType === 'ne') {
                // 右方向のリサイズ
                const scaleFactor = (dragStartWidth + dx) / dragStartWidth;
                selectedObject.fontSize = Math.max(10, Math.round(dragStartHeight * scaleFactor));
            } else if (handleType === 'sw' || handleType === 'nw') {
                // 左方向のリサイズ
                const scaleFactor = (dragStartWidth - dx) / dragStartWidth;
                selectedObject.fontSize = Math.max(10, Math.round(dragStartHeight * scaleFactor));
                // 位置も調整
                const metrics = measureText(selectedObject);
                selectedObject.x = dragStartObjX + (dragStartWidth - metrics.width);
            }

            updatePropertiesPanel();
            render();
        }

        function selectObjectAt(x, y) {
            // テキストオブジェクトをチェック（後ろから）
            for (let i = textObjects.length - 1; i >= 0; i--) {
                const obj = textObjects[i];
                const metrics = measureText(obj);

                if (x >= obj.x - 10 && x <= obj.x + metrics.width + 10 &&
                    y >= obj.y - metrics.height && y <= obj.y + 10) {
                    selectedObject = obj;
                    updatePropertiesPanel();
                    render();
                    return true;
                }
            }

            // 図形オブジェクトをチェック（後ろから）
            for (let i = shapeObjects.length - 1; i >= 0; i--) {
                const obj = shapeObjects[i];
                const minX = Math.min(obj.x, obj.x + obj.width);
                const minY = Math.min(obj.y, obj.y + obj.height);
                const maxX = Math.max(obj.x, obj.x + obj.width);
                const maxY = Math.max(obj.y, obj.y + obj.height);

                if (x >= minX - 10 && x <= maxX + 10 &&
                    y >= minY - 10 && y <= maxY + 10) {
                    selectedObject = obj;
                    render();
                    return true;
                }
            }

            // 何も選択されなかった
            selectedObject = null;
            render();
            return false;
        }

        function startTyping() {
            isTyping = true;
            cursorPosition = selectedObject.text.length;

            // IME入力をフォーカス
            const imeInput = document.getElementById('imeInput');
            imeInput.value = selectedObject.text;
            imeInput.classList.add('active');
            imeInput.focus();
            imeInput.select();
        }

        // IME入力処理
        document.getElementById('imeInput').addEventListener('input', (e) => {
            if (selectedObject && isTyping) {
                selectedObject.text = e.target.value;
                cursorPosition = e.target.selectionStart;
                selectionStart = e.target.selectionStart;
                selectionEnd = e.target.selectionEnd;
                render();
            }
        });

        // 選択範囲の変更を追跡
        document.getElementById('imeInput').addEventListener('select', (e) => {
            if (selectedObject && isTyping) {
                selectionStart = e.target.selectionStart;
                selectionEnd = e.target.selectionEnd;
                cursorPosition = e.target.selectionStart;
                render();
            }
        });

        document.getElementById('imeInput').addEventListener('click', (e) => {
            if (selectedObject && isTyping) {
                selectionStart = e.target.selectionStart;
                selectionEnd = e.target.selectionEnd;
                cursorPosition = e.target.selectionStart;
                render();
            }
        });

        // IME入力のblurイベント
        document.getElementById('imeInput').addEventListener('blur', (e) => {
            if (isTyping) {
                isTyping = false;
                e.target.classList.remove('active');

                // 空のテキストオブジェクトを削除（レガシータイトルと同じ動作）
                if (selectedObject && selectedObject.text.trim() === '') {
                    const index = textObjects.indexOf(selectedObject);
                    if (index > -1) {
                        textObjects.splice(index, 1);
                        selectedObject = null;
                    }
                }

                render();
            }
        });

        // キーボードイベント
        document.addEventListener('keydown', (e) => {
            if (isTyping && selectedObject) {
                if (e.key === 'Escape') {
                    isTyping = false;
                    const imeInput = document.getElementById('imeInput');
                    imeInput.blur();
                    imeInput.classList.remove('active');
                    render();
                }
            } else if (selectedObject && !isTyping) {
                // 選択モードでのキーボードショートカット
                if (e.key === 'Delete' || e.key === 'Backspace') {
                    const index = textObjects.indexOf(selectedObject);
                    if (index > -1) {
                        textObjects.splice(index, 1);
                        selectedObject = null;
                        render();
                    }
                } else if (e.key === 'Enter') {
                    startTyping();
                }
            }
        });

        function updatePropertiesPanel() {
            if (!selectedObject) return;

            document.getElementById('prop_x').value = selectedObject.x.toFixed(1);
            document.getElementById('prop_y').value = selectedObject.y.toFixed(1);
            document.getElementById('prop_fontSize').value = selectedObject.fontSize;
            document.getElementById('prop_fontFamily').value = selectedObject.fontFamily;
            document.getElementById('prop_scaleX').value = selectedObject.scaleX;
            document.getElementById('scaleXValue').textContent = selectedObject.scaleX + '%';
            document.getElementById('prop_kerning').value = selectedObject.kerning;
            document.getElementById('prop_tracking').value = selectedObject.tracking;
            document.getElementById('prop_rotation').value = selectedObject.rotation;
            document.getElementById('prop_vertical').checked = selectedObject.vertical || false;

            document.getElementById('fill_enabled').checked = selectedObject.fill.enabled;
            document.getElementById('fill_color').value = selectedObject.fill.color;
            document.getElementById('fill_opacity').value = selectedObject.fill.opacity;

            if (selectedObject.strokes.length >= 4) {
                document.getElementById('stroke1_enabled').checked = selectedObject.strokes[0].enabled;
                document.getElementById('stroke1_size').value = selectedObject.strokes[0].size;
                document.getElementById('stroke1_color').value = selectedObject.strokes[0].color;

                document.getElementById('stroke2_enabled').checked = selectedObject.strokes[1].enabled;
                document.getElementById('stroke2_size').value = selectedObject.strokes[1].size;
                document.getElementById('stroke2_color').value = selectedObject.strokes[1].color;

                document.getElementById('stroke3_enabled').checked = selectedObject.strokes[2].enabled;
                document.getElementById('stroke3_size').value = selectedObject.strokes[2].size;
                document.getElementById('stroke3_color').value = selectedObject.strokes[2].color;

                document.getElementById('stroke4_enabled').checked = selectedObject.strokes[3].enabled;
                document.getElementById('stroke4_size').value = selectedObject.strokes[3].size;
                document.getElementById('stroke4_color').value = selectedObject.strokes[3].color;
            }

            document.getElementById('shadow_enabled').checked = selectedObject.shadow.enabled;
            document.getElementById('shadow_color').value = selectedObject.shadow.color;
            document.getElementById('shadow_opacity').value = selectedObject.shadow.opacity;
            document.getElementById('shadow_distance').value = selectedObject.shadow.distance;
            document.getElementById('shadow_angle').value = selectedObject.shadow.angle;
        }

        function measureText(obj) {
            ctx.font = `${obj.fontSize}px "${obj.fontFamily}"`;

            if (obj.vertical) {
                // 縦書きの場合
                const charCount = (obj.text || '|').length;
                return {
                    width: obj.fontSize * (obj.scaleX / 100),
                    height: obj.fontSize * charCount
                };
            } else {
                // 横書きの場合
                const metrics = ctx.measureText(obj.text || '|');
                return {
                    width: metrics.width * (obj.scaleX / 100),
                    height: obj.fontSize
                };
            }
        }

        function render() {
            // チェッカーボード背景を描画（レガシータイトルと同じ）
            drawCheckerboardBackground();

            // セーフマージン描画
            if (document.getElementById('safeMarginEnabled').checked) {
                drawSafeMargins();
            }

            // 全図形オブジェクトを描画
            shapeObjects.forEach(obj => {
                drawShapeObject(obj, obj === selectedObject);
            });

            // 図形作成中の場合
            if (isCreatingShape && currentShape) {
                drawShapeObject(currentShape, false);
            }

            // 全テキストオブジェクトを描画
            textObjects.forEach(obj => {
                drawTextObject(obj, obj === selectedObject);
            });

            // テキスト選択範囲の描画（入力中の場合）
            if (isTyping && selectedObject && selectionStart !== selectionEnd) {
                drawTextSelection();
            }

            // カーソル描画（入力中の場合）
            if (isTyping && selectedObject && cursorVisible) {
                drawCursor();
            }
        }

        function drawShapeObject(obj, isSelected) {
            ctx.save();

            const x = obj.x;
            const y = obj.y;
            const w = obj.width;
            const h = obj.height;

            // 塗り
            if (obj.fill && obj.fill.enabled) {
                const opacity = obj.fill.opacity / 100;
                if (opacity < 1) {
                    const rgb = hexToRgb(obj.fill.color);
                    ctx.fillStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`;
                } else {
                    ctx.fillStyle = obj.fill.color;
                }
            }

            // ストローク
            if (obj.stroke && obj.stroke.enabled) {
                ctx.strokeStyle = obj.stroke.color;
                ctx.lineWidth = obj.stroke.size;
            }

            // 図形タイプごとの描画
            if (obj.type === 'rectangle') {
                if (obj.fill && obj.fill.enabled) {
                    ctx.fillRect(x, y, w, h);
                }
                if (obj.stroke && obj.stroke.enabled) {
                    ctx.strokeRect(x, y, w, h);
                }
            } else if (obj.type === 'ellipse') {
                ctx.beginPath();
                ctx.ellipse(x + w/2, y + h/2, Math.abs(w/2), Math.abs(h/2), 0, 0, 2 * Math.PI);
                if (obj.fill && obj.fill.enabled) {
                    ctx.fill();
                }
                if (obj.stroke && obj.stroke.enabled) {
                    ctx.stroke();
                }
            } else if (obj.type === 'line') {
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + w, y + h);
                if (obj.stroke && obj.stroke.enabled) {
                    ctx.stroke();
                }
            }

            // 選択ボックス
            if (isSelected) {
                ctx.strokeStyle = '#0099ff';
                ctx.lineWidth = 1;
                ctx.setLineDash([]);

                const minX = Math.min(x, x + w);
                const minY = Math.min(y, y + h);
                const maxX = Math.max(x, x + w);
                const maxY = Math.max(y, y + h);

                ctx.strokeRect(minX - 2, minY - 2, maxX - minX + 4, maxY - minY + 4);

                // ハンドル
                const handleSize = 6;
                const handles = [
                    [minX - 2, minY - 2],
                    [maxX + 2, minY - 2],
                    [minX - 2, maxY + 2],
                    [maxX + 2, maxY + 2]
                ];

                ctx.fillStyle = '#ffffff';
                ctx.strokeStyle = '#0099ff';
                ctx.lineWidth = 1;
                handles.forEach(([hx, hy]) => {
                    ctx.fillRect(hx - handleSize/2, hy - handleSize/2, handleSize, handleSize);
                    ctx.strokeRect(hx - handleSize/2, hy - handleSize/2, handleSize, handleSize);
                });
            }

            ctx.restore();
        }

        function drawCheckerboardBackground() {
            const squareSize = 16;
            const color1 = '#3a3a3a';
            const color2 = '#2a2a2a';

            for (let y = 0; y < canvas.height; y += squareSize) {
                for (let x = 0; x < canvas.width; x += squareSize) {
                    const isEven = ((x / squareSize) + (y / squareSize)) % 2 === 0;
                    ctx.fillStyle = isEven ? color1 : color2;
                    ctx.fillRect(x, y, squareSize, squareSize);
                }
            }
        }

        function drawSafeMargins() {
            const actionMargin = parseFloat(document.getElementById('actionSafeMargin').value) / 100;
            const titleMargin = parseFloat(document.getElementById('titleSafeMargin').value) / 100;
            const marginColor = document.getElementById('safeMarginColor').value;
            const opacity = parseFloat(document.getElementById('safeMarginOpacity').value) / 100;

            const rgb = hexToRgb(marginColor);
            ctx.strokeStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`;
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);

            // アクションセーフ
            const actionX = canvas.width * actionMargin;
            const actionY = canvas.height * actionMargin;
            const actionW = canvas.width * (1 - actionMargin * 2);
            const actionH = canvas.height * (1 - actionMargin * 2);
            ctx.strokeRect(actionX, actionY, actionW, actionH);

            // タイトルセーフ
            const titleX = canvas.width * titleMargin;
            const titleY = canvas.height * titleMargin;
            const titleW = canvas.width * (1 - titleMargin * 2);
            const titleH = canvas.height * (1 - titleMargin * 2);
            ctx.strokeRect(titleX, titleY, titleW, titleH);

            ctx.setLineDash([]);
        }

        function drawTextObject(obj, isSelected) {
            if (!obj.text && !isTyping) return;

            ctx.save();

            // 描画設定
            ctx.font = `${obj.fontSize}px "${obj.fontFamily}"`;
            ctx.textBaseline = 'top';
            ctx.textAlign = 'left';

            const text = obj.text || '|';

            if (obj.vertical) {
                // 縦書き描画
                const chars = text.split('');
                for (let i = 0; i < chars.length; i++) {
                    ctx.save();

                    // 各文字の位置
                    const charY = obj.y + (i * obj.fontSize);
                    ctx.translate(obj.x, charY);
                    ctx.rotate(obj.rotation * Math.PI / 180);

                    const char = chars[i];

                    // シャドウ描画
                    if (obj.shadow && obj.shadow.enabled) {
                        const angle = obj.shadow.angle * Math.PI / 180;
                        const offsetX = Math.cos(angle) * obj.shadow.distance;
                        const offsetY = Math.sin(angle) * obj.shadow.distance;
                        const opacity = obj.shadow.opacity / 100;

                        const rgb = hexToRgb(obj.shadow.color);
                        ctx.fillStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`;
                        ctx.fillText(char, offsetX, offsetY);
                    }

                    // ストローク描画
                    if (obj.strokes) {
                        for (let j = obj.strokes.length - 1; j >= 0; j--) {
                            const stroke = obj.strokes[j];
                            if (stroke.enabled && stroke.size > 0) {
                                ctx.strokeStyle = stroke.color;
                                ctx.lineWidth = stroke.size;
                                ctx.lineJoin = 'round';
                                ctx.miterLimit = 2;
                                ctx.strokeText(char, 0, 0);
                            }
                        }
                    }

                    // 塗り描画
                    if (obj.fill && obj.fill.enabled) {
                        const opacity = obj.fill.opacity / 100;
                        if (opacity < 1) {
                            const rgb = hexToRgb(obj.fill.color);
                            ctx.fillStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`;
                        } else {
                            ctx.fillStyle = obj.fill.color;
                        }
                        ctx.fillText(char, 0, 0);
                    }

                    ctx.restore();
                }
            } else {
                // 横書き描画
                const scaleX = obj.scaleX / 100;
                ctx.translate(obj.x, obj.y);
                ctx.rotate(obj.rotation * Math.PI / 180);
                ctx.scale(scaleX, 1);

                // シャドウ描画
                if (obj.shadow && obj.shadow.enabled) {
                    const angle = obj.shadow.angle * Math.PI / 180;
                    const offsetX = Math.cos(angle) * obj.shadow.distance / scaleX;
                    const offsetY = Math.sin(angle) * obj.shadow.distance;
                    const opacity = obj.shadow.opacity / 100;

                    const rgb = hexToRgb(obj.shadow.color);
                    ctx.fillStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`;
                    ctx.fillText(text, offsetX, offsetY);
                }

                // ストローク描画（外側から内側へ）
                if (obj.strokes) {
                    for (let i = obj.strokes.length - 1; i >= 0; i--) {
                        const stroke = obj.strokes[i];
                        if (stroke.enabled && stroke.size > 0) {
                            ctx.strokeStyle = stroke.color;
                            ctx.lineWidth = stroke.size;
                            ctx.lineJoin = 'round';
                            ctx.miterLimit = 2;
                            ctx.strokeText(text, 0, 0);
                        }
                    }
                }

                // フェース（塗り）描画
                if (obj.fill && obj.fill.enabled) {
                    const opacity = obj.fill.opacity / 100;
                    if (opacity < 1) {
                        const rgb = hexToRgb(obj.fill.color);
                        ctx.fillStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`;
                    } else {
                        ctx.fillStyle = obj.fill.color;
                    }
                    ctx.fillText(text, 0, 0);
                }
            }

            ctx.restore();

            // 選択ボックス描画（レガシータイトルと同じスタイル）
            if (isSelected) {
                const metrics = measureText(obj);
                ctx.strokeStyle = '#0099ff';
                ctx.lineWidth = 1;
                ctx.setLineDash([]);
                ctx.strokeRect(obj.x - 2, obj.y - 2, metrics.width + 4, metrics.height + 4);

                // ハンドル（レガシータイトル風）
                const handleSize = 6;
                const handles = [
                    [obj.x - 2, obj.y - 2], // 左上
                    [obj.x + metrics.width + 2, obj.y - 2], // 右上
                    [obj.x - 2, obj.y + metrics.height + 2], // 左下
                    [obj.x + metrics.width + 2, obj.y + metrics.height + 2], // 右下
                ];

                ctx.fillStyle = '#ffffff';
                ctx.strokeStyle = '#0099ff';
                ctx.lineWidth = 1;
                handles.forEach(([hx, hy]) => {
                    ctx.fillRect(hx - handleSize/2, hy - handleSize/2, handleSize, handleSize);
                    ctx.strokeRect(hx - handleSize/2, hy - handleSize/2, handleSize, handleSize);
                });
            }
        }

        function drawTextSelection() {
            if (!selectedObject) return;

            ctx.save();
            ctx.font = `${selectedObject.fontSize}px "${selectedObject.fontFamily}"`;

            const start = Math.min(selectionStart, selectionEnd);
            const end = Math.max(selectionStart, selectionEnd);

            const textBeforeSelection = selectedObject.text.substring(0, start);
            const selectedText = selectedObject.text.substring(start, end);

            const metricsBeforeSelection = ctx.measureText(textBeforeSelection);
            const metricsSelectedText = ctx.measureText(selectedText);

            const selectionX = selectedObject.x + metricsBeforeSelection.width * (selectedObject.scaleX / 100);
            const selectionWidth = metricsSelectedText.width * (selectedObject.scaleX / 100);
            const selectionY = selectedObject.y;
            const selectionHeight = selectedObject.fontSize;

            // 青いハイライト（レガシータイトルと同じ）
            ctx.fillStyle = 'rgba(0, 102, 204, 0.3)';
            ctx.fillRect(selectionX, selectionY, selectionWidth, selectionHeight);

            ctx.restore();
        }

        function drawCursor() {
            if (!selectedObject) return;

            ctx.save();
            ctx.font = `${selectedObject.fontSize}px "${selectedObject.fontFamily}"`;
            const textBeforeCursor = selectedObject.text.substring(0, cursorPosition);
            const metrics = ctx.measureText(textBeforeCursor);
            const cursorX = selectedObject.x + metrics.width * (selectedObject.scaleX / 100);
            const cursorY = selectedObject.y;

            // より目立つカーソル（レガシータイトルと同じ）
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(cursorX, cursorY);
            ctx.lineTo(cursorX, cursorY + selectedObject.fontSize);
            ctx.stroke();
            ctx.restore();
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 0, g: 0, b: 0 };
        }

        // プロパティセクションの折りたたみ
        document.querySelectorAll('.property-section-header').forEach(header => {
            header.addEventListener('click', () => {
                header.classList.toggle('collapsed');
                const content = header.nextElementSibling;
                content.classList.toggle('hidden');
            });
        });

        // PRTL書き出し（既存のPRTLGeneratorV2を使用）
        function exportPRTL() {
            if (textObjects.length === 0) {
                alert('テキストオブジェクトがありません');
                return;
            }

            // 最初のテキストオブジェクトを使用（複数対応は後で実装）
            const obj = textObjects[0];

            const config = {
                width: canvas.width,
                height: canvas.height,
                text: obj.text,
                fontFamily: obj.fontFamily,
                fontSize: obj.fontSize,
                scaleX: obj.scaleX,
                posX: obj.x,
                posY: obj.y,
                textAlign: 'left',
                fillType: 'solid',
                fillColor: obj.fill.color,
                stroke4_enabled: obj.strokes[3].enabled,
                stroke4_size: obj.strokes[3].size,
                stroke4_color: obj.strokes[3].color,
                stroke3_enabled: obj.strokes[2].enabled,
                stroke3_size: obj.strokes[2].size,
                stroke3_color: obj.strokes[2].color,
                stroke2_enabled: obj.strokes[1].enabled,
                stroke2_size: obj.strokes[1].size,
                stroke2_color: obj.strokes[1].color,
                stroke1_enabled: obj.strokes[0].enabled,
                stroke1_size: obj.strokes[0].size,
                stroke1_color: obj.strokes[0].color,
                shadow_enabled: obj.shadow.enabled,
                shadow_offset: obj.shadow.distance,
                shadow_angle: obj.shadow.angle,
                shadow_color: obj.shadow.color,
                shadow_opacity: obj.shadow.opacity
            };

            const generator = new PRTLGeneratorV2();
            const prtlXML = generator.generatePRTL(config);

            // UTF-8エンコード
            const encoder = new TextEncoder();
            const utf8Array = encoder.encode(prtlXML);

            const blob = new Blob([utf8Array], { type: 'application/octet-stream' });
            const link = document.createElement('a');
            link.download = `NLT_${Date.now()}.prtl`;
            link.href = URL.createObjectURL(blob);
            link.click();

            console.log('✅ PRTL書き出し完了');
        }

        // PRTLGeneratorV2クラス（既存のものを再利用）
        class PRTLGeneratorV2 {
            constructor() {
                this.nextStyleID = 4096;
                this.nextShaderID = 4096;
                this.nextTextDescID = 4096;
            }

            generatePRTL(config) {
                const width = config.width || 1920;
                const height = config.height || 1080;

                const textDescriptions = this._buildTextDescriptions(config);
                const shaders = this._buildShaders(config);
                const styles = this._buildStyles(config);
                const layers = this._buildLayers(config);

                return this._buildPRTLDocument(width, height, textDescriptions, shaders, styles, layers);
            }

            _buildPRTLDocument(width, height, textDescriptions, shaders, styles, layers) {
                return `<?xml version="1.0" encoding="UTF-16" ?>` +
                    `<Adobe_Root>` +
                        `<Adobe_Title>` +
                            `<Version>20080702</Version>` +
                            `<Motion_Settings>` +
                                `<Play_Forward>true</Play_Forward>` +
                                `<Start_on_Screen>false</Start_on_Screen>` +
                                `<Pre_Roll>0</Pre_Roll>` +
                                `<Ease_In>0</Ease_In>` +
                                `<End_off_Screen>false</End_off_Screen>` +
                                `<Post_Roll>0</Post_Roll>` +
                                `<Ease_Out>0</Ease_Out>` +
                            `</Motion_Settings>` +
                        `</Adobe_Title>` +
                        `<InscriberLayouts Version="1.0">` +
                            `<Layout>` +
                                this._buildLayoutHeader(width, height) +
                                textDescriptions +
                                styles +
                                shaders +
                                this._buildTextures() +
                                this._buildLogos() +
                                layers +
                                this._buildVLS() +
                            `</Layout>` +
                        `</InscriberLayouts>` +
                    `</Adobe_Root>`;
            }

            _buildLayoutHeader(width, height) {
                return `<LayoutEffectInfo Version="2">` +
                        `<EffectType>0</EffectType>` +
                        `<Indic>false</Indic>` +
                        `<Ligatures>false</Ligatures>` +
                        `<HindiDigits>false</HindiDigits>` +
                    `</LayoutEffectInfo>` +
                    `<LayoutDimension Version="2">` +
                        `<pXPIXELS>${width}</pXPIXELS>` +
                        `<pYLINES>${height}</pYLINES>` +
                        `<pSCREENAR>1</pSCREENAR>` +
                        `<growthDirection>growRightDown</growthDirection>` +
                    `</LayoutDimension>` +
                    `<LayoutAttributes>` +
                        `<SafeTitleArea>` +
                            `<left>0.1</left><top>0.1</top><right>0.9</right><bottom>0.9</bottom>` +
                        `</SafeTitleArea>` +
                        `<SafeActionArea>` +
                            `<left>0.05</left><top>0.05</top><right>0.95</right><bottom>0.95</bottom>` +
                        `</SafeActionArea>` +
                    `</LayoutAttributes>` +
                    `<Background Version="4">` +
                        `<ShaderReference>4098</ShaderReference>` +
                        `<On>false</On>` +
                        `<paintingRange>normalLayout</paintingRange>` +
                    `</Background>` +
                    `<DefaultStyle><Reference>${this.nextStyleID}</Reference></DefaultStyle>` +
                    `<DefaultTextDescription><Reference>${this.nextTextDescID}</Reference></DefaultTextDescription>` +
                    `<GraphicObjectDefaults>` +
                        `<endCapType>square</endCapType>` +
                        `<joinTypeClosed>round</joinTypeClosed>` +
                        `<joinTypeOpen>round</joinTypeOpen>` +
                        `<lineWidth>5</lineWidth>` +
                        `<miterLimit>5</miterLimit>` +
                        `<windBeziers>false</windBeziers>` +
                        `<roundCornerFillets>37.5 37.5 37.5 37.5 37.5 37.5 37.5 37.5 </roundCornerFillets>` +
                        `<clippedCornerFillets>37.5 37.5 37.5 37.5 37.5 37.5 37.5 37.5 </clippedCornerFillets>` +
                    `</GraphicObjectDefaults>` +
                    this._buildTextChainDefaults();
            }

            _buildTextChainDefaults() {
                const defaults = `<leading>0</leading>` +
                    `<boxCanGrow>false</boxCanGrow>` +
                    `<wordWrap>true</wordWrap>` +
                    `<lockedLinesX>false</lockedLinesX>` +
                    `<lockedLinesY>false</lockedLinesY>` +
                    `<Alignment>left</Alignment>` +
                    `<tabModeStyle>Word</tabModeStyle>` +
                    `<implicitTabSpacing>100</implicitTabSpacing>` +
                    `<implicitTabType>left</implicitTabType>` +
                    `<rtl>false</rtl>` +
                    `<tabs></tabs>`;

                return `<TextChainDefaults>` +
                    `<normal>${defaults}</normal>` +
                    `<boxNormal>${defaults.replace('<wordWrap>true</wordWrap>', '<wordWrap>true</wordWrap>').replace('<lockedLinesX>false</lockedLinesX>', '<lockedLinesX>true</lockedLinesX>').replace('<lockedLinesY>false</lockedLinesY>', '<lockedLinesY>true</lockedLinesY>')}</boxNormal>` +
                    `<blockNormal>${defaults.replace('<wordWrap>true</wordWrap>', '<wordWrap>false</wordWrap>').replace('<lockedLinesX>false</lockedLinesX>', '<lockedLinesX>true</lockedLinesX>').replace('<lockedLinesY>false</lockedLinesY>', '<lockedLinesY>true</lockedLinesY>')}</blockNormal>` +
                    `<spline>${defaults}</spline>` +
                `</TextChainDefaults>`;
            }

            _buildTextDescriptions(config) {
                const ref = this.nextTextDescID;
                const fontFamily = config.fontFamily || 'Yu Gothic UI';
                const fontSize = config.fontSize || 72;
                const scaleX = config.scaleX || 100;

                return `<TextDescriptions Version="4">` +
                    `<TextDescription Reference="${ref}">` +
                        `<TypeSpec>` +
                            `<size>${fontSize * 8}</size>` +
                            `<txHeight>${fontSize}</txHeight>` +
                            `<txKern>0</txKern>` +
                            `<baselineShift>0</baselineShift>` +
                            `<leading>0</leading>` +
                            `<txSCaps>${fontSize}</txSCaps>` +
                            `<txSCapsOn>false</txSCapsOn>` +
                            `<txSlant>0</txSlant>` +
                            `<txUnderline>false</txUnderline>` +
                            `<txWidth>${scaleX}</txWidth>` +
                            `<linked>false</linked>` +
                            `<fiBold>0</fiBold>` +
                            `<fiItalic>0</fiItalic>` +
                            `<fifullName>${this._escapeXML(fontFamily)}</fifullName>` +
                            `<fifontFamilyName>${this._escapeXML(fontFamily)}</fifontFamilyName>` +
                            `<fifontStyle>Regular</fifontStyle>` +
                            `<fifontType>5</fifontType>` +
                            `<ficategory>1</ficategory>` +
                        `</TypeSpec>` +
                    `</TextDescription>` +
                `</TextDescriptions>`;
            }

            _buildStyles(config) {
                const styleID = this.nextStyleID;
                const textDescRef = this.nextTextDescID;

                let fragments = '';
                let shaderRefs = {};
                let nextPainter = 10;
                let nextShaderRef = this.nextShaderID;

                if (config.stroke4_enabled) {
                    fragments += `<Fragment>` +
                        `<size>${config.stroke4_size}</size>` +
                        `<offset>0</offset>` +
                        `<angle>0</angle>` +
                        `<ghost>false</ghost>` +
                        `<isExtendedShadowFragment>false</isExtendedShadowFragment>` +
                        `<eFragmentType>2</eFragmentType>` +
                        `<fragmentOff>false</fragmentOff>` +
                        `<placeHolder>false</placeHolder>` +
                        `<annotation>4</annotation>` +
                        `<placeHolderShaderIndex>4294967295</placeHolderShaderIndex>` +
                        `<painterMix>${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} </painterMix>` +
                    `</Fragment>`;
                    shaderRefs[nextPainter++] = nextShaderRef++;
                }

                if (config.stroke3_enabled) {
                    fragments += `<Fragment>` +
                        `<size>${config.stroke3_size}</size>` +
                        `<offset>0</offset>` +
                        `<angle>0</angle>` +
                        `<ghost>false</ghost>` +
                        `<isExtendedShadowFragment>false</isExtendedShadowFragment>` +
                        `<eFragmentType>2</eFragmentType>` +
                        `<fragmentOff>false</fragmentOff>` +
                        `<placeHolder>false</placeHolder>` +
                        `<annotation>3</annotation>` +
                        `<placeHolderShaderIndex>4294967295</placeHolderShaderIndex>` +
                        `<painterMix>${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} </painterMix>` +
                    `</Fragment>`;
                    shaderRefs[nextPainter++] = nextShaderRef++;
                }

                if (config.stroke2_enabled) {
                    fragments += `<Fragment>` +
                        `<size>${config.stroke2_size}</size>` +
                        `<offset>0</offset>` +
                        `<angle>0</angle>` +
                        `<ghost>false</ghost>` +
                        `<isExtendedShadowFragment>false</isExtendedShadowFragment>` +
                        `<eFragmentType>2</eFragmentType>` +
                        `<fragmentOff>false</fragmentOff>` +
                        `<placeHolder>false</placeHolder>` +
                        `<annotation>2</annotation>` +
                        `<placeHolderShaderIndex>4294967295</placeHolderShaderIndex>` +
                        `<painterMix>${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} </painterMix>` +
                    `</Fragment>`;
                    shaderRefs[nextPainter++] = nextShaderRef++;
                }

                if (config.stroke1_enabled) {
                    fragments += `<Fragment>` +
                        `<size>${config.stroke1_size}</size>` +
                        `<offset>0</offset>` +
                        `<angle>0</angle>` +
                        `<ghost>false</ghost>` +
                        `<isExtendedShadowFragment>false</isExtendedShadowFragment>` +
                        `<eFragmentType>2</eFragmentType>` +
                        `<fragmentOff>false</fragmentOff>` +
                        `<placeHolder>false</placeHolder>` +
                        `<annotation>1</annotation>` +
                        `<placeHolderShaderIndex>4294967295</placeHolderShaderIndex>` +
                        `<painterMix>${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} </painterMix>` +
                    `</Fragment>`;
                    shaderRefs[nextPainter++] = nextShaderRef++;
                }

                fragments += `<Fragment>` +
                    `<size>0</size>` +
                    `<offset>0</offset>` +
                    `<angle>0</angle>` +
                    `<ghost>false</ghost>` +
                    `<isExtendedShadowFragment>false</isExtendedShadowFragment>` +
                    `<eFragmentType>0</eFragmentType>` +
                    `<fragmentOff>false</fragmentOff>` +
                    `<placeHolder>false</placeHolder>` +
                    `<annotation>65538</annotation>` +
                    `<placeHolderShaderIndex>4294967295</placeHolderShaderIndex>` +
                    `<painterMix>15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 </painterMix>` +
                `</Fragment>`;
                shaderRefs[15] = nextShaderRef++;

                const shadowOff = config.shadow_enabled ? 'false' : 'true';
                fragments += `<Fragment>` +
                    `<size>0</size>` +
                    `<offset>${config.shadow_offset || 10}</offset>` +
                    `<angle>${config.shadow_angle || -45}</angle>` +
                    `<ghost>false</ghost>` +
                    `<isExtendedShadowFragment>true</isExtendedShadowFragment>` +
                    `<eFragmentType>0</eFragmentType>` +
                    `<fragmentOff>${shadowOff}</fragmentOff>` +
                    `<placeHolder>false</placeHolder>` +
                    `<annotation>65537</annotation>` +
                    `<placeHolderShaderIndex>4294967295</placeHolderShaderIndex>` +
                    `<painterMix>0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 </painterMix>` +
                `</Fragment>`;
                if (config.shadow_enabled) {
                    shaderRefs[0] = nextShaderRef++;
                }

                let shaderList = '';
                for (let i = 0; i <= 15; i++) {
                    const ref = shaderRefs[i] || 0;
                    shaderList += `<ShaderRef PainterNumber="${i}"><shaderRef>${ref}</shaderRef></ShaderRef>`;
                }
                shaderList += `<ShaderRef PainterNumber="-1"><shaderRef>0</shaderRef></ShaderRef>`;

                config._shaderRefs = shaderRefs;
                config._nextShaderRef = nextShaderRef;

                return `<Styles>` +
                    `<Style ID="${styleID}">` +
                        `<StyleBase Version="4">` +
                            `<type>50000</type>` +
                            `<positionDominance>0</positionDominance>` +
                            `<lineGradient>false</lineGradient>` +
                            `<styleRef>${styleID}</styleRef>` +
                            `<faceDistortX>0</faceDistortX>` +
                            `<faceDistortY>0</faceDistortY>` +
                            `<shadow_softness>30</shadow_softness>` +
                            `<personality>0</personality>` +
                            `<linked>false</linked>` +
                            `<EmbellishmentSizeRule>false</EmbellishmentSizeRule>` +
                            `<PainterRampType>Basic</PainterRampType>` +
                        `</StyleBase>` +
                        `<FragmentList Version="5">` +
                            fragments +
                        `</FragmentList>` +
                        `<ShaderList Version="1">` +
                            shaderList +
                        `</ShaderList>` +
                    `</Style>` +
                `</Styles>`;
            }

            _buildShaders(config) {
                let shaders = '<Shaders>';
                const shaderRefs = config._shaderRefs || {};

                for (const [painter, shaderRef] of Object.entries(shaderRefs)) {
                    const painterNum = parseInt(painter);

                    if (painterNum === 15) {
                        shaders += this._buildFaceShader(shaderRef, config);
                    } else if (painterNum === 0) {
                        shaders += this._buildShadowShader(shaderRef, config);
                    } else if (painterNum >= 10 && painterNum <= 13) {
                        const strokeNum = 14 - painterNum;
                        const strokeColor = config[`stroke${strokeNum}_color`] || '#000000';
                        shaders += this._buildStrokeShader(shaderRef, strokeColor);
                    }
                }

                shaders += '</Shaders>';
                return shaders;
            }

            _buildStrokeShader(shaderRef, color) {
                const rgb = this._parseColor(color);

                let colorSpecs = '';
                for (let i = 0; i <= 4; i++) {
                    colorSpecs += `<ColorSpec index="${i}">` +
                        `<red>${rgb.r}</red>` +
                        `<green>${rgb.g}</green>` +
                        `<blue>${rgb.b}</blue>` +
                        `<xpar>0</xpar>` +
                    `</ColorSpec>`;
                }

                return `<Shader Version="4">` +
                    `<cReference>${shaderRef}</cReference>` +
                    `<textureRef>0</textureRef>` +
                    `<colorOption>4</colorOption>` +
                    `<shaderOn>true</shaderOn>` +
                    `<glintSize>10</glintSize>` +
                    `<glintOffset>0</glintOffset>` +
                    `<rampPosTop>75</rampPosTop>` +
                    `<rampPosBottom>25</rampPosBottom>` +
                    `<rampAngle>0</rampAngle>` +
                    `<bevelBalance>0</bevelBalance>` +
                    `<rampCycle>0</rampCycle>` +
                    `<classicStyle>0</classicStyle>` +
                    `<rampType>0</rampType>` +
                    colorSpecs +
                    `<glintAngle>0</glintAngle>` +
                    `<bevelSize>0</bevelSize>` +
                    `<bevelDirection>0</bevelDirection>` +
                    `<bevelPipe>false</bevelPipe>` +
                    `<bevelAngle>0</bevelAngle>` +
                    `<bevelShape>1</bevelShape>` +
                    `<bevelShining>0</bevelShining>` +
                    `<bevelLight>false</bevelLight>` +
                    `<bevelMerge>true</bevelMerge>` +
                    `<sheenOn>false</sheenOn>` +
                `</Shader>`;
            }

            _buildFaceShader(shaderRef, config) {
                const rgb = this._parseColor(config.fillColor || '#ffffff');
                let colorSpecs = '';
                for (let i = 0; i <= 4; i++) {
                    colorSpecs += `<ColorSpec index="${i}">` +
                        `<red>${rgb.r}</red>` +
                        `<green>${rgb.g}</green>` +
                        `<blue>${rgb.b}</blue>` +
                        `<xpar>0</xpar>` +
                    `</ColorSpec>`;
                }

                return `<Shader Version="4">` +
                    `<cReference>${shaderRef}</cReference>` +
                    `<textureRef>0</textureRef>` +
                    `<colorOption>4</colorOption>` +
                    `<shaderOn>true</shaderOn>` +
                    `<glintSize>10</glintSize>` +
                    `<glintOffset>0</glintOffset>` +
                    `<rampPosTop>75</rampPosTop>` +
                    `<rampPosBottom>25</rampPosBottom>` +
                    `<rampAngle>0</rampAngle>` +
                    `<bevelBalance>0</bevelBalance>` +
                    `<rampCycle>0</rampCycle>` +
                    `<classicStyle>0</classicStyle>` +
                    `<rampType>0</rampType>` +
                    colorSpecs +
                    `<glintAngle>0</glintAngle>` +
                    `<bevelSize>0</bevelSize>` +
                    `<bevelDirection>0</bevelDirection>` +
                    `<bevelPipe>false</bevelPipe>` +
                    `<bevelAngle>0</bevelAngle>` +
                    `<bevelShape>1</bevelShape>` +
                    `<bevelShining>0</bevelShining>` +
                    `<bevelLight>false</bevelLight>` +
                    `<bevelMerge>true</bevelMerge>` +
                    `<sheenOn>false</sheenOn>` +
                `</Shader>`;
            }

            _buildShadowShader(shaderRef, config) {
                const rgb = this._parseColor(config.shadow_color || '#000000');
                const opacity = config.shadow_opacity || 50;
                const xpar = Math.round((100 - opacity) * 255 / 100);

                let colorSpecs = '';
                for (let i = 0; i <= 4; i++) {
                    colorSpecs += `<ColorSpec index="${i}">` +
                        `<red>${rgb.r}</red>` +
                        `<green>${rgb.g}</green>` +
                        `<blue>${rgb.b}</blue>` +
                        `<xpar>${i === 0 ? xpar : 0}</xpar>` +
                    `</ColorSpec>`;
                }

                return `<Shader Version="4">` +
                    `<cReference>${shaderRef}</cReference>` +
                    `<textureRef>0</textureRef>` +
                    `<colorOption>0</colorOption>` +
                    `<shaderOn>true</shaderOn>` +
                    `<glintSize>0</glintSize>` +
                    `<glintOffset>0</glintOffset>` +
                    `<rampPosTop>75</rampPosTop>` +
                    `<rampPosBottom>25</rampPosBottom>` +
                    `<rampAngle>0</rampAngle>` +
                    `<bevelBalance>0</bevelBalance>` +
                    `<rampCycle>0</rampCycle>` +
                    `<classicStyle>0</classicStyle>` +
                    `<rampType>0</rampType>` +
                    colorSpecs +
                    `<glintAngle>0</glintAngle>` +
                    `<bevelSize>0</bevelSize>` +
                    `<bevelDirection>0</bevelDirection>` +
                    `<bevelPipe>false</bevelPipe>` +
                    `<bevelAngle>0</bevelAngle>` +
                    `<bevelShape>1</bevelShape>` +
                    `<bevelShining>0</bevelShining>` +
                    `<bevelLight>false</bevelLight>` +
                    `<bevelMerge>true</bevelMerge>` +
                    `<sheenOn>false</sheenOn>` +
                `</Shader>`;
            }

            _buildLayers(config) {
                const text = config.text || 'サンプル';
                const posX = config.posX || 960;
                const posY = config.posY || 540;
                const textAlign = config.textAlign || 'left';
                const styleRef = this.nextStyleID;
                const textRef = this.nextTextDescID;
                const fontSize = config.fontSize || 72;
                const txBase = fontSize * 1.2;

                return `<Layers>` +
                    `<Layer>` +
                        `<DrawPage></DrawPage>` +
                        `<TextPage>` +
                            `<TextChain>` +
                                `<ChainProperty>` +
                                    `<Position><x>${posX}</x><y>${posY}</y></Position>` +
                                    `<Size><x>1000</x><y>200</y></Size>` +
                                    `<wordWrap>false</wordWrap>` +
                                    `<Alignment>${textAlign}</Alignment>` +
                                `</ChainProperty>` +
                                `<ChainTabs></ChainTabs>` +
                                `<TextLine Version="2" objectID="1" persistentID="1">` +
                                    `<BaseProperties Version="5">` +
                                        `<txBase>${txBase}</txBase>` +
                                        `<XPos>${posX}</XPos>` +
                                        `<angle>0</angle>` +
                                        `<verticalText>false</verticalText>` +
                                        `<objectLeading>0</objectLeading>` +
                                    `</BaseProperties>` +
                                    `<EnclosingObjectType>block</EnclosingObjectType>` +
                                    `<Alignment>${textAlign}</Alignment>` +
                                    `<RTL>false</RTL>` +
                                    `<TRString>${this._escapeXML(text)}</TRString>` +
                                    `<RunLengthEncodedCharacterAttributes>` +
                                        `<CharacterAttributes ` +
                                            `RunCount="${text.length}" ` +
                                            `StyleRef="${styleRef}" ` +
                                            `TextRef="${textRef}" ` +
                                            `TXKerning="0" ` +
                                            `TXPostKerning="0" ` +
                                            `BaselineShifting="0" />` +
                                    `</RunLengthEncodedCharacterAttributes>` +
                                    `<tagName></tagName>` +
                                `</TextLine>` +
                            `</TextChain>` +
                        `</TextPage>` +
                        `<MergeGroups></MergeGroups>` +
                    `</Layer>` +
                `</Layers>`;
            }

            _buildTextures() {
                return `<Textures></Textures>`;
            }

            _buildLogos() {
                return `<Logos></Logos>`;
            }

            _buildVLS() {
                return `<VLS>` +
                    `<FileReference Version="1">` +
                        `<fileString></fileString>` +
                        `<seClass>2</seClass>` +
                        `<seCode>1000</seCode>` +
                    `</FileReference>` +
                `</VLS>`;
            }

            _parseColor(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : { r: 255, g: 255, b: 255 };
            }

            _escapeXML(str) {
                if (!str) return '';
                return String(str)
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&apos;');
            }
        }

        // 整列関数
        function alignCenter() {
            if (!selectedObject) {
                alert('オブジェクトを選択してください');
                return;
            }

            const metrics = measureText(selectedObject);
            selectedObject.x = (canvas.width - metrics.width) / 2;
            updatePropertiesPanel();
            render();
        }

        function alignMiddle() {
            if (!selectedObject) {
                alert('オブジェクトを選択してください');
                return;
            }

            const metrics = measureText(selectedObject);
            selectedObject.y = (canvas.height - metrics.height) / 2 + metrics.height;
            updatePropertiesPanel();
            render();
        }

        // ビューコントロール関数
        function zoomIn() {
            viewportScale *= 1.2;
            applyViewportTransform();
        }

        function zoomOut() {
            viewportScale /= 1.2;
            applyViewportTransform();
        }

        function fitToScreen() {
            const container = document.querySelector('.canvas-area');
            const scaleX = (container.clientWidth - 40) / canvas.width;
            const scaleY = (container.clientHeight - 40) / canvas.height;
            viewportScale = Math.min(scaleX, scaleY);
            viewportOffsetX = 0;
            viewportOffsetY = 0;
            applyViewportTransform();
        }

        function resetView() {
            viewportScale = 1;
            viewportOffsetX = 0;
            viewportOffsetY = 0;
            applyViewportTransform();
        }

        function applyViewportTransform() {
            canvas.style.transform = `scale(${viewportScale}) translate(${viewportOffsetX}px, ${viewportOffsetY}px)`;
        }

        // キーボードショートカット
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey || e.metaKey) {
                if (e.key === '=' || e.key === '+') {
                    e.preventDefault();
                    zoomIn();
                } else if (e.key === '-') {
                    e.preventDefault();
                    zoomOut();
                } else if (e.key === '0') {
                    e.preventDefault();
                    fitToScreen();
                } else if (e.key === 'r' || e.key === 'R') {
                    e.preventDefault();
                    resetView();
                }
            }
        });

        // 初期表示を画面に合わせる
        setTimeout(fitToScreen, 100);

        // 初期レンダリング
        render();
    </script>
</body>
</html>

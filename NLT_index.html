<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NLT - Neo Legacy Title Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: #2d2d2d;
            color: #e0e0e0;
            overflow: hidden;
            height: 100vh;
        }

        /* „É°„Ç§„É≥„Ç≥„É≥„ÉÜ„Éä */
        .main-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        /* ‰∏äÈÉ®„ÉÑ„Éº„É´„Éê„Éº */
        .toolbar {
            background: #1e1e1e;
            padding: 8px 12px;
            border-bottom: 1px solid #000;
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .tool-btn {
            width: 32px;
            height: 32px;
            background: #3a3a3a;
            border: 1px solid #555;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #aaa;
            font-size: 18px;
            transition: all 0.2s;
        }

        .tool-btn:hover {
            background: #4a4a4a;
            color: #fff;
        }

        .tool-btn.active {
            background: #0066cc;
            color: #fff;
            border-color: #0077ee;
        }

        .toolbar-separator {
            width: 1px;
            height: 24px;
            background: #555;
            margin: 0 4px;
        }

        /* „Ç≥„É≥„ÉÜ„É≥„ÉÑ„Ç®„É™„Ç¢ */
        .content-area {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        /* Â∑¶ÂÅ¥„ÉÑ„Éº„É´„Éê„ÉºÔºà„É¨„Ç¨„Ç∑„Éº„Çø„Ç§„Éà„É´„Å®Âêå„Åò„É¨„Ç§„Ç¢„Ç¶„ÉàÔºâ */
        .left-toolbar {
            width: 50px;
            background: #1e1e1e;
            border-right: 1px solid #000;
            display: flex;
            flex-direction: column;
            padding: 8px 0;
            gap: 4px;
            align-items: center;
        }

        /* „Ç≠„É£„É≥„Éê„Çπ„Ç®„É™„Ç¢ */
        .canvas-area {
            flex: 1;
            background: #141414;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        #canvas {
            background: repeating-conic-gradient(
                #2a2a2a 0% 25%,
                #1e1e1e 0% 50%
            ) 50% / 16px 16px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            cursor: crosshair;
            max-width: 100%;
            max-height: 100%;
        }

        #canvas.selection-mode {
            cursor: default;
        }

        /* Âè≥ÂÅ¥„Éó„É≠„Éë„ÉÜ„Ç£„Éë„Éç„É´ */
        .properties-panel {
            width: 280px;
            background: #252525;
            border-left: 1px solid #000;
            overflow-y: auto;
            padding: 12px;
        }

        .property-section {
            margin-bottom: 16px;
            background: #2d2d2d;
            border-radius: 4px;
            overflow: hidden;
        }

        .property-section-header {
            background: #1e1e1e;
            padding: 8px 12px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
            cursor: pointer;
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .property-section-header:hover {
            background: #252525;
        }

        .property-section-header::after {
            content: '‚ñº';
            font-size: 8px;
            transition: transform 0.2s;
        }

        .property-section-header.collapsed::after {
            transform: rotate(-90deg);
        }

        .property-section-content {
            padding: 12px;
            display: block;
        }

        .property-section-content.hidden {
            display: none;
        }

        .property-row {
            margin-bottom: 10px;
        }

        .property-row label {
            display: block;
            font-size: 11px;
            color: #aaa;
            margin-bottom: 4px;
        }

        .property-row input,
        .property-row select {
            width: 100%;
            padding: 6px 8px;
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 3px;
            color: #fff;
            font-size: 12px;
        }

        .property-row input:focus,
        .property-row select:focus {
            outline: none;
            border-color: #0066cc;
        }

        .property-row input[type="color"] {
            height: 32px;
            padding: 2px;
            cursor: pointer;
        }

        .property-row input[type="range"] {
            padding: 0;
            accent-color: #0066cc;
        }

        .property-row input[type="checkbox"] {
            width: auto;
            margin-right: 6px;
            accent-color: #0066cc;
        }

        .property-grid-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .property-grid-3 {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 6px;
        }

        .btn {
            width: 100%;
            padding: 8px;
            background: #3a3a3a;
            border: 1px solid #555;
            border-radius: 4px;
            color: #e0e0e0;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn:hover {
            background: #4a4a4a;
        }

        .btn-primary {
            background: #0066cc;
            border-color: #0077ee;
            color: #fff;
        }

        .btn-primary:hover {
            background: #0077ee;
        }

        .value-display {
            font-size: 10px;
            color: #666;
            margin-top: 2px;
        }

        /* „ÉÑ„Éº„É´„ÉÅ„ÉÉ„Éó */
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 11px;
            pointer-events: none;
            z-index: 1000;
            display: none;
        }

        /* Èö†„ÅóIMEÂÖ•Âäõ„Éï„Ç£„Éº„É´„Éâ */
        #imeInput {
            position: absolute;
            padding: 0;
            margin: 0;
            border: none;
            background: transparent;
            color: transparent;
            outline: none;
            font-size: 16px;
            z-index: -1;
            opacity: 0;
            pointer-events: none;
            width: 1px;
            height: 1px;
        }

        #imeInput.active {
            opacity: 0;
        }

        /* „Çπ„ÇØ„É≠„Éº„É´„Éê„Éº„ÅÆ„Çπ„Çø„Ç§„É´ */
        ::-webkit-scrollbar {
            width: 12px;
        }

        ::-webkit-scrollbar-track {
            background: #1a1a1a;
        }

        ::-webkit-scrollbar-thumb {
            background: #4a4a4a;
            border-radius: 6px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #5a5a5a;
        }

        /* „ÉÜ„Ç≠„Çπ„Éà„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅÆÈÅ∏Êäû„Éè„É≥„Éâ„É´ */
        .text-selection-box {
            position: absolute;
            border: 2px solid #0066cc;
            pointer-events: none;
            z-index: 100;
        }

        .resize-handle {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #fff;
            border: 1px solid #0066cc;
            pointer-events: all;
            cursor: nwse-resize;
        }

        .resize-handle.nw { top: -4px; left: -4px; cursor: nw-resize; }
        .resize-handle.ne { top: -4px; right: -4px; cursor: ne-resize; }
        .resize-handle.sw { bottom: -4px; left: -4px; cursor: sw-resize; }
        .resize-handle.se { bottom: -4px; right: -4px; cursor: se-resize; }
    </style>
</head>
<body>
    <div class="main-container">
        <!-- ‰∏äÈÉ®„ÉÑ„Éº„É´„Éê„Éº -->
        <div class="toolbar">
            <span style="font-size: 11px; color: #888;">Ëß£ÂÉèÂ∫¶:</span>
            <input type="number" id="canvasWidth" value="1920" min="1" style="width: 70px; padding: 4px; background: #3a3a3a; border: 1px solid #555; border-radius: 3px; color: #fff; font-size: 11px;">
            <span style="font-size: 11px; color: #888;">√ó</span>
            <input type="number" id="canvasHeight" value="1080" min="1" style="width: 70px; padding: 4px; background: #3a3a3a; border: 1px solid #555; border-radius: 3px; color: #fff; font-size: 11px;">
            <div class="toolbar-separator"></div>
            <div class="tool-btn" onclick="zoomIn()" title="Êã°Â§ß (Ctrl++)">
                +
            </div>
            <div class="tool-btn" onclick="zoomOut()" title="Á∏ÆÂ∞è (Ctrl+-)">
                ‚àí
            </div>
            <div class="tool-btn" onclick="fitToScreen()" title="ÁîªÈù¢„Å´Âêà„Çè„Åõ„Çã (Ctrl+0)">
                ‚ä°
            </div>
            <div class="tool-btn" onclick="resetView()" title="„Éì„É•„Éº„É™„Çª„ÉÉ„Éà (Ctrl+R)">
                ‚ü≤
            </div>
            <div class="toolbar-separator"></div>
            <div class="tool-btn" onclick="alignCenter()" title="‰∏≠Â§ÆÊèÉ„ÅàÔºàÊ®™Ôºâ">
                ‚¨å
            </div>
            <div class="tool-btn" onclick="alignMiddle()" title="‰∏≠Â§ÆÊèÉ„ÅàÔºàÁ∏¶Ôºâ">
                ‚¨ç
            </div>
            <div class="toolbar-separator"></div>
            <div class="tool-btn" onclick="bringToFront()" title="ÊúÄÂâçÈù¢„Å∏ (Ctrl+])">
                ‚¨Ü
            </div>
            <div class="tool-btn" onclick="sendToBack()" title="ÊúÄËÉåÈù¢„Å∏ (Ctrl+[)">
                ‚¨á
            </div>
            <div class="tool-btn" onclick="bringForward()" title="ÂâçÈù¢„Å∏">
                ‚Üë
            </div>
            <div class="tool-btn" onclick="sendBackward()" title="ËÉåÈù¢„Å∏">
                ‚Üì
            </div>
            <div class="toolbar-separator"></div>
            <button class="btn btn-primary" onclick="exportPRTL()" style="width: auto; padding: 6px 12px;">PRTLÊõ∏„ÅçÂá∫„Åó</button>
        </div>

        <!-- „Ç≥„É≥„ÉÜ„É≥„ÉÑ„Ç®„É™„Ç¢ -->
        <div class="content-area">
            <!-- Â∑¶ÂÅ¥„ÉÑ„Éº„É´„Éê„Éº („É¨„Ç¨„Ç∑„Éº„Çø„Ç§„Éà„É´„Å®Âêå„Åò„É¨„Ç§„Ç¢„Ç¶„Éà) -->
            <div class="left-toolbar">
                <div class="tool-btn active" id="selectTool" title="ÈÅ∏Êäû„ÉÑ„Éº„É´ (V)">
                    ‚û§
                </div>
                <div class="tool-btn" id="textTool" title="„ÉÜ„Ç≠„Çπ„Éà„ÉÑ„Éº„É´ (T)">
                    T
                </div>
                <div class="tool-btn" id="rectangleTool" title="Áü©ÂΩ¢„ÉÑ„Éº„É´ (R)">
                    ‚ñ≠
                </div>
                <div class="tool-btn" id="roundRectTool" title="Ëßí‰∏∏Áü©ÂΩ¢„ÉÑ„Éº„É´ (U)">
                    ‚ñ¢
                </div>
                <div class="tool-btn" id="ellipseTool" title="Ê•ïÂÜÜ„ÉÑ„Éº„É´ (E)">
                    ‚óã
                </div>
                <div class="tool-btn" id="polygonTool" title="Â§öËßíÂΩ¢„ÉÑ„Éº„É´ (P)">
                    ‚¨°
                </div>
                <div class="tool-btn" id="starTool" title="ÊòüÂΩ¢„ÉÑ„Éº„É´ (S)">
                    ‚òÖ
                </div>
            </div>

            <!-- „Ç≠„É£„É≥„Éê„Çπ„Ç®„É™„Ç¢ -->
            <div class="canvas-area">
                <canvas id="canvas" width="1920" height="1080"></canvas>
            </div>

            <!-- Âè≥ÂÅ¥„Éó„É≠„Éë„ÉÜ„Ç£„Éë„Éç„É´ -->
            <div class="properties-panel">
                <h3 style="font-size: 12px; margin-bottom: 12px; color: #0066cc;">„Éó„É≠„Éë„ÉÜ„Ç£</h3>

                <!-- „Ç≠„É£„É≥„Éê„ÇπË®≠ÂÆö„Çª„ÇØ„Ç∑„Éß„É≥ -->
                <div class="property-section">
                    <div class="property-section-header">„Ç≠„É£„É≥„Éê„ÇπË®≠ÂÆö</div>
                    <div class="property-section-content">
                        <h4 style="font-size: 10px; color: #888; margin: 8px 0 4px;">„Çª„Éº„Éï„Éû„Éº„Ç∏„É≥</h4>
                        <div class="property-row">
                            <label><input type="checkbox" id="safeMarginEnabled" checked onchange="render()">Ë°®Á§∫</label>
                        </div>
                        <div class="property-grid-2">
                            <div class="property-row">
                                <label>„Ç¢„ÇØ„Ç∑„Éß„É≥ %</label>
                                <input type="number" id="actionSafeMargin" min="0" max="20" value="5" onchange="render()">
                            </div>
                            <div class="property-row">
                                <label>„Çø„Ç§„Éà„É´ %</label>
                                <input type="number" id="titleSafeMargin" min="0" max="20" value="10" onchange="render()">
                            </div>
                        </div>
                        <div class="property-grid-2">
                            <div class="property-row">
                                <label>Ëâ≤</label>
                                <input type="color" id="safeMarginColor" value="#ffffff" onchange="render()">
                            </div>
                            <div class="property-row">
                                <label>‰∏çÈÄèÊòéÂ∫¶ %</label>
                                <input type="number" id="safeMarginOpacity" min="0" max="100" value="50" onchange="render()">
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Â§âÂΩ¢„Çª„ÇØ„Ç∑„Éß„É≥ -->
                <div class="property-section">
                    <div class="property-section-header">Â§âÂΩ¢</div>
                    <div class="property-section-content">
                        <div class="property-grid-2">
                            <div class="property-row">
                                <label>XÂ∫ßÊ®ô</label>
                                <input type="number" id="prop_x" value="960" step="0.1">
                            </div>
                            <div class="property-row">
                                <label>YÂ∫ßÊ®ô</label>
                                <input type="number" id="prop_y" value="540" step="0.1">
                            </div>
                        </div>
                        <div class="property-grid-2">
                            <div class="property-row">
                                <label>ÂπÖ</label>
                                <input type="number" id="prop_width" value="500" step="0.1" readonly>
                            </div>
                            <div class="property-row">
                                <label>È´ò„Åï</label>
                                <input type="number" id="prop_height" value="100" step="0.1" readonly>
                            </div>
                        </div>
                        <div class="property-row">
                            <label>ÂõûËª¢ (Â∫¶)</label>
                            <input type="number" id="prop_rotation" value="0" step="0.1">
                        </div>
                    </div>
                </div>

                <!-- „Éó„É≠„Éë„ÉÜ„Ç£„Çª„ÇØ„Ç∑„Éß„É≥ -->
                <div class="property-section">
                    <div class="property-section-header">„Éï„Ç©„É≥„Éà</div>
                    <div class="property-section-content">
                        <div class="property-row">
                            <label>„Éï„Ç©„É≥„Éà„Éï„Ç°„Éü„É™„Éº</label>
                            <select id="prop_fontFamily">
                                <option value="Yu Gothic UI">Yu Gothic UI</option>
                                <option value="Arial">Arial</option>
                                <option value="Meiryo">Meiryo</option>
                                <option value="MS Gothic">MS Gothic</option>
                                <option value="Hiragino Sans">Hiragino Sans</option>
                            </select>
                        </div>
                        <div class="property-row">
                            <label>„Éï„Ç©„É≥„Éà„Çπ„Çø„Ç§„É´</label>
                            <select id="prop_fontStyle">
                                <option value="Regular">Regular</option>
                                <option value="Bold">Bold</option>
                                <option value="Italic">Italic</option>
                            </select>
                        </div>
                        <div class="property-row">
                            <label>„Éï„Ç©„É≥„Éà„Çµ„Ç§„Ç∫</label>
                            <input type="number" id="prop_fontSize" value="72" min="1" max="500">
                        </div>
                        <div class="property-row">
                            <label>Á∏¶Ê®™ÊØî (%)</label>
                            <input type="range" id="prop_scaleX" value="100" min="10" max="200" step="1">
                            <div class="value-display" id="scaleXValue">100%</div>
                        </div>
                        <div class="property-row">
                            <label>„Ç´„Éº„Éã„É≥„Ç∞</label>
                            <input type="number" id="prop_kerning" value="0" step="1">
                        </div>
                        <div class="property-row">
                            <label>„Éà„É©„ÉÉ„Ç≠„É≥„Ç∞</label>
                            <input type="number" id="prop_tracking" value="0" step="1">
                        </div>
                        <div class="property-row">
                            <label>„Éô„Éº„Çπ„É©„Ç§„É≥„Ç∑„Éï„Éà</label>
                            <input type="number" id="prop_baselineShift" value="0" step="1">
                        </div>
                        <div class="property-row">
                            <label><input type="checkbox" id="prop_vertical">Á∏¶Êõ∏„Åç</label>
                        </div>
                    </div>
                </div>

                <!-- Â°ó„Çä„Çª„ÇØ„Ç∑„Éß„É≥ -->
                <div class="property-section">
                    <div class="property-section-header">Â°ó„Çä</div>
                    <div class="property-section-content">
                        <div class="property-row">
                            <label><input type="checkbox" id="fill_enabled" checked>ÊúâÂäπ</label>
                        </div>
                        <div class="property-row">
                            <label>Â°ó„Çä„Çø„Ç§„Éó</label>
                            <select id="fill_type">
                                <option value="solid">„Éô„ÇøÂ°ó„Çä</option>
                                <option value="gradient-linear">Á∑öÂΩ¢„Ç∞„É©„Éá„Éº„Ç∑„Éß„É≥</option>
                                <option value="gradient-radial">ÂÜÜÂΩ¢„Ç∞„É©„Éá„Éº„Ç∑„Éß„É≥</option>
                                <option value="sheen">ÂÖâÊ≤¢</option>
                            </select>
                        </div>
                        <div id="solidFillControls">
                            <div class="property-grid-2">
                                <div class="property-row">
                                    <label>„Ç´„É©„Éº</label>
                                    <input type="color" id="fill_color" value="#fdff00">
                                </div>
                                <div class="property-row">
                                    <label>‰∏çÈÄèÊòéÂ∫¶ (%)</label>
                                    <input type="number" id="fill_opacity" value="100" min="0" max="100">
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- „Çπ„Éà„É≠„Éº„ÇØ„Çª„ÇØ„Ç∑„Éß„É≥ -->
                <div class="property-section">
                    <div class="property-section-header">„Çπ„Éà„É≠„Éº„ÇØ</div>
                    <div class="property-section-content">
                        <div class="property-row">
                            <label><input type="checkbox" id="stroke1_enabled">„Çπ„Éà„É≠„Éº„ÇØ1</label>
                        </div>
                        <div class="property-grid-3">
                            <div class="property-row">
                                <label>„Çµ„Ç§„Ç∫</label>
                                <input type="number" id="stroke1_size" value="8" min="0" max="200">
                            </div>
                            <div class="property-row" style="grid-column: span 2;">
                                <label>„Ç´„É©„Éº</label>
                                <input type="color" id="stroke1_color" value="#000000">
                            </div>
                        </div>

                        <div class="property-row" style="margin-top: 12px;">
                            <label><input type="checkbox" id="stroke2_enabled">„Çπ„Éà„É≠„Éº„ÇØ2</label>
                        </div>
                        <div class="property-grid-3">
                            <div class="property-row">
                                <label>„Çµ„Ç§„Ç∫</label>
                                <input type="number" id="stroke2_size" value="38" min="0" max="200">
                            </div>
                            <div class="property-row" style="grid-column: span 2;">
                                <label>„Ç´„É©„Éº</label>
                                <input type="color" id="stroke2_color" value="#ffffff">
                            </div>
                        </div>

                        <div class="property-row" style="margin-top: 12px;">
                            <label><input type="checkbox" id="stroke3_enabled">„Çπ„Éà„É≠„Éº„ÇØ3</label>
                        </div>
                        <div class="property-grid-3">
                            <div class="property-row">
                                <label>„Çµ„Ç§„Ç∫</label>
                                <input type="number" id="stroke3_size" value="68" min="0" max="200">
                            </div>
                            <div class="property-row" style="grid-column: span 2;">
                                <label>„Ç´„É©„Éº</label>
                                <input type="color" id="stroke3_color" value="#000000">
                            </div>
                        </div>

                        <div class="property-row" style="margin-top: 12px;">
                            <label><input type="checkbox" id="stroke4_enabled">„Çπ„Éà„É≠„Éº„ÇØ4</label>
                        </div>
                        <div class="property-grid-3">
                            <div class="property-row">
                                <label>„Çµ„Ç§„Ç∫</label>
                                <input type="number" id="stroke4_size" value="78" min="0" max="200">
                            </div>
                            <div class="property-row" style="grid-column: span 2;">
                                <label>„Ç´„É©„Éº</label>
                                <input type="color" id="stroke4_color" value="#000000">
                            </div>
                        </div>
                    </div>
                </div>

                <!-- ÂΩ±„Çª„ÇØ„Ç∑„Éß„É≥ -->
                <div class="property-section">
                    <div class="property-section-header">ÂΩ±</div>
                    <div class="property-section-content">
                        <div class="property-row">
                            <label><input type="checkbox" id="shadow_enabled">ÊúâÂäπ</label>
                        </div>
                        <div class="property-grid-2">
                            <div class="property-row">
                                <label>„Ç´„É©„Éº</label>
                                <input type="color" id="shadow_color" value="#000000">
                            </div>
                            <div class="property-row">
                                <label>‰∏çÈÄèÊòéÂ∫¶ (%)</label>
                                <input type="number" id="shadow_opacity" value="50" min="0" max="100">
                            </div>
                        </div>
                        <div class="property-grid-2">
                            <div class="property-row">
                                <label>Ë∑ùÈõ¢</label>
                                <input type="number" id="shadow_distance" value="10" min="0" max="100">
                            </div>
                            <div class="property-row">
                                <label>ËßíÂ∫¶ (Â∫¶)</label>
                                <input type="number" id="shadow_angle" value="-45" min="-180" max="180">
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Èö†„ÅóIMEÂÖ•ÂäõÁî® -->
    <input type="text" id="imeInput" autocomplete="off">

    <script>
        // „Ç∞„É≠„Éº„Éê„É´Â§âÊï∞
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let currentTool = 'select'; // 'select', 'text', 'rectangle', 'roundRect', 'ellipse', 'polygon', 'star'
        let textObjects = []; // { text, x, y, fontSize, fontFamily, scaleX, ... }
        let shapeObjects = []; // { type, x, y, width, height, ... }
        let selectedObject = null;
        let isTyping = false;
        let cursorPosition = 0;
        let selectionStart = 0;
        let selectionEnd = 0;

        // „Éì„É•„Éº„Éù„Éº„ÉàÂà∂Âæ°
        let viewportScale = 1;
        let viewportOffsetX = 0;
        let viewportOffsetY = 0;

        // „Ç´„Éº„ÇΩ„É´ÁÇπÊªÖÁî®
        let cursorVisible = true;
        setInterval(() => {
            cursorVisible = !cursorVisible;
            if (isTyping) render();
        }, 530);

        // „ÉÑ„Éº„É´Âàá„ÇäÊõø„Åà
        document.getElementById('selectTool').addEventListener('click', () => {
            switchTool('select');
        });

        document.getElementById('textTool').addEventListener('click', () => {
            switchTool('text');
        });

        document.getElementById('rectangleTool').addEventListener('click', () => {
            switchTool('rectangle');
        });

        document.getElementById('roundRectTool').addEventListener('click', () => {
            switchTool('roundRect');
        });

        document.getElementById('ellipseTool').addEventListener('click', () => {
            switchTool('ellipse');
        });

        document.getElementById('polygonTool').addEventListener('click', () => {
            switchTool('polygon');
        });

        document.getElementById('starTool').addEventListener('click', () => {
            switchTool('star');
        });

        function switchTool(tool) {
            currentTool = tool;

            // ÂÖ®„ÉÑ„Éº„É´„ÅÆactive„ÇØ„É©„Çπ„ÇíÂâäÈô§
            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));

            // ÈÅ∏Êäû„Åï„Çå„Åü„ÉÑ„Éº„É´„Çí„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Å´
            if (tool === 'select') {
                document.getElementById('selectTool').classList.add('active');
                canvas.classList.add('selection-mode');
                canvas.style.cursor = 'default';
            } else if (tool === 'text') {
                document.getElementById('textTool').classList.add('active');
                canvas.classList.remove('selection-mode');
                canvas.style.cursor = 'crosshair';
            } else if (tool === 'rectangle') {
                document.getElementById('rectangleTool').classList.add('active');
                canvas.classList.remove('selection-mode');
                canvas.style.cursor = 'crosshair';
            } else if (tool === 'roundRect') {
                document.getElementById('roundRectTool').classList.add('active');
                canvas.classList.remove('selection-mode');
                canvas.style.cursor = 'crosshair';
            } else if (tool === 'ellipse') {
                document.getElementById('ellipseTool').classList.add('active');
                canvas.classList.remove('selection-mode');
                canvas.style.cursor = 'crosshair';
            } else if (tool === 'polygon') {
                document.getElementById('polygonTool').classList.add('active');
                canvas.classList.remove('selection-mode');
                canvas.style.cursor = 'crosshair';
            } else if (tool === 'star') {
                document.getElementById('starTool').classList.add('active');
                canvas.classList.remove('selection-mode');
                canvas.style.cursor = 'crosshair';
            }
        }

        // „Ç≠„É£„É≥„Éê„ÇπËß£ÂÉèÂ∫¶Â§âÊõ¥
        document.getElementById('canvasWidth').addEventListener('change', function() {
            canvas.width = parseInt(this.value);
            render();
        });

        document.getElementById('canvasHeight').addEventListener('change', function() {
            canvas.height = parseInt(this.value);
            render();
        });

        // Á∏¶Ê®™ÊØî„Çπ„É©„Ç§„ÉÄ„Éº„ÅÆÂÄ§Ë°®Á§∫
        document.getElementById('prop_scaleX').addEventListener('input', function() {
            document.getElementById('scaleXValue').textContent = this.value + '%';
            if (selectedObject) {
                selectedObject.scaleX = parseInt(this.value);
                render();
            }
        });

        // „Éó„É≠„Éë„ÉÜ„Ç£Â§âÊõ¥ÊôÇ„ÅÆ„É™„Ç¢„É´„Çø„Ç§„É†Êõ¥Êñ∞
        const propertyInputs = [
            'prop_x', 'prop_y', 'prop_fontSize', 'prop_fontFamily',
            'prop_kerning', 'prop_tracking', 'prop_rotation', 'prop_vertical',
            'fill_color', 'fill_opacity', 'fill_enabled',
            'stroke1_enabled', 'stroke1_size', 'stroke1_color',
            'stroke2_enabled', 'stroke2_size', 'stroke2_color',
            'stroke3_enabled', 'stroke3_size', 'stroke3_color',
            'stroke4_enabled', 'stroke4_size', 'stroke4_color',
            'shadow_enabled', 'shadow_color', 'shadow_opacity', 'shadow_distance', 'shadow_angle'
        ];

        propertyInputs.forEach(id => {
            const el = document.getElementById(id);
            if (el) {
                el.addEventListener('input', updateSelectedObjectFromProperties);
                el.addEventListener('change', updateSelectedObjectFromProperties);
            }
        });

        function updateSelectedObjectFromProperties() {
            if (!selectedObject) return;

            selectedObject.x = parseFloat(document.getElementById('prop_x').value) || 0;
            selectedObject.y = parseFloat(document.getElementById('prop_y').value) || 0;
            selectedObject.fontSize = parseInt(document.getElementById('prop_fontSize').value) || 72;
            selectedObject.fontFamily = document.getElementById('prop_fontFamily').value;
            selectedObject.scaleX = parseInt(document.getElementById('prop_scaleX').value) || 100;
            selectedObject.kerning = parseInt(document.getElementById('prop_kerning').value) || 0;
            selectedObject.tracking = parseInt(document.getElementById('prop_tracking').value) || 0;
            selectedObject.rotation = parseFloat(document.getElementById('prop_rotation').value) || 0;
            selectedObject.vertical = document.getElementById('prop_vertical').checked;

            selectedObject.fill = {
                enabled: document.getElementById('fill_enabled').checked,
                color: document.getElementById('fill_color').value,
                opacity: parseInt(document.getElementById('fill_opacity').value) || 100
            };

            selectedObject.strokes = [
                {
                    enabled: document.getElementById('stroke1_enabled').checked,
                    size: parseInt(document.getElementById('stroke1_size').value) || 0,
                    color: document.getElementById('stroke1_color').value
                },
                {
                    enabled: document.getElementById('stroke2_enabled').checked,
                    size: parseInt(document.getElementById('stroke2_size').value) || 0,
                    color: document.getElementById('stroke2_color').value
                },
                {
                    enabled: document.getElementById('stroke3_enabled').checked,
                    size: parseInt(document.getElementById('stroke3_size').value) || 0,
                    color: document.getElementById('stroke3_color').value
                },
                {
                    enabled: document.getElementById('stroke4_enabled').checked,
                    size: parseInt(document.getElementById('stroke4_size').value) || 0,
                    color: document.getElementById('stroke4_color').value
                }
            ];

            selectedObject.shadow = {
                enabled: document.getElementById('shadow_enabled').checked,
                color: document.getElementById('shadow_color').value,
                opacity: parseInt(document.getElementById('shadow_opacity').value) || 50,
                distance: parseInt(document.getElementById('shadow_distance').value) || 10,
                angle: parseInt(document.getElementById('shadow_angle').value) || -45
            };

            render();
        }

        // „Éû„Ç¶„Çπ„Ç§„Éô„É≥„ÉàÂá¶ÁêÜ
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let dragTarget = null; // 'object' or 'handle-nw', 'handle-ne', etc.
        let dragStartObjX = 0;
        let dragStartObjY = 0;
        let dragStartWidth = 0;
        let dragStartHeight = 0;
        let isCreatingShape = false;
        let currentShape = null;

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (canvas.width / rect.width);
            const y = (e.clientY - rect.top) * (canvas.height / rect.height);

            dragStartX = x;
            dragStartY = y;

            if (currentTool === 'text') {
                // Êñ∞„Åó„ÅÑ„ÉÜ„Ç≠„Çπ„Éà„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Çí‰ΩúÊàê
                const newText = {
                    text: '',
                    x: x,
                    y: y,
                    fontSize: 72,
                    fontFamily: 'Yu Gothic UI',
                    scaleX: 100,
                    kerning: 0,
                    tracking: 0,
                    rotation: 0,
                    vertical: false,
                    fill: {
                        enabled: true,
                        color: '#fdff00',
                        opacity: 100
                    },
                    strokes: [
                        { enabled: false, size: 8, color: '#000000' },
                        { enabled: false, size: 38, color: '#ffffff' },
                        { enabled: false, size: 68, color: '#000000' },
                        { enabled: false, size: 78, color: '#000000' }
                    ],
                    shadow: {
                        enabled: false,
                        color: '#000000',
                        opacity: 50,
                        distance: 10,
                        angle: -45
                    }
                };

                textObjects.push(newText);
                selectedObject = newText;
                updatePropertiesPanel();
                startTyping();
            } else if (currentTool === 'rectangle' || currentTool === 'roundRect' || currentTool === 'ellipse' || currentTool === 'polygon' || currentTool === 'star') {
                // Âõ≥ÂΩ¢‰ΩúÊàêÈñãÂßã
                isCreatingShape = true;
                currentShape = {
                    type: currentTool,
                    x: x,
                    y: y,
                    width: 0,
                    height: 0,
                    radius: 20, // Ëßí‰∏∏Áü©ÂΩ¢Áî®
                    sides: 5, // Â§öËßíÂΩ¢„ÉªÊòüÂΩ¢Áî®
                    fill: {
                        enabled: true,
                        color: '#ffffff',
                        opacity: 100
                    },
                    stroke: {
                        enabled: true,
                        size: 3,
                        color: '#000000'
                    }
                };
            } else if (currentTool === 'select') {
                // „ÉÜ„Ç≠„Çπ„ÉàÂÖ•Âäõ‰∏≠„ÅÆÂ†¥Âêà„ÅØÁµÇ‰∫Ü
                if (isTyping) {
                    isTyping = false;
                    const imeInput = document.getElementById('imeInput');
                    imeInput.classList.remove('active');
                    imeInput.blur();

                    // Á©∫„ÅÆ„ÉÜ„Ç≠„Çπ„Éà„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇíÂâäÈô§
                    if (selectedObject && selectedObject.text === '') {
                        const index = textObjects.indexOf(selectedObject);
                        if (index > -1) {
                            textObjects.splice(index, 1);
                        }
                        selectedObject = null;
                    }
                }

                // „Éè„É≥„Éâ„É´„ÇØ„É™„ÉÉ„ÇØ„ÉÅ„Çß„ÉÉ„ÇØ
                const handle = getHandleAt(x, y);
                if (handle && selectedObject) {
                    isDragging = true;
                    dragTarget = handle;
                    dragStartObjX = selectedObject.x;
                    dragStartObjY = selectedObject.y;
                    const metrics = measureText(selectedObject);
                    dragStartWidth = metrics.width;
                    dragStartHeight = metrics.height;
                } else if (selectObjectAt(x, y)) {
                    // „Ç™„Éñ„Ç∏„Çß„ÇØ„ÉàÈÅ∏ÊäûÊàêÂäü„ÄÅ„Éâ„É©„ÉÉ„Ç∞ÈñãÂßã
                    isDragging = true;
                    dragTarget = 'object';
                    dragStartObjX = selectedObject.x;
                    dragStartObjY = selectedObject.y;
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (canvas.width / rect.width);
            const y = (e.clientY - rect.top) * (canvas.height / rect.height);

            if (isCreatingShape && currentShape) {
                // Âõ≥ÂΩ¢„ÅÆ„Çµ„Ç§„Ç∫„ÇíÊõ¥Êñ∞
                currentShape.width = x - currentShape.x;
                currentShape.height = y - currentShape.y;
                render();
            } else if (isDragging && selectedObject) {
                const dx = x - dragStartX;
                const dy = y - dragStartY;

                if (dragTarget === 'object') {
                    // „Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇíÁßªÂãï
                    selectedObject.x = dragStartObjX + dx;
                    selectedObject.y = dragStartObjY + dy;
                    updatePropertiesPanel();
                    render();
                } else if (dragTarget && dragTarget.startsWith('handle-')) {
                    // „É™„Çµ„Ç§„Ç∫Âá¶ÁêÜ
                    const handleType = dragTarget.replace('handle-', '');
                    resizeObject(handleType, dx, dy);
                }
            } else {
                // „Ç´„Éº„ÇΩ„É´ÂΩ¢Áä∂„ÇíÊõ¥Êñ∞
                if (currentTool === 'select' && selectedObject) {
                    const handle = getHandleAt(x, y);
                    if (handle) {
                        const handleType = handle.replace('handle-', '');
                        if (handleType === 'nw' || handleType === 'se') {
                            canvas.style.cursor = 'nwse-resize';
                        } else if (handleType === 'ne' || handleType === 'sw') {
                            canvas.style.cursor = 'nesw-resize';
                        }
                    } else {
                        // „Ç™„Éñ„Ç∏„Çß„ÇØ„Éà‰∏ä„Åã„ÉÅ„Çß„ÉÉ„ÇØ
                        const metrics = measureText(selectedObject);
                        if (x >= selectedObject.x - 10 && x <= selectedObject.x + metrics.width + 10 &&
                            y >= selectedObject.y - metrics.height && y <= selectedObject.y + 10) {
                            canvas.style.cursor = 'move';
                        } else {
                            canvas.style.cursor = 'default';
                        }
                    }
                }
            }
        });

        canvas.addEventListener('mouseup', () => {
            if (isCreatingShape && currentShape) {
                // Âõ≥ÂΩ¢„ÇíÁ¢∫ÂÆö
                if (Math.abs(currentShape.width) > 5 || Math.abs(currentShape.height) > 5) {
                    shapeObjects.push(currentShape);
                }
                isCreatingShape = false;
                currentShape = null;
                render();
            }

            isDragging = false;
            dragTarget = null;
        });

        canvas.addEventListener('dblclick', (e) => {
            if (currentTool === 'select' && selectedObject) {
                // „ÉÄ„Éñ„É´„ÇØ„É™„ÉÉ„ÇØ„Åß„ÉÜ„Ç≠„Çπ„ÉàÁ∑®ÈõÜ„É¢„Éº„Éâ
                startTyping();
            }
        });

        function getHandleAt(x, y) {
            if (!selectedObject) return null;

            const metrics = measureText(selectedObject);
            const handleSize = 6;
            const handles = {
                'handle-nw': [selectedObject.x - 2, selectedObject.y - 2],
                'handle-ne': [selectedObject.x + metrics.width + 2, selectedObject.y - 2],
                'handle-sw': [selectedObject.x - 2, selectedObject.y + metrics.height + 2],
                'handle-se': [selectedObject.x + metrics.width + 2, selectedObject.y + metrics.height + 2]
            };

            for (const [name, [hx, hy]] of Object.entries(handles)) {
                if (Math.abs(x - hx) <= handleSize && Math.abs(y - hy) <= handleSize) {
                    return name;
                }
            }

            return null;
        }

        function resizeObject(handleType, dx, dy) {
            if (!selectedObject) return;

            const newFontSize = selectedObject.fontSize;

            // „Éï„Ç©„É≥„Éà„Çµ„Ç§„Ç∫„ÇíÂ§âÊõ¥„Åó„Å¶„É™„Çµ„Ç§„Ç∫
            if (handleType === 'se' || handleType === 'ne') {
                // Âè≥ÊñπÂêë„ÅÆ„É™„Çµ„Ç§„Ç∫
                const scaleFactor = (dragStartWidth + dx) / dragStartWidth;
                selectedObject.fontSize = Math.max(10, Math.round(dragStartHeight * scaleFactor));
            } else if (handleType === 'sw' || handleType === 'nw') {
                // Â∑¶ÊñπÂêë„ÅÆ„É™„Çµ„Ç§„Ç∫
                const scaleFactor = (dragStartWidth - dx) / dragStartWidth;
                selectedObject.fontSize = Math.max(10, Math.round(dragStartHeight * scaleFactor));
                // ‰ΩçÁΩÆ„ÇÇË™øÊï¥
                const metrics = measureText(selectedObject);
                selectedObject.x = dragStartObjX + (dragStartWidth - metrics.width);
            }

            updatePropertiesPanel();
            render();
        }

        function selectObjectAt(x, y) {
            // „ÉÜ„Ç≠„Çπ„Éà„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Çí„ÉÅ„Çß„ÉÉ„ÇØÔºàÂæå„Çç„Åã„ÇâÔºâ
            for (let i = textObjects.length - 1; i >= 0; i--) {
                const obj = textObjects[i];
                const metrics = measureText(obj);

                if (x >= obj.x - 10 && x <= obj.x + metrics.width + 10 &&
                    y >= obj.y - metrics.height && y <= obj.y + 10) {
                    selectedObject = obj;
                    updatePropertiesPanel();
                    render();
                    return true;
                }
            }

            // Âõ≥ÂΩ¢„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Çí„ÉÅ„Çß„ÉÉ„ÇØÔºàÂæå„Çç„Åã„ÇâÔºâ
            for (let i = shapeObjects.length - 1; i >= 0; i--) {
                const obj = shapeObjects[i];
                const minX = Math.min(obj.x, obj.x + obj.width);
                const minY = Math.min(obj.y, obj.y + obj.height);
                const maxX = Math.max(obj.x, obj.x + obj.width);
                const maxY = Math.max(obj.y, obj.y + obj.height);

                if (x >= minX - 10 && x <= maxX + 10 &&
                    y >= minY - 10 && y <= maxY + 10) {
                    selectedObject = obj;
                    render();
                    return true;
                }
            }

            // ‰Ωï„ÇÇÈÅ∏Êäû„Åï„Çå„Å™„Åã„Å£„Åü
            selectedObject = null;
            render();
            return false;
        }

        function startTyping() {
            if (!selectedObject) return;

            isTyping = true;
            cursorPosition = selectedObject.text.length;

            // IMEÂÖ•Âäõ„Çí„Éï„Ç©„Éº„Ç´„ÇπÔºàCanvas‰∏ä„ÅßÈÄèÊòé„Å´Ôºâ
            const imeInput = document.getElementById('imeInput');
            const rect = canvas.getBoundingClientRect();

            // Canvas‰∏ä„ÅÆ„ÉÜ„Ç≠„Çπ„Éà„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅÆ‰ΩçÁΩÆ„Å´IMEÂÖ•Âäõ„ÇíÈÖçÁΩÆ
            imeInput.style.left = (rect.left + selectedObject.x * (rect.width / canvas.width)) + 'px';
            imeInput.style.top = (rect.top + selectedObject.y * (rect.height / canvas.height)) + 'px';

            imeInput.value = selectedObject.text;
            imeInput.classList.add('active');

            // Â∞ë„ÅóÈÅÖÂª∂„Åï„Åõ„Å¶„Éï„Ç©„Éº„Ç´„ÇπÔºà‰ªñ„ÅÆ„Ç§„Éô„É≥„Éà„ÅåÂÆå‰∫Ü„Åó„Å¶„Åã„ÇâÔºâ
            setTimeout(() => {
                imeInput.focus();
                imeInput.select();
                console.log('‚úÖ „ÉÜ„Ç≠„Çπ„ÉàÂÖ•ÂäõÈñãÂßã:', selectedObject.text);
            }, 10);
        }

        // IMEÂÖ•ÂäõÂá¶ÁêÜ
        document.getElementById('imeInput').addEventListener('input', (e) => {
            if (selectedObject && isTyping) {
                selectedObject.text = e.target.value;
                cursorPosition = e.target.selectionStart;
                selectionStart = e.target.selectionStart;
                selectionEnd = e.target.selectionEnd;
                render();
            }
        });

        // ÈÅ∏ÊäûÁØÑÂõ≤„ÅÆÂ§âÊõ¥„ÇíËøΩË∑°
        document.getElementById('imeInput').addEventListener('select', (e) => {
            if (selectedObject && isTyping) {
                selectionStart = e.target.selectionStart;
                selectionEnd = e.target.selectionEnd;
                cursorPosition = e.target.selectionStart;
                render();
            }
        });

        document.getElementById('imeInput').addEventListener('click', (e) => {
            if (selectedObject && isTyping) {
                selectionStart = e.target.selectionStart;
                selectionEnd = e.target.selectionEnd;
                cursorPosition = e.target.selectionStart;
                render();
            }
        });

        // IMEÂÖ•Âäõ„ÅÆblur„Ç§„Éô„É≥„Éà
        document.getElementById('imeInput').addEventListener('blur', (e) => {
            console.log('üîµ IMEÂÖ•Âäõ„Éï„Ç£„Éº„É´„Éâ„Ååblur');
            if (isTyping) {
                isTyping = false;
                e.target.classList.remove('active');

                // Á©∫„ÅÆ„ÉÜ„Ç≠„Çπ„Éà„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇíÂâäÈô§Ôºà„É¨„Ç¨„Ç∑„Éº„Çø„Ç§„Éà„É´„Å®Âêå„ÅòÂãï‰ΩúÔºâ
                if (selectedObject && selectedObject.text.trim() === '') {
                    const index = textObjects.indexOf(selectedObject);
                    if (index > -1) {
                        textObjects.splice(index, 1);
                        selectedObject = null;
                        console.log('üóëÔ∏è Á©∫„ÅÆ„ÉÜ„Ç≠„Çπ„Éà„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇíÂâäÈô§');
                    }
                } else if (selectedObject) {
                    console.log('‚úÖ „ÉÜ„Ç≠„Çπ„ÉàÂÖ•ÂäõÂÆå‰∫Ü:', selectedObject.text);
                }

                render();
            }
        });

        // „Ç≠„Éº„Éú„Éº„Éâ„Ç§„Éô„É≥„Éà
        document.addEventListener('keydown', (e) => {
            if (isTyping && selectedObject) {
                if (e.key === 'Escape') {
                    isTyping = false;
                    const imeInput = document.getElementById('imeInput');
                    imeInput.blur();
                    imeInput.classList.remove('active');
                    render();
                }
            } else if (selectedObject && !isTyping) {
                // ÈÅ∏Êäû„É¢„Éº„Éâ„Åß„ÅÆ„Ç≠„Éº„Éú„Éº„Éâ„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà
                if (e.key === 'Delete' || e.key === 'Backspace') {
                    const index = textObjects.indexOf(selectedObject);
                    if (index > -1) {
                        textObjects.splice(index, 1);
                        selectedObject = null;
                        render();
                    }
                } else if (e.key === 'Enter') {
                    startTyping();
                }
            }
        });

        function updatePropertiesPanel() {
            if (!selectedObject) return;

            document.getElementById('prop_x').value = selectedObject.x.toFixed(1);
            document.getElementById('prop_y').value = selectedObject.y.toFixed(1);
            document.getElementById('prop_fontSize').value = selectedObject.fontSize;
            document.getElementById('prop_fontFamily').value = selectedObject.fontFamily;
            document.getElementById('prop_scaleX').value = selectedObject.scaleX;
            document.getElementById('scaleXValue').textContent = selectedObject.scaleX + '%';
            document.getElementById('prop_kerning').value = selectedObject.kerning;
            document.getElementById('prop_tracking').value = selectedObject.tracking;
            document.getElementById('prop_rotation').value = selectedObject.rotation;
            document.getElementById('prop_vertical').checked = selectedObject.vertical || false;

            document.getElementById('fill_enabled').checked = selectedObject.fill.enabled;
            document.getElementById('fill_color').value = selectedObject.fill.color;
            document.getElementById('fill_opacity').value = selectedObject.fill.opacity;

            if (selectedObject.strokes.length >= 4) {
                document.getElementById('stroke1_enabled').checked = selectedObject.strokes[0].enabled;
                document.getElementById('stroke1_size').value = selectedObject.strokes[0].size;
                document.getElementById('stroke1_color').value = selectedObject.strokes[0].color;

                document.getElementById('stroke2_enabled').checked = selectedObject.strokes[1].enabled;
                document.getElementById('stroke2_size').value = selectedObject.strokes[1].size;
                document.getElementById('stroke2_color').value = selectedObject.strokes[1].color;

                document.getElementById('stroke3_enabled').checked = selectedObject.strokes[2].enabled;
                document.getElementById('stroke3_size').value = selectedObject.strokes[2].size;
                document.getElementById('stroke3_color').value = selectedObject.strokes[2].color;

                document.getElementById('stroke4_enabled').checked = selectedObject.strokes[3].enabled;
                document.getElementById('stroke4_size').value = selectedObject.strokes[3].size;
                document.getElementById('stroke4_color').value = selectedObject.strokes[3].color;
            }

            document.getElementById('shadow_enabled').checked = selectedObject.shadow.enabled;
            document.getElementById('shadow_color').value = selectedObject.shadow.color;
            document.getElementById('shadow_opacity').value = selectedObject.shadow.opacity;
            document.getElementById('shadow_distance').value = selectedObject.shadow.distance;
            document.getElementById('shadow_angle').value = selectedObject.shadow.angle;
        }

        function measureText(obj) {
            ctx.font = `${obj.fontSize}px "${obj.fontFamily}"`;

            if (obj.vertical) {
                // Á∏¶Êõ∏„Åç„ÅÆÂ†¥Âêà
                const charCount = (obj.text || '|').length;
                return {
                    width: obj.fontSize * (obj.scaleX / 100),
                    height: obj.fontSize * charCount
                };
            } else {
                // Ê®™Êõ∏„Åç„ÅÆÂ†¥Âêà
                const metrics = ctx.measureText(obj.text || '|');
                return {
                    width: metrics.width * (obj.scaleX / 100),
                    height: obj.fontSize
                };
            }
        }

        function render() {
            // „ÉÅ„Çß„ÉÉ„Ç´„Éº„Éú„Éº„ÉâËÉåÊôØ„ÇíÊèèÁîªÔºà„É¨„Ç¨„Ç∑„Éº„Çø„Ç§„Éà„É´„Å®Âêå„ÅòÔºâ
            drawCheckerboardBackground();

            // „Çª„Éº„Éï„Éû„Éº„Ç∏„É≥ÊèèÁîª
            if (document.getElementById('safeMarginEnabled').checked) {
                drawSafeMargins();
            }

            // ÂÖ®Âõ≥ÂΩ¢„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇíÊèèÁîª
            shapeObjects.forEach(obj => {
                drawShapeObject(obj, obj === selectedObject);
            });

            // Âõ≥ÂΩ¢‰ΩúÊàê‰∏≠„ÅÆÂ†¥Âêà
            if (isCreatingShape && currentShape) {
                drawShapeObject(currentShape, false);
            }

            // ÂÖ®„ÉÜ„Ç≠„Çπ„Éà„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇíÊèèÁîª
            textObjects.forEach(obj => {
                drawTextObject(obj, obj === selectedObject);
            });

            // „ÉÜ„Ç≠„Çπ„ÉàÈÅ∏ÊäûÁØÑÂõ≤„ÅÆÊèèÁîªÔºàÂÖ•Âäõ‰∏≠„ÅÆÂ†¥ÂêàÔºâ
            if (isTyping && selectedObject && selectionStart !== selectionEnd) {
                drawTextSelection();
            }

            // „Ç´„Éº„ÇΩ„É´ÊèèÁîªÔºàÂÖ•Âäõ‰∏≠„ÅÆÂ†¥ÂêàÔºâ
            if (isTyping && selectedObject && cursorVisible) {
                drawCursor();
            }
        }

        function drawShapeObject(obj, isSelected) {
            ctx.save();

            const x = obj.x;
            const y = obj.y;
            const w = obj.width;
            const h = obj.height;

            // Â°ó„Çä
            if (obj.fill && obj.fill.enabled) {
                const opacity = obj.fill.opacity / 100;
                if (opacity < 1) {
                    const rgb = hexToRgb(obj.fill.color);
                    ctx.fillStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`;
                } else {
                    ctx.fillStyle = obj.fill.color;
                }
            }

            // „Çπ„Éà„É≠„Éº„ÇØ
            if (obj.stroke && obj.stroke.enabled) {
                ctx.strokeStyle = obj.stroke.color;
                ctx.lineWidth = obj.stroke.size;
            }

            // Âõ≥ÂΩ¢„Çø„Ç§„Éó„Åî„Å®„ÅÆÊèèÁîª
            if (obj.type === 'rectangle') {
                if (obj.fill && obj.fill.enabled) {
                    ctx.fillRect(x, y, w, h);
                }
                if (obj.stroke && obj.stroke.enabled) {
                    ctx.strokeRect(x, y, w, h);
                }
            } else if (obj.type === 'roundRect') {
                // Ëßí‰∏∏Áü©ÂΩ¢
                const radius = Math.min(obj.radius || 20, Math.abs(w) / 2, Math.abs(h) / 2);
                ctx.beginPath();
                ctx.roundRect(x, y, w, h, radius);
                if (obj.fill && obj.fill.enabled) {
                    ctx.fill();
                }
                if (obj.stroke && obj.stroke.enabled) {
                    ctx.stroke();
                }
            } else if (obj.type === 'ellipse') {
                ctx.beginPath();
                ctx.ellipse(x + w/2, y + h/2, Math.abs(w/2), Math.abs(h/2), 0, 0, 2 * Math.PI);
                if (obj.fill && obj.fill.enabled) {
                    ctx.fill();
                }
                if (obj.stroke && obj.stroke.enabled) {
                    ctx.stroke();
                }
            } else if (obj.type === 'polygon') {
                // Ê≠£Â§öËßíÂΩ¢
                const sides = obj.sides || 5;
                const centerX = x + w / 2;
                const centerY = y + h / 2;
                const radius = Math.min(Math.abs(w), Math.abs(h)) / 2;
                ctx.beginPath();
                for (let i = 0; i < sides; i++) {
                    const angle = (Math.PI * 2 * i / sides) - Math.PI / 2;
                    const px = centerX + radius * Math.cos(angle);
                    const py = centerY + radius * Math.sin(angle);
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                if (obj.fill && obj.fill.enabled) {
                    ctx.fill();
                }
                if (obj.stroke && obj.stroke.enabled) {
                    ctx.stroke();
                }
            } else if (obj.type === 'star') {
                // ÊòüÂΩ¢
                const points = (obj.sides || 5) * 2;
                const centerX = x + w / 2;
                const centerY = y + h / 2;
                const outerRadius = Math.min(Math.abs(w), Math.abs(h)) / 2;
                const innerRadius = outerRadius * 0.4;
                ctx.beginPath();
                for (let i = 0; i < points; i++) {
                    const angle = (Math.PI * 2 * i / points) - Math.PI / 2;
                    const radius = i % 2 === 0 ? outerRadius : innerRadius;
                    const px = centerX + radius * Math.cos(angle);
                    const py = centerY + radius * Math.sin(angle);
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                if (obj.fill && obj.fill.enabled) {
                    ctx.fill();
                }
                if (obj.stroke && obj.stroke.enabled) {
                    ctx.stroke();
                }
            }

            // ÈÅ∏Êäû„Éú„ÉÉ„ÇØ„Çπ
            if (isSelected) {
                ctx.strokeStyle = '#0099ff';
                ctx.lineWidth = 1;
                ctx.setLineDash([]);

                const minX = Math.min(x, x + w);
                const minY = Math.min(y, y + h);
                const maxX = Math.max(x, x + w);
                const maxY = Math.max(y, y + h);

                ctx.strokeRect(minX - 2, minY - 2, maxX - minX + 4, maxY - minY + 4);

                // „Éè„É≥„Éâ„É´
                const handleSize = 6;
                const handles = [
                    [minX - 2, minY - 2],
                    [maxX + 2, minY - 2],
                    [minX - 2, maxY + 2],
                    [maxX + 2, maxY + 2]
                ];

                ctx.fillStyle = '#ffffff';
                ctx.strokeStyle = '#0099ff';
                ctx.lineWidth = 1;
                handles.forEach(([hx, hy]) => {
                    ctx.fillRect(hx - handleSize/2, hy - handleSize/2, handleSize, handleSize);
                    ctx.strokeRect(hx - handleSize/2, hy - handleSize/2, handleSize, handleSize);
                });
            }

            ctx.restore();
        }

        function drawCheckerboardBackground() {
            const squareSize = 16;
            const color1 = '#3a3a3a';
            const color2 = '#2a2a2a';

            for (let y = 0; y < canvas.height; y += squareSize) {
                for (let x = 0; x < canvas.width; x += squareSize) {
                    const isEven = ((x / squareSize) + (y / squareSize)) % 2 === 0;
                    ctx.fillStyle = isEven ? color1 : color2;
                    ctx.fillRect(x, y, squareSize, squareSize);
                }
            }
        }

        function drawSafeMargins() {
            const actionMargin = parseFloat(document.getElementById('actionSafeMargin').value) / 100;
            const titleMargin = parseFloat(document.getElementById('titleSafeMargin').value) / 100;
            const marginColor = document.getElementById('safeMarginColor').value;
            const opacity = parseFloat(document.getElementById('safeMarginOpacity').value) / 100;

            const rgb = hexToRgb(marginColor);
            ctx.strokeStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`;
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);

            // „Ç¢„ÇØ„Ç∑„Éß„É≥„Çª„Éº„Éï
            const actionX = canvas.width * actionMargin;
            const actionY = canvas.height * actionMargin;
            const actionW = canvas.width * (1 - actionMargin * 2);
            const actionH = canvas.height * (1 - actionMargin * 2);
            ctx.strokeRect(actionX, actionY, actionW, actionH);

            // „Çø„Ç§„Éà„É´„Çª„Éº„Éï
            const titleX = canvas.width * titleMargin;
            const titleY = canvas.height * titleMargin;
            const titleW = canvas.width * (1 - titleMargin * 2);
            const titleH = canvas.height * (1 - titleMargin * 2);
            ctx.strokeRect(titleX, titleY, titleW, titleH);

            ctx.setLineDash([]);
        }

        function drawTextObject(obj, isSelected) {
            if (!obj.text && !isTyping) return;

            ctx.save();

            // ÊèèÁîªË®≠ÂÆö
            ctx.font = `${obj.fontSize}px "${obj.fontFamily}"`;
            ctx.textBaseline = 'top';
            ctx.textAlign = 'left';

            const text = obj.text || '|';

            if (obj.vertical) {
                // Á∏¶Êõ∏„ÅçÊèèÁîª
                const chars = text.split('');
                for (let i = 0; i < chars.length; i++) {
                    ctx.save();

                    // ÂêÑÊñáÂ≠ó„ÅÆ‰ΩçÁΩÆ
                    const charY = obj.y + (i * obj.fontSize);
                    ctx.translate(obj.x, charY);
                    ctx.rotate(obj.rotation * Math.PI / 180);

                    const char = chars[i];

                    // „Ç∑„É£„Éâ„Ç¶ÊèèÁîª
                    if (obj.shadow && obj.shadow.enabled) {
                        const angle = obj.shadow.angle * Math.PI / 180;
                        const offsetX = Math.cos(angle) * obj.shadow.distance;
                        const offsetY = Math.sin(angle) * obj.shadow.distance;
                        const opacity = obj.shadow.opacity / 100;

                        const rgb = hexToRgb(obj.shadow.color);
                        ctx.fillStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`;
                        ctx.fillText(char, offsetX, offsetY);
                    }

                    // „Çπ„Éà„É≠„Éº„ÇØÊèèÁîª
                    if (obj.strokes) {
                        for (let j = obj.strokes.length - 1; j >= 0; j--) {
                            const stroke = obj.strokes[j];
                            if (stroke.enabled && stroke.size > 0) {
                                ctx.strokeStyle = stroke.color;
                                ctx.lineWidth = stroke.size;
                                ctx.lineJoin = 'round';
                                ctx.miterLimit = 2;
                                ctx.strokeText(char, 0, 0);
                            }
                        }
                    }

                    // Â°ó„ÇäÊèèÁîª
                    if (obj.fill && obj.fill.enabled) {
                        const opacity = obj.fill.opacity / 100;
                        if (opacity < 1) {
                            const rgb = hexToRgb(obj.fill.color);
                            ctx.fillStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`;
                        } else {
                            ctx.fillStyle = obj.fill.color;
                        }
                        ctx.fillText(char, 0, 0);
                    }

                    ctx.restore();
                }
            } else {
                // Ê®™Êõ∏„ÅçÊèèÁîª
                const scaleX = obj.scaleX / 100;
                ctx.translate(obj.x, obj.y);
                ctx.rotate(obj.rotation * Math.PI / 180);
                ctx.scale(scaleX, 1);

                // „Ç∑„É£„Éâ„Ç¶ÊèèÁîª
                if (obj.shadow && obj.shadow.enabled) {
                    const angle = obj.shadow.angle * Math.PI / 180;
                    const offsetX = Math.cos(angle) * obj.shadow.distance / scaleX;
                    const offsetY = Math.sin(angle) * obj.shadow.distance;
                    const opacity = obj.shadow.opacity / 100;

                    const rgb = hexToRgb(obj.shadow.color);
                    ctx.fillStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`;
                    ctx.fillText(text, offsetX, offsetY);
                }

                // „Çπ„Éà„É≠„Éº„ÇØÊèèÁîªÔºàÂ§ñÂÅ¥„Åã„ÇâÂÜÖÂÅ¥„Å∏Ôºâ
                if (obj.strokes) {
                    for (let i = obj.strokes.length - 1; i >= 0; i--) {
                        const stroke = obj.strokes[i];
                        if (stroke.enabled && stroke.size > 0) {
                            ctx.strokeStyle = stroke.color;
                            ctx.lineWidth = stroke.size;
                            ctx.lineJoin = 'round';
                            ctx.miterLimit = 2;
                            ctx.strokeText(text, 0, 0);
                        }
                    }
                }

                // „Éï„Çß„Éº„ÇπÔºàÂ°ó„ÇäÔºâÊèèÁîª
                if (obj.fill && obj.fill.enabled) {
                    const opacity = obj.fill.opacity / 100;
                    if (opacity < 1) {
                        const rgb = hexToRgb(obj.fill.color);
                        ctx.fillStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`;
                    } else {
                        ctx.fillStyle = obj.fill.color;
                    }
                    ctx.fillText(text, 0, 0);
                }
            }

            ctx.restore();

            // ÈÅ∏Êäû„Éú„ÉÉ„ÇØ„ÇπÊèèÁîªÔºà„É¨„Ç¨„Ç∑„Éº„Çø„Ç§„Éà„É´„Å®Âêå„Åò„Çπ„Çø„Ç§„É´Ôºâ
            if (isSelected) {
                const metrics = measureText(obj);
                ctx.strokeStyle = '#0099ff';
                ctx.lineWidth = 1;
                ctx.setLineDash([]);
                ctx.strokeRect(obj.x - 2, obj.y - 2, metrics.width + 4, metrics.height + 4);

                // „Éè„É≥„Éâ„É´Ôºà„É¨„Ç¨„Ç∑„Éº„Çø„Ç§„Éà„É´È¢®Ôºâ
                const handleSize = 6;
                const handles = [
                    [obj.x - 2, obj.y - 2], // Â∑¶‰∏ä
                    [obj.x + metrics.width + 2, obj.y - 2], // Âè≥‰∏ä
                    [obj.x - 2, obj.y + metrics.height + 2], // Â∑¶‰∏ã
                    [obj.x + metrics.width + 2, obj.y + metrics.height + 2], // Âè≥‰∏ã
                ];

                ctx.fillStyle = '#ffffff';
                ctx.strokeStyle = '#0099ff';
                ctx.lineWidth = 1;
                handles.forEach(([hx, hy]) => {
                    ctx.fillRect(hx - handleSize/2, hy - handleSize/2, handleSize, handleSize);
                    ctx.strokeRect(hx - handleSize/2, hy - handleSize/2, handleSize, handleSize);
                });
            }
        }

        function drawTextSelection() {
            if (!selectedObject) return;

            ctx.save();
            ctx.font = `${selectedObject.fontSize}px "${selectedObject.fontFamily}"`;

            const start = Math.min(selectionStart, selectionEnd);
            const end = Math.max(selectionStart, selectionEnd);

            const textBeforeSelection = selectedObject.text.substring(0, start);
            const selectedText = selectedObject.text.substring(start, end);

            const metricsBeforeSelection = ctx.measureText(textBeforeSelection);
            const metricsSelectedText = ctx.measureText(selectedText);

            const selectionX = selectedObject.x + metricsBeforeSelection.width * (selectedObject.scaleX / 100);
            const selectionWidth = metricsSelectedText.width * (selectedObject.scaleX / 100);
            const selectionY = selectedObject.y;
            const selectionHeight = selectedObject.fontSize;

            // Èùí„ÅÑ„Éè„Ç§„É©„Ç§„ÉàÔºà„É¨„Ç¨„Ç∑„Éº„Çø„Ç§„Éà„É´„Å®Âêå„ÅòÔºâ
            ctx.fillStyle = 'rgba(0, 102, 204, 0.3)';
            ctx.fillRect(selectionX, selectionY, selectionWidth, selectionHeight);

            ctx.restore();
        }

        function drawCursor() {
            if (!selectedObject) return;

            ctx.save();
            ctx.font = `${selectedObject.fontSize}px "${selectedObject.fontFamily}"`;
            const textBeforeCursor = selectedObject.text.substring(0, cursorPosition);
            const metrics = ctx.measureText(textBeforeCursor);
            const cursorX = selectedObject.x + metrics.width * (selectedObject.scaleX / 100);
            const cursorY = selectedObject.y;

            // „Çà„ÇäÁõÆÁ´ã„Å§„Ç´„Éº„ÇΩ„É´Ôºà„É¨„Ç¨„Ç∑„Éº„Çø„Ç§„Éà„É´„Å®Âêå„ÅòÔºâ
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(cursorX, cursorY);
            ctx.lineTo(cursorX, cursorY + selectedObject.fontSize);
            ctx.stroke();
            ctx.restore();
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 0, g: 0, b: 0 };
        }

        // „Éó„É≠„Éë„ÉÜ„Ç£„Çª„ÇØ„Ç∑„Éß„É≥„ÅÆÊäò„Çä„Åü„Åü„Åø
        document.querySelectorAll('.property-section-header').forEach(header => {
            header.addEventListener('click', () => {
                header.classList.toggle('collapsed');
                const content = header.nextElementSibling;
                content.classList.toggle('hidden');
            });
        });

        // PRTLÊõ∏„ÅçÂá∫„ÅóÔºàÊó¢Â≠ò„ÅÆPRTLGeneratorV2„Çí‰ΩøÁî®Ôºâ
        function exportPRTL() {
            if (textObjects.length === 0) {
                alert('„ÉÜ„Ç≠„Çπ„Éà„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Åå„ÅÇ„Çä„Åæ„Åõ„Çì');
                return;
            }

            // ÊúÄÂàù„ÅÆ„ÉÜ„Ç≠„Çπ„Éà„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Çí‰ΩøÁî®ÔºàË§áÊï∞ÂØæÂøú„ÅØÂæå„ÅßÂÆüË£ÖÔºâ
            const obj = textObjects[0];

            const config = {
                width: canvas.width,
                height: canvas.height,
                text: obj.text,
                fontFamily: obj.fontFamily,
                fontSize: obj.fontSize,
                scaleX: obj.scaleX,
                posX: obj.x,
                posY: obj.y,
                textAlign: 'left',
                fillType: 'solid',
                fillColor: obj.fill.color,
                stroke4_enabled: obj.strokes[3].enabled,
                stroke4_size: obj.strokes[3].size,
                stroke4_color: obj.strokes[3].color,
                stroke3_enabled: obj.strokes[2].enabled,
                stroke3_size: obj.strokes[2].size,
                stroke3_color: obj.strokes[2].color,
                stroke2_enabled: obj.strokes[1].enabled,
                stroke2_size: obj.strokes[1].size,
                stroke2_color: obj.strokes[1].color,
                stroke1_enabled: obj.strokes[0].enabled,
                stroke1_size: obj.strokes[0].size,
                stroke1_color: obj.strokes[0].color,
                shadow_enabled: obj.shadow.enabled,
                shadow_offset: obj.shadow.distance,
                shadow_angle: obj.shadow.angle,
                shadow_color: obj.shadow.color,
                shadow_opacity: obj.shadow.opacity
            };

            const generator = new PRTLGeneratorV2();
            const prtlXML = generator.generatePRTL(config);

            // UTF-8„Ç®„É≥„Ç≥„Éº„Éâ
            const encoder = new TextEncoder();
            const utf8Array = encoder.encode(prtlXML);

            const blob = new Blob([utf8Array], { type: 'application/octet-stream' });
            const link = document.createElement('a');
            link.download = `NLT_${Date.now()}.prtl`;
            link.href = URL.createObjectURL(blob);
            link.click();

            console.log('‚úÖ PRTLÊõ∏„ÅçÂá∫„ÅóÂÆå‰∫Ü');
        }

        // PRTLGeneratorV2„ÇØ„É©„ÇπÔºàÊó¢Â≠ò„ÅÆ„ÇÇ„ÅÆ„ÇíÂÜçÂà©Áî®Ôºâ
        class PRTLGeneratorV2 {
            constructor() {
                this.nextStyleID = 4096;
                this.nextShaderID = 4096;
                this.nextTextDescID = 4096;
            }

            generatePRTL(config) {
                const width = config.width || 1920;
                const height = config.height || 1080;

                const textDescriptions = this._buildTextDescriptions(config);
                const shaders = this._buildShaders(config);
                const styles = this._buildStyles(config);
                const layers = this._buildLayers(config);

                return this._buildPRTLDocument(width, height, textDescriptions, shaders, styles, layers);
            }

            _buildPRTLDocument(width, height, textDescriptions, shaders, styles, layers) {
                return `<?xml version="1.0" encoding="UTF-16" ?>` +
                    `<Adobe_Root>` +
                        `<Adobe_Title>` +
                            `<Version>20080702</Version>` +
                            `<Motion_Settings>` +
                                `<Play_Forward>true</Play_Forward>` +
                                `<Start_on_Screen>false</Start_on_Screen>` +
                                `<Pre_Roll>0</Pre_Roll>` +
                                `<Ease_In>0</Ease_In>` +
                                `<End_off_Screen>false</End_off_Screen>` +
                                `<Post_Roll>0</Post_Roll>` +
                                `<Ease_Out>0</Ease_Out>` +
                            `</Motion_Settings>` +
                        `</Adobe_Title>` +
                        `<InscriberLayouts Version="1.0">` +
                            `<Layout>` +
                                this._buildLayoutHeader(width, height) +
                                textDescriptions +
                                styles +
                                shaders +
                                this._buildTextures() +
                                this._buildLogos() +
                                layers +
                                this._buildVLS() +
                            `</Layout>` +
                        `</InscriberLayouts>` +
                    `</Adobe_Root>`;
            }

            _buildLayoutHeader(width, height) {
                return `<LayoutEffectInfo Version="2">` +
                        `<EffectType>0</EffectType>` +
                        `<Indic>false</Indic>` +
                        `<Ligatures>false</Ligatures>` +
                        `<HindiDigits>false</HindiDigits>` +
                    `</LayoutEffectInfo>` +
                    `<LayoutDimension Version="2">` +
                        `<pXPIXELS>${width}</pXPIXELS>` +
                        `<pYLINES>${height}</pYLINES>` +
                        `<pSCREENAR>1</pSCREENAR>` +
                        `<growthDirection>growRightDown</growthDirection>` +
                    `</LayoutDimension>` +
                    `<LayoutAttributes>` +
                        `<SafeTitleArea>` +
                            `<left>0.1</left><top>0.1</top><right>0.9</right><bottom>0.9</bottom>` +
                        `</SafeTitleArea>` +
                        `<SafeActionArea>` +
                            `<left>0.05</left><top>0.05</top><right>0.95</right><bottom>0.95</bottom>` +
                        `</SafeActionArea>` +
                    `</LayoutAttributes>` +
                    `<Background Version="4">` +
                        `<ShaderReference>4098</ShaderReference>` +
                        `<On>false</On>` +
                        `<paintingRange>normalLayout</paintingRange>` +
                    `</Background>` +
                    `<DefaultStyle><Reference>${this.nextStyleID}</Reference></DefaultStyle>` +
                    `<DefaultTextDescription><Reference>${this.nextTextDescID}</Reference></DefaultTextDescription>` +
                    `<GraphicObjectDefaults>` +
                        `<endCapType>square</endCapType>` +
                        `<joinTypeClosed>round</joinTypeClosed>` +
                        `<joinTypeOpen>round</joinTypeOpen>` +
                        `<lineWidth>5</lineWidth>` +
                        `<miterLimit>5</miterLimit>` +
                        `<windBeziers>false</windBeziers>` +
                        `<roundCornerFillets>37.5 37.5 37.5 37.5 37.5 37.5 37.5 37.5 </roundCornerFillets>` +
                        `<clippedCornerFillets>37.5 37.5 37.5 37.5 37.5 37.5 37.5 37.5 </clippedCornerFillets>` +
                    `</GraphicObjectDefaults>` +
                    this._buildTextChainDefaults();
            }

            _buildTextChainDefaults() {
                const defaults = `<leading>0</leading>` +
                    `<boxCanGrow>false</boxCanGrow>` +
                    `<wordWrap>true</wordWrap>` +
                    `<lockedLinesX>false</lockedLinesX>` +
                    `<lockedLinesY>false</lockedLinesY>` +
                    `<Alignment>left</Alignment>` +
                    `<tabModeStyle>Word</tabModeStyle>` +
                    `<implicitTabSpacing>100</implicitTabSpacing>` +
                    `<implicitTabType>left</implicitTabType>` +
                    `<rtl>false</rtl>` +
                    `<tabs></tabs>`;

                return `<TextChainDefaults>` +
                    `<normal>${defaults}</normal>` +
                    `<boxNormal>${defaults.replace('<wordWrap>true</wordWrap>', '<wordWrap>true</wordWrap>').replace('<lockedLinesX>false</lockedLinesX>', '<lockedLinesX>true</lockedLinesX>').replace('<lockedLinesY>false</lockedLinesY>', '<lockedLinesY>true</lockedLinesY>')}</boxNormal>` +
                    `<blockNormal>${defaults.replace('<wordWrap>true</wordWrap>', '<wordWrap>false</wordWrap>').replace('<lockedLinesX>false</lockedLinesX>', '<lockedLinesX>true</lockedLinesX>').replace('<lockedLinesY>false</lockedLinesY>', '<lockedLinesY>true</lockedLinesY>')}</blockNormal>` +
                    `<spline>${defaults}</spline>` +
                `</TextChainDefaults>`;
            }

            _buildTextDescriptions(config) {
                const ref = this.nextTextDescID;
                const fontFamily = config.fontFamily || 'Yu Gothic UI';
                const fontSize = config.fontSize || 72;
                const scaleX = config.scaleX || 100;

                return `<TextDescriptions Version="4">` +
                    `<TextDescription Reference="${ref}">` +
                        `<TypeSpec>` +
                            `<size>${fontSize * 8}</size>` +
                            `<txHeight>${fontSize}</txHeight>` +
                            `<txKern>0</txKern>` +
                            `<baselineShift>0</baselineShift>` +
                            `<leading>0</leading>` +
                            `<txSCaps>${fontSize}</txSCaps>` +
                            `<txSCapsOn>false</txSCapsOn>` +
                            `<txSlant>0</txSlant>` +
                            `<txUnderline>false</txUnderline>` +
                            `<txWidth>${scaleX}</txWidth>` +
                            `<linked>false</linked>` +
                            `<fiBold>0</fiBold>` +
                            `<fiItalic>0</fiItalic>` +
                            `<fifullName>${this._escapeXML(fontFamily)}</fifullName>` +
                            `<fifontFamilyName>${this._escapeXML(fontFamily)}</fifontFamilyName>` +
                            `<fifontStyle>Regular</fifontStyle>` +
                            `<fifontType>5</fifontType>` +
                            `<ficategory>1</ficategory>` +
                        `</TypeSpec>` +
                    `</TextDescription>` +
                `</TextDescriptions>`;
            }

            _buildStyles(config) {
                const styleID = this.nextStyleID;
                const textDescRef = this.nextTextDescID;

                let fragments = '';
                let shaderRefs = {};
                let nextPainter = 10;
                let nextShaderRef = this.nextShaderID;

                if (config.stroke4_enabled) {
                    fragments += `<Fragment>` +
                        `<size>${config.stroke4_size}</size>` +
                        `<offset>0</offset>` +
                        `<angle>0</angle>` +
                        `<ghost>false</ghost>` +
                        `<isExtendedShadowFragment>false</isExtendedShadowFragment>` +
                        `<eFragmentType>2</eFragmentType>` +
                        `<fragmentOff>false</fragmentOff>` +
                        `<placeHolder>false</placeHolder>` +
                        `<annotation>4</annotation>` +
                        `<placeHolderShaderIndex>4294967295</placeHolderShaderIndex>` +
                        `<painterMix>${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} </painterMix>` +
                    `</Fragment>`;
                    shaderRefs[nextPainter++] = nextShaderRef++;
                }

                if (config.stroke3_enabled) {
                    fragments += `<Fragment>` +
                        `<size>${config.stroke3_size}</size>` +
                        `<offset>0</offset>` +
                        `<angle>0</angle>` +
                        `<ghost>false</ghost>` +
                        `<isExtendedShadowFragment>false</isExtendedShadowFragment>` +
                        `<eFragmentType>2</eFragmentType>` +
                        `<fragmentOff>false</fragmentOff>` +
                        `<placeHolder>false</placeHolder>` +
                        `<annotation>3</annotation>` +
                        `<placeHolderShaderIndex>4294967295</placeHolderShaderIndex>` +
                        `<painterMix>${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} </painterMix>` +
                    `</Fragment>`;
                    shaderRefs[nextPainter++] = nextShaderRef++;
                }

                if (config.stroke2_enabled) {
                    fragments += `<Fragment>` +
                        `<size>${config.stroke2_size}</size>` +
                        `<offset>0</offset>` +
                        `<angle>0</angle>` +
                        `<ghost>false</ghost>` +
                        `<isExtendedShadowFragment>false</isExtendedShadowFragment>` +
                        `<eFragmentType>2</eFragmentType>` +
                        `<fragmentOff>false</fragmentOff>` +
                        `<placeHolder>false</placeHolder>` +
                        `<annotation>2</annotation>` +
                        `<placeHolderShaderIndex>4294967295</placeHolderShaderIndex>` +
                        `<painterMix>${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} </painterMix>` +
                    `</Fragment>`;
                    shaderRefs[nextPainter++] = nextShaderRef++;
                }

                if (config.stroke1_enabled) {
                    fragments += `<Fragment>` +
                        `<size>${config.stroke1_size}</size>` +
                        `<offset>0</offset>` +
                        `<angle>0</angle>` +
                        `<ghost>false</ghost>` +
                        `<isExtendedShadowFragment>false</isExtendedShadowFragment>` +
                        `<eFragmentType>2</eFragmentType>` +
                        `<fragmentOff>false</fragmentOff>` +
                        `<placeHolder>false</placeHolder>` +
                        `<annotation>1</annotation>` +
                        `<placeHolderShaderIndex>4294967295</placeHolderShaderIndex>` +
                        `<painterMix>${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} </painterMix>` +
                    `</Fragment>`;
                    shaderRefs[nextPainter++] = nextShaderRef++;
                }

                fragments += `<Fragment>` +
                    `<size>0</size>` +
                    `<offset>0</offset>` +
                    `<angle>0</angle>` +
                    `<ghost>false</ghost>` +
                    `<isExtendedShadowFragment>false</isExtendedShadowFragment>` +
                    `<eFragmentType>0</eFragmentType>` +
                    `<fragmentOff>false</fragmentOff>` +
                    `<placeHolder>false</placeHolder>` +
                    `<annotation>65538</annotation>` +
                    `<placeHolderShaderIndex>4294967295</placeHolderShaderIndex>` +
                    `<painterMix>15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 </painterMix>` +
                `</Fragment>`;
                shaderRefs[15] = nextShaderRef++;

                const shadowOff = config.shadow_enabled ? 'false' : 'true';
                fragments += `<Fragment>` +
                    `<size>0</size>` +
                    `<offset>${config.shadow_offset || 10}</offset>` +
                    `<angle>${config.shadow_angle || -45}</angle>` +
                    `<ghost>false</ghost>` +
                    `<isExtendedShadowFragment>true</isExtendedShadowFragment>` +
                    `<eFragmentType>0</eFragmentType>` +
                    `<fragmentOff>${shadowOff}</fragmentOff>` +
                    `<placeHolder>false</placeHolder>` +
                    `<annotation>65537</annotation>` +
                    `<placeHolderShaderIndex>4294967295</placeHolderShaderIndex>` +
                    `<painterMix>0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 </painterMix>` +
                `</Fragment>`;
                if (config.shadow_enabled) {
                    shaderRefs[0] = nextShaderRef++;
                }

                let shaderList = '';
                for (let i = 0; i <= 15; i++) {
                    const ref = shaderRefs[i] || 0;
                    shaderList += `<ShaderRef PainterNumber="${i}"><shaderRef>${ref}</shaderRef></ShaderRef>`;
                }
                shaderList += `<ShaderRef PainterNumber="-1"><shaderRef>0</shaderRef></ShaderRef>`;

                config._shaderRefs = shaderRefs;
                config._nextShaderRef = nextShaderRef;

                return `<Styles>` +
                    `<Style ID="${styleID}">` +
                        `<StyleBase Version="4">` +
                            `<type>50000</type>` +
                            `<positionDominance>0</positionDominance>` +
                            `<lineGradient>false</lineGradient>` +
                            `<styleRef>${styleID}</styleRef>` +
                            `<faceDistortX>0</faceDistortX>` +
                            `<faceDistortY>0</faceDistortY>` +
                            `<shadow_softness>30</shadow_softness>` +
                            `<personality>0</personality>` +
                            `<linked>false</linked>` +
                            `<EmbellishmentSizeRule>false</EmbellishmentSizeRule>` +
                            `<PainterRampType>Basic</PainterRampType>` +
                        `</StyleBase>` +
                        `<FragmentList Version="5">` +
                            fragments +
                        `</FragmentList>` +
                        `<ShaderList Version="1">` +
                            shaderList +
                        `</ShaderList>` +
                    `</Style>` +
                `</Styles>`;
            }

            _buildShaders(config) {
                let shaders = '<Shaders>';
                const shaderRefs = config._shaderRefs || {};

                for (const [painter, shaderRef] of Object.entries(shaderRefs)) {
                    const painterNum = parseInt(painter);

                    if (painterNum === 15) {
                        shaders += this._buildFaceShader(shaderRef, config);
                    } else if (painterNum === 0) {
                        shaders += this._buildShadowShader(shaderRef, config);
                    } else if (painterNum >= 10 && painterNum <= 13) {
                        const strokeNum = 14 - painterNum;
                        const strokeColor = config[`stroke${strokeNum}_color`] || '#000000';
                        shaders += this._buildStrokeShader(shaderRef, strokeColor);
                    }
                }

                shaders += '</Shaders>';
                return shaders;
            }

            _buildStrokeShader(shaderRef, color) {
                const rgb = this._parseColor(color);

                let colorSpecs = '';
                for (let i = 0; i <= 4; i++) {
                    colorSpecs += `<ColorSpec index="${i}">` +
                        `<red>${rgb.r}</red>` +
                        `<green>${rgb.g}</green>` +
                        `<blue>${rgb.b}</blue>` +
                        `<xpar>0</xpar>` +
                    `</ColorSpec>`;
                }

                return `<Shader Version="4">` +
                    `<cReference>${shaderRef}</cReference>` +
                    `<textureRef>0</textureRef>` +
                    `<colorOption>4</colorOption>` +
                    `<shaderOn>true</shaderOn>` +
                    `<glintSize>10</glintSize>` +
                    `<glintOffset>0</glintOffset>` +
                    `<rampPosTop>75</rampPosTop>` +
                    `<rampPosBottom>25</rampPosBottom>` +
                    `<rampAngle>0</rampAngle>` +
                    `<bevelBalance>0</bevelBalance>` +
                    `<rampCycle>0</rampCycle>` +
                    `<classicStyle>0</classicStyle>` +
                    `<rampType>0</rampType>` +
                    colorSpecs +
                    `<glintAngle>0</glintAngle>` +
                    `<bevelSize>0</bevelSize>` +
                    `<bevelDirection>0</bevelDirection>` +
                    `<bevelPipe>false</bevelPipe>` +
                    `<bevelAngle>0</bevelAngle>` +
                    `<bevelShape>1</bevelShape>` +
                    `<bevelShining>0</bevelShining>` +
                    `<bevelLight>false</bevelLight>` +
                    `<bevelMerge>true</bevelMerge>` +
                    `<sheenOn>false</sheenOn>` +
                `</Shader>`;
            }

            _buildFaceShader(shaderRef, config) {
                const rgb = this._parseColor(config.fillColor || '#ffffff');
                let colorSpecs = '';
                for (let i = 0; i <= 4; i++) {
                    colorSpecs += `<ColorSpec index="${i}">` +
                        `<red>${rgb.r}</red>` +
                        `<green>${rgb.g}</green>` +
                        `<blue>${rgb.b}</blue>` +
                        `<xpar>0</xpar>` +
                    `</ColorSpec>`;
                }

                return `<Shader Version="4">` +
                    `<cReference>${shaderRef}</cReference>` +
                    `<textureRef>0</textureRef>` +
                    `<colorOption>4</colorOption>` +
                    `<shaderOn>true</shaderOn>` +
                    `<glintSize>10</glintSize>` +
                    `<glintOffset>0</glintOffset>` +
                    `<rampPosTop>75</rampPosTop>` +
                    `<rampPosBottom>25</rampPosBottom>` +
                    `<rampAngle>0</rampAngle>` +
                    `<bevelBalance>0</bevelBalance>` +
                    `<rampCycle>0</rampCycle>` +
                    `<classicStyle>0</classicStyle>` +
                    `<rampType>0</rampType>` +
                    colorSpecs +
                    `<glintAngle>0</glintAngle>` +
                    `<bevelSize>0</bevelSize>` +
                    `<bevelDirection>0</bevelDirection>` +
                    `<bevelPipe>false</bevelPipe>` +
                    `<bevelAngle>0</bevelAngle>` +
                    `<bevelShape>1</bevelShape>` +
                    `<bevelShining>0</bevelShining>` +
                    `<bevelLight>false</bevelLight>` +
                    `<bevelMerge>true</bevelMerge>` +
                    `<sheenOn>false</sheenOn>` +
                `</Shader>`;
            }

            _buildShadowShader(shaderRef, config) {
                const rgb = this._parseColor(config.shadow_color || '#000000');
                const opacity = config.shadow_opacity || 50;
                const xpar = Math.round((100 - opacity) * 255 / 100);

                let colorSpecs = '';
                for (let i = 0; i <= 4; i++) {
                    colorSpecs += `<ColorSpec index="${i}">` +
                        `<red>${rgb.r}</red>` +
                        `<green>${rgb.g}</green>` +
                        `<blue>${rgb.b}</blue>` +
                        `<xpar>${i === 0 ? xpar : 0}</xpar>` +
                    `</ColorSpec>`;
                }

                return `<Shader Version="4">` +
                    `<cReference>${shaderRef}</cReference>` +
                    `<textureRef>0</textureRef>` +
                    `<colorOption>0</colorOption>` +
                    `<shaderOn>true</shaderOn>` +
                    `<glintSize>0</glintSize>` +
                    `<glintOffset>0</glintOffset>` +
                    `<rampPosTop>75</rampPosTop>` +
                    `<rampPosBottom>25</rampPosBottom>` +
                    `<rampAngle>0</rampAngle>` +
                    `<bevelBalance>0</bevelBalance>` +
                    `<rampCycle>0</rampCycle>` +
                    `<classicStyle>0</classicStyle>` +
                    `<rampType>0</rampType>` +
                    colorSpecs +
                    `<glintAngle>0</glintAngle>` +
                    `<bevelSize>0</bevelSize>` +
                    `<bevelDirection>0</bevelDirection>` +
                    `<bevelPipe>false</bevelPipe>` +
                    `<bevelAngle>0</bevelAngle>` +
                    `<bevelShape>1</bevelShape>` +
                    `<bevelShining>0</bevelShining>` +
                    `<bevelLight>false</bevelLight>` +
                    `<bevelMerge>true</bevelMerge>` +
                    `<sheenOn>false</sheenOn>` +
                `</Shader>`;
            }

            _buildLayers(config) {
                const text = config.text || '„Çµ„É≥„Éó„É´';
                const posX = config.posX || 960;
                const posY = config.posY || 540;
                const textAlign = config.textAlign || 'left';
                const styleRef = this.nextStyleID;
                const textRef = this.nextTextDescID;
                const fontSize = config.fontSize || 72;
                const txBase = fontSize * 1.2;

                return `<Layers>` +
                    `<Layer>` +
                        `<DrawPage></DrawPage>` +
                        `<TextPage>` +
                            `<TextChain>` +
                                `<ChainProperty>` +
                                    `<Position><x>${posX}</x><y>${posY}</y></Position>` +
                                    `<Size><x>1000</x><y>200</y></Size>` +
                                    `<wordWrap>false</wordWrap>` +
                                    `<Alignment>${textAlign}</Alignment>` +
                                `</ChainProperty>` +
                                `<ChainTabs></ChainTabs>` +
                                `<TextLine Version="2" objectID="1" persistentID="1">` +
                                    `<BaseProperties Version="5">` +
                                        `<txBase>${txBase}</txBase>` +
                                        `<XPos>${posX}</XPos>` +
                                        `<angle>0</angle>` +
                                        `<verticalText>false</verticalText>` +
                                        `<objectLeading>0</objectLeading>` +
                                    `</BaseProperties>` +
                                    `<EnclosingObjectType>block</EnclosingObjectType>` +
                                    `<Alignment>${textAlign}</Alignment>` +
                                    `<RTL>false</RTL>` +
                                    `<TRString>${this._escapeXML(text)}</TRString>` +
                                    `<RunLengthEncodedCharacterAttributes>` +
                                        `<CharacterAttributes ` +
                                            `RunCount="${text.length}" ` +
                                            `StyleRef="${styleRef}" ` +
                                            `TextRef="${textRef}" ` +
                                            `TXKerning="0" ` +
                                            `TXPostKerning="0" ` +
                                            `BaselineShifting="0" />` +
                                    `</RunLengthEncodedCharacterAttributes>` +
                                    `<tagName></tagName>` +
                                `</TextLine>` +
                            `</TextChain>` +
                        `</TextPage>` +
                        `<MergeGroups></MergeGroups>` +
                    `</Layer>` +
                `</Layers>`;
            }

            _buildTextures() {
                return `<Textures></Textures>`;
            }

            _buildLogos() {
                return `<Logos></Logos>`;
            }

            _buildVLS() {
                return `<VLS>` +
                    `<FileReference Version="1">` +
                        `<fileString></fileString>` +
                        `<seClass>2</seClass>` +
                        `<seCode>1000</seCode>` +
                    `</FileReference>` +
                `</VLS>`;
            }

            _parseColor(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : { r: 255, g: 255, b: 255 };
            }

            _escapeXML(str) {
                if (!str) return '';
                return String(str)
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&apos;');
            }
        }

        // Êï¥ÂàóÈñ¢Êï∞
        function alignCenter() {
            if (!selectedObject) {
                alert('„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ');
                return;
            }

            const metrics = measureText(selectedObject);
            selectedObject.x = (canvas.width - metrics.width) / 2;
            updatePropertiesPanel();
            render();
        }

        function alignMiddle() {
            if (!selectedObject) {
                alert('„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ');
                return;
            }

            const metrics = measureText(selectedObject);
            selectedObject.y = (canvas.height - metrics.height) / 2 + metrics.height;
            updatePropertiesPanel();
            render();
        }

        // „É¨„Ç§„É§„ÉºÁÆ°ÁêÜÈñ¢Êï∞
        function bringToFront() {
            if (!selectedObject) return;

            // „ÉÜ„Ç≠„Çπ„Éà„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅÆÂ†¥Âêà
            const textIndex = textObjects.indexOf(selectedObject);
            if (textIndex > -1 && textIndex < textObjects.length - 1) {
                textObjects.splice(textIndex, 1);
                textObjects.push(selectedObject);
                render();
                return;
            }

            // Âõ≥ÂΩ¢„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅÆÂ†¥Âêà
            const shapeIndex = shapeObjects.indexOf(selectedObject);
            if (shapeIndex > -1 && shapeIndex < shapeObjects.length - 1) {
                shapeObjects.splice(shapeIndex, 1);
                shapeObjects.push(selectedObject);
                render();
            }
        }

        function sendToBack() {
            if (!selectedObject) return;

            // „ÉÜ„Ç≠„Çπ„Éà„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅÆÂ†¥Âêà
            const textIndex = textObjects.indexOf(selectedObject);
            if (textIndex > 0) {
                textObjects.splice(textIndex, 1);
                textObjects.unshift(selectedObject);
                render();
                return;
            }

            // Âõ≥ÂΩ¢„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅÆÂ†¥Âêà
            const shapeIndex = shapeObjects.indexOf(selectedObject);
            if (shapeIndex > 0) {
                shapeObjects.splice(shapeIndex, 1);
                shapeObjects.unshift(selectedObject);
                render();
            }
        }

        function bringForward() {
            if (!selectedObject) return;

            // „ÉÜ„Ç≠„Çπ„Éà„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅÆÂ†¥Âêà
            const textIndex = textObjects.indexOf(selectedObject);
            if (textIndex > -1 && textIndex < textObjects.length - 1) {
                const temp = textObjects[textIndex + 1];
                textObjects[textIndex + 1] = textObjects[textIndex];
                textObjects[textIndex] = temp;
                render();
                return;
            }

            // Âõ≥ÂΩ¢„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅÆÂ†¥Âêà
            const shapeIndex = shapeObjects.indexOf(selectedObject);
            if (shapeIndex > -1 && shapeIndex < shapeObjects.length - 1) {
                const temp = shapeObjects[shapeIndex + 1];
                shapeObjects[shapeIndex + 1] = shapeObjects[shapeIndex];
                shapeObjects[shapeIndex] = temp;
                render();
            }
        }

        function sendBackward() {
            if (!selectedObject) return;

            // „ÉÜ„Ç≠„Çπ„Éà„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅÆÂ†¥Âêà
            const textIndex = textObjects.indexOf(selectedObject);
            if (textIndex > 0) {
                const temp = textObjects[textIndex - 1];
                textObjects[textIndex - 1] = textObjects[textIndex];
                textObjects[textIndex] = temp;
                render();
                return;
            }

            // Âõ≥ÂΩ¢„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÅÆÂ†¥Âêà
            const shapeIndex = shapeObjects.indexOf(selectedObject);
            if (shapeIndex > 0) {
                const temp = shapeObjects[shapeIndex - 1];
                shapeObjects[shapeIndex - 1] = shapeObjects[shapeIndex];
                shapeObjects[shapeIndex] = temp;
                render();
            }
        }

        // „Éì„É•„Éº„Ç≥„É≥„Éà„É≠„Éº„É´Èñ¢Êï∞
        function zoomIn() {
            viewportScale *= 1.2;
            applyViewportTransform();
        }

        function zoomOut() {
            viewportScale /= 1.2;
            applyViewportTransform();
        }

        function fitToScreen() {
            const container = document.querySelector('.canvas-area');
            const scaleX = (container.clientWidth - 40) / canvas.width;
            const scaleY = (container.clientHeight - 40) / canvas.height;
            viewportScale = Math.min(scaleX, scaleY);
            viewportOffsetX = 0;
            viewportOffsetY = 0;
            applyViewportTransform();
        }

        function resetView() {
            viewportScale = 1;
            viewportOffsetX = 0;
            viewportOffsetY = 0;
            applyViewportTransform();
        }

        function applyViewportTransform() {
            canvas.style.transform = `scale(${viewportScale}) translate(${viewportOffsetX}px, ${viewportOffsetY}px)`;
        }

        // „Ç≠„Éº„Éú„Éº„Éâ„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà
        document.addEventListener('keydown', (e) => {
            // IMEÂÖ•Âäõ‰∏≠„ÅØ„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà„ÇíÁÑ°ÂäπÂåñ
            if (isTyping) return;

            if (e.ctrlKey || e.metaKey) {
                // „Ç∫„Éº„É†„Éª„Éì„É•„ÉºÊìç‰Ωú
                if (e.key === '=' || e.key === '+') {
                    e.preventDefault();
                    zoomIn();
                } else if (e.key === '-') {
                    e.preventDefault();
                    zoomOut();
                } else if (e.key === '0') {
                    e.preventDefault();
                    fitToScreen();
                } else if (e.key === 'r' || e.key === 'R') {
                    e.preventDefault();
                    resetView();
                }
                // „É¨„Ç§„É§„ÉºÁÆ°ÁêÜ
                else if (e.key === ']') {
                    e.preventDefault();
                    bringToFront();
                } else if (e.key === '[') {
                    e.preventDefault();
                    sendToBack();
                }
            } else {
                // „ÉÑ„Éº„É´Âàá„ÇäÊõø„Åà
                if (e.key === 'v' || e.key === 'V') {
                    switchTool('select');
                } else if (e.key === 't' || e.key === 'T') {
                    switchTool('text');
                } else if (e.key === 'r' || e.key === 'R') {
                    switchTool('rectangle');
                } else if (e.key === 'u' || e.key === 'U') {
                    switchTool('roundRect');
                } else if (e.key === 'e' || e.key === 'E') {
                    switchTool('ellipse');
                } else if (e.key === 'p' || e.key === 'P') {
                    switchTool('polygon');
                } else if (e.key === 's' || e.key === 'S') {
                    switchTool('star');
                }
            }
        });

        // ÂàùÊúüË°®Á§∫„ÇíÁîªÈù¢„Å´Âêà„Çè„Åõ„Çã
        setTimeout(fitToScreen, 100);

        // ÂàùÊúü„É¨„É≥„ÉÄ„É™„É≥„Ç∞
        render();
    </script>
</body>
</html>

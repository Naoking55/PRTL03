<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NLT - Neo Legacy Title Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: #2d2d2d;
            color: #e0e0e0;
            overflow: hidden;
            height: 100vh;
        }

        /* メインコンテナ */
        .main-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        /* 上部ツールバー */
        .toolbar {
            background: #1e1e1e;
            padding: 8px 12px;
            border-bottom: 1px solid #000;
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .tool-btn {
            width: 32px;
            height: 32px;
            background: #3a3a3a;
            border: 1px solid #555;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #aaa;
            font-size: 18px;
            transition: all 0.2s;
        }

        .tool-btn:hover {
            background: #4a4a4a;
            color: #fff;
        }

        .tool-btn.active {
            background: #0066cc;
            color: #fff;
            border-color: #0077ee;
        }

        .toolbar-separator {
            width: 1px;
            height: 24px;
            background: #555;
            margin: 0 4px;
        }

        /* コンテンツエリア */
        .content-area {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        /* 左側ツールバー（レガシータイトルと同じレイアウト） */
        .left-toolbar {
            width: 50px;
            background: #1e1e1e;
            border-right: 1px solid #000;
            display: flex;
            flex-direction: column;
            padding: 8px 0;
            gap: 4px;
            align-items: center;
        }

        /* キャンバスエリア */
        .canvas-area {
            flex: 1;
            background: #141414;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        #canvas {
            background: repeating-conic-gradient(
                #2a2a2a 0% 25%,
                #1e1e1e 0% 50%
            ) 50% / 16px 16px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            cursor: crosshair;
            max-width: 100%;
            max-height: 100%;
        }

        #canvas.selection-mode {
            cursor: default;
        }

        /* 右側プロパティパネル */
        .properties-panel {
            width: 280px;
            background: #252525;
            border-left: 1px solid #000;
            overflow-y: auto;
            padding: 12px;
        }

        .property-section {
            margin-bottom: 16px;
            background: #2d2d2d;
            border-radius: 4px;
            overflow: hidden;
        }

        .property-section-header {
            background: #1e1e1e;
            padding: 8px 12px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #aaa;
            cursor: pointer;
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .property-section-header:hover {
            background: #252525;
        }

        .property-section-header::after {
            content: '▼';
            font-size: 8px;
            transition: transform 0.2s;
        }

        .property-section-header.collapsed::after {
            transform: rotate(-90deg);
        }

        .property-section-content {
            padding: 12px;
            display: block;
        }

        .property-section-content.hidden {
            display: none;
        }

        .property-row {
            margin-bottom: 10px;
        }

        .property-row label {
            display: block;
            font-size: 11px;
            color: #aaa;
            margin-bottom: 4px;
        }

        .property-row input,
        .property-row select {
            width: 100%;
            padding: 6px 8px;
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 3px;
            color: #fff;
            font-size: 12px;
        }

        .property-row input:focus,
        .property-row select:focus {
            outline: none;
            border-color: #0066cc;
        }

        .property-row input[type="color"] {
            height: 32px;
            padding: 2px;
            cursor: pointer;
        }

        .property-row input[type="range"] {
            padding: 0;
            accent-color: #0066cc;
        }

        .property-row input[type="checkbox"] {
            width: auto;
            margin-right: 6px;
            accent-color: #0066cc;
        }

        .property-grid-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .property-grid-3 {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 6px;
        }

        .btn {
            width: 100%;
            padding: 8px;
            background: #3a3a3a;
            border: 1px solid #555;
            border-radius: 4px;
            color: #e0e0e0;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn:hover {
            background: #4a4a4a;
        }

        .btn-primary {
            background: #0066cc;
            border-color: #0077ee;
            color: #fff;
        }

        .btn-primary:hover {
            background: #0077ee;
        }

        .value-display {
            font-size: 10px;
            color: #666;
            margin-top: 2px;
        }

        /* ツールチップ */
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 11px;
            pointer-events: none;
            z-index: 1000;
            display: none;
        }

        /* 隠しIME入力フィールド */
        #imeInput {
            position: absolute;
            padding: 4px;
            margin: 0;
            border: 1px solid transparent;
            background: transparent;
            color: transparent;
            outline: none;
            font-size: 16px;
            z-index: -1;
            opacity: 0;
            pointer-events: none;
            width: 200px;
            height: 30px;
        }

        #imeInput.active {
            z-index: 9999;
            opacity: 0.01; /* ほぼ透明だが入力可能 */
            pointer-events: auto;
            color: rgba(255, 255, 255, 0.1); /* 微かに見える */
            caret-color: transparent; /* カーソルを透明に */
        }

        /* スクロールバーのスタイル */
        ::-webkit-scrollbar {
            width: 12px;
        }

        ::-webkit-scrollbar-track {
            background: #1a1a1a;
        }

        ::-webkit-scrollbar-thumb {
            background: #4a4a4a;
            border-radius: 6px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #5a5a5a;
        }

        /* テキストオブジェクトの選択ハンドル */
        .text-selection-box {
            position: absolute;
            border: 2px solid #0066cc;
            pointer-events: none;
            z-index: 100;
        }

        .resize-handle {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #fff;
            border: 1px solid #0066cc;
            pointer-events: all;
            cursor: nwse-resize;
        }

        .resize-handle.nw { top: -4px; left: -4px; cursor: nw-resize; }
        .resize-handle.ne { top: -4px; right: -4px; cursor: ne-resize; }
        .resize-handle.sw { bottom: -4px; left: -4px; cursor: sw-resize; }
        .resize-handle.se { bottom: -4px; right: -4px; cursor: se-resize; }

        /* ステータスメッセージ */
        .status-message {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 102, 204, 0.95);
            color: #fff;
            padding: 12px 24px;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            font-size: 14px;
            font-weight: 500;
            z-index: 10000;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        .status-message.show {
            opacity: 1;
        }

        /* レイヤーパネル */
        .layer-item {
            display: flex;
            align-items: center;
            padding: 6px 8px;
            margin-bottom: 4px;
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s;
            gap: 6px;
        }

        .layer-item:hover {
            background: #252525;
            border-color: #555;
        }

        .layer-item.selected {
            background: #0066cc;
            border-color: #0077ee;
        }

        .layer-name {
            flex: 1;
            font-size: 11px;
            color: #e0e0e0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .layer-item.selected .layer-name {
            color: #fff;
            font-weight: 500;
        }

        .layer-controls {
            display: flex;
            gap: 2px;
        }

        .layer-btn {
            width: 20px;
            height: 20px;
            background: #3a3a3a;
            border: 1px solid #555;
            border-radius: 2px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #aaa;
            font-size: 10px;
            transition: all 0.2s;
        }

        .layer-btn:hover {
            background: #4a4a4a;
            color: #fff;
        }

        .layer-item.selected .layer-btn {
            background: #0055aa;
            border-color: #0066cc;
            color: #fff;
        }

        .layer-item.selected .layer-btn:hover {
            background: #0077ee;
        }

        .layers-list {
            max-height: 300px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <div class="main-container">
        <!-- 上部ツールバー -->
        <div class="toolbar">
            <span style="font-size: 11px; color: #888;">解像度:</span>
            <input type="number" id="canvasWidth" value="1920" min="1" style="width: 70px; padding: 4px; background: #3a3a3a; border: 1px solid #555; border-radius: 3px; color: #fff; font-size: 11px;">
            <span style="font-size: 11px; color: #888;">×</span>
            <input type="number" id="canvasHeight" value="1080" min="1" style="width: 70px; padding: 4px; background: #3a3a3a; border: 1px solid #555; border-radius: 3px; color: #fff; font-size: 11px;">
            <div class="toolbar-separator"></div>
            <div class="tool-btn" onclick="zoomIn()" title="拡大 (Ctrl++)">
                +
            </div>
            <div class="tool-btn" onclick="zoomOut()" title="縮小 (Ctrl+-)">
                −
            </div>
            <div class="tool-btn" onclick="fitToScreen()" title="画面に合わせる (Ctrl+0)">
                ⊡
            </div>
            <div class="tool-btn" onclick="resetView()" title="ビューリセット (Ctrl+R)">
                ⟲
            </div>
            <div class="toolbar-separator"></div>
            <div class="tool-btn" onclick="alignCenter()" title="中央揃え（横）">
                ⬌
            </div>
            <div class="tool-btn" onclick="alignMiddle()" title="中央揃え（縦）">
                ⬍
            </div>
            <div class="toolbar-separator"></div>
            <div class="tool-btn" onclick="bringToFront()" title="最前面へ (Ctrl+])">
                ⬆
            </div>
            <div class="tool-btn" onclick="sendToBack()" title="最背面へ (Ctrl+[)">
                ⬇
            </div>
            <div class="tool-btn" onclick="bringForward()" title="前面へ">
                ↑
            </div>
            <div class="tool-btn" onclick="sendBackward()" title="背面へ">
                ↓
            </div>
            <div class="toolbar-separator"></div>
            <input type="file" id="prtlFileInput" accept=".prtl" style="display: none;" onchange="importPRTL(event)">
            <button class="btn" onclick="document.getElementById('prtlFileInput').click()" style="width: auto; padding: 6px 12px;">PRTL読み込み</button>
            <button class="btn btn-primary" onclick="exportPRTL()" style="width: auto; padding: 6px 12px;">PRTL書き出し</button>
        </div>

        <!-- コンテンツエリア -->
        <div class="content-area">
            <!-- 左側ツールバー (レガシータイトルと同じレイアウト) -->
            <div class="left-toolbar">
                <div class="tool-btn active" id="selectTool" title="選択ツール (V)">
                    ➤
                </div>
                <div class="tool-btn" id="textTool" title="テキストツール (T)">
                    T
                </div>
                <div class="tool-btn" id="textVTool" title="縦書きテキストツール">
                    T↓
                </div>
                <div class="tool-btn" id="pathTextTool" title="パス上文字ツール (Shift+T)">
                    ⌇
                </div>
                <div class="tool-btn" id="rectangleTool" title="矩形ツール (R)">
                    ▭
                </div>
                <div class="tool-btn" id="roundRectTool" title="角丸矩形ツール (U)">
                    ▢
                </div>
                <div class="tool-btn" id="ellipseTool" title="楕円ツール (E)">
                    ○
                </div>
                <div class="tool-btn" id="lineTool" title="線ツール (L)">
                    ╱
                </div>
                <div class="tool-btn" id="penTool" title="ペンツール (P)">
                    ✎
                </div>
                <div class="tool-btn" id="addAnchorTool" title="アンカーポイントの追加ツール (+)">
                    ➕
                </div>
                <div class="tool-btn" id="deleteAnchorTool" title="アンカーポイントの削除ツール (-)">
                    ➖
                </div>
                <div class="tool-btn" id="convertAnchorTool" title="アンカーポイントの切り替えツール (Shift+C)">
                    ⚬
                </div>
                <div class="tool-btn" id="chamferRectTool" title="斜角長方形ツール (B)">
                    ▭
                </div>
                <div class="tool-btn" id="triangleTool" title="三角形ツール (A)">
                    △
                </div>
                <div class="tool-btn" id="arcTool" title="円弧ツール (C)">
                    ◠
                </div>
            </div>

            <!-- キャンバスエリア -->
            <div class="canvas-area">
                <canvas id="canvas" width="1920" height="1080"></canvas>
            </div>

            <!-- 右側プロパティパネル -->
            <div class="properties-panel">
                <h3 style="font-size: 12px; margin-bottom: 12px; color: #0066cc;">プロパティ</h3>

                <!-- レイヤー管理セクション -->
                <div class="property-section">
                    <div class="property-section-header">レイヤー</div>
                    <div class="property-section-content">
                        <div class="layers-list" id="layersList">
                            <!-- レイヤーアイテムが動的に生成されます -->
                        </div>
                    </div>
                </div>

                <!-- キャンバス設定セクション -->
                <div class="property-section">
                    <div class="property-section-header">キャンバス設定</div>
                    <div class="property-section-content">
                        <h4 style="font-size: 10px; color: #888; margin: 8px 0 4px;">セーフマージン</h4>
                        <div class="property-row">
                            <label><input type="checkbox" id="safeMarginEnabled" checked onchange="render()">表示</label>
                        </div>
                        <div class="property-grid-2">
                            <div class="property-row">
                                <label>アクション %</label>
                                <input type="number" id="actionSafeMargin" min="0" max="20" value="5" onchange="render()">
                            </div>
                            <div class="property-row">
                                <label>タイトル %</label>
                                <input type="number" id="titleSafeMargin" min="0" max="20" value="10" onchange="render()">
                            </div>
                        </div>
                        <div class="property-grid-2">
                            <div class="property-row">
                                <label>色</label>
                                <input type="color" id="safeMarginColor" value="#ffffff" onchange="render()">
                            </div>
                            <div class="property-row">
                                <label>不透明度 %</label>
                                <input type="number" id="safeMarginOpacity" min="0" max="100" value="50" onchange="render()">
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 変形セクション -->
                <div class="property-section">
                    <div class="property-section-header">変形</div>
                    <div class="property-section-content">
                        <div class="property-grid-2">
                            <div class="property-row">
                                <label>X座標</label>
                                <input type="number" id="prop_x" value="960" step="0.1">
                            </div>
                            <div class="property-row">
                                <label>Y座標</label>
                                <input type="number" id="prop_y" value="540" step="0.1">
                            </div>
                        </div>
                        <div class="property-grid-2">
                            <div class="property-row">
                                <label>幅</label>
                                <input type="number" id="prop_width" value="500" step="0.1" readonly>
                            </div>
                            <div class="property-row">
                                <label>高さ</label>
                                <input type="number" id="prop_height" value="100" step="0.1" readonly>
                            </div>
                        </div>
                        <div class="property-row">
                            <label>回転 (度)</label>
                            <input type="number" id="prop_rotation" value="0" step="0.1">
                        </div>
                    </div>
                </div>

                <!-- プロパティセクション -->
                <div class="property-section">
                    <div class="property-section-header">フォント</div>
                    <div class="property-section-content">
                        <div class="property-row">
                            <label>フォントファミリー</label>
                            <select id="prop_fontFamily">
                                <option value="Yu Gothic UI">Yu Gothic UI</option>
                                <option value="Arial">Arial</option>
                                <option value="Meiryo">Meiryo</option>
                                <option value="MS Gothic">MS Gothic</option>
                                <option value="Hiragino Sans">Hiragino Sans</option>
                            </select>
                        </div>
                        <div class="property-row">
                            <label>フォントスタイル</label>
                            <select id="prop_fontStyle">
                                <option value="Regular">Regular</option>
                                <option value="Bold">Bold</option>
                                <option value="Italic">Italic</option>
                            </select>
                        </div>
                        <div class="property-row">
                            <label>フォントサイズ</label>
                            <input type="number" id="prop_fontSize" value="100" min="1" max="500" step="0.1">
                        </div>
                        <div class="property-row">
                            <label>縦横比 (%)</label>
                            <input type="range" id="prop_scaleX" value="100" min="10" max="200" step="1">
                            <div class="value-display" id="scaleXValue">100%</div>
                        </div>
                        <div class="property-row">
                            <label>カーニング</label>
                            <input type="number" id="prop_kerning" value="0" step="1">
                        </div>
                        <div class="property-row">
                            <label>トラッキング</label>
                            <input type="number" id="prop_tracking" value="0" step="1">
                        </div>
                        <div class="property-row">
                            <label>ベースラインシフト</label>
                            <input type="number" id="prop_baselineShift" value="0" step="1">
                        </div>
                        <div class="property-row">
                            <label>行間</label>
                            <input type="number" id="prop_leading" value="0" step="0.1">
                        </div>
                        <div class="property-row">
                            <label>傾き (度)</label>
                            <input type="number" id="prop_slant" value="0" step="0.1" min="-45" max="45">
                        </div>
                        <div class="property-row">
                            <label><input type="checkbox" id="prop_underline">下線</label>
                        </div>
                        <div class="property-row">
                            <label><input type="checkbox" id="prop_smallCaps">スモールキャップス</label>
                        </div>
                        <div class="property-row">
                            <label>スモールキャップスサイズ (%)</label>
                            <input type="number" id="prop_smallCapsSize" value="75" min="10" max="100">
                        </div>
                        <div class="property-row">
                            <label><input type="checkbox" id="prop_vertical">縦書き</label>
                        </div>
                    </div>
                </div>

                <!-- 塗りセクション -->
                <div class="property-section">
                    <div class="property-section-header">塗り</div>
                    <div class="property-section-content">
                        <div class="property-row">
                            <label><input type="checkbox" id="fill_enabled" checked>有効</label>
                        </div>
                        <div class="property-row">
                            <label>塗りタイプ</label>
                            <select id="fill_type">
                                <option value="solid">ベタ塗り</option>
                                <option value="gradient-linear">線形グラデーション</option>
                                <option value="gradient-radial">円形グラデーション</option>
                                <option value="sheen">光沢</option>
                            </select>
                        </div>
                        <div id="solidFillControls">
                            <div class="property-grid-2">
                                <div class="property-row">
                                    <label>カラー</label>
                                    <input type="color" id="fill_color" value="#fdff00">
                                </div>
                                <div class="property-row">
                                    <label>不透明度 (%)</label>
                                    <input type="number" id="fill_opacity" value="100" min="0" max="100">
                                </div>
                            </div>
                        </div>
                        <div id="gradientFillControls" style="display: none;">
                            <div class="property-row">
                                <label>開始色</label>
                                <input type="color" id="gradient_color1" value="#fdff00">
                            </div>
                            <div class="property-row">
                                <label>終了色</label>
                                <input type="color" id="gradient_color2" value="#ff6600">
                            </div>
                            <div class="property-row">
                                <label>中間色を追加</label>
                                <input type="checkbox" id="gradient_use_color3">
                            </div>
                            <div class="property-row" id="gradient_color3_row" style="display: none;">
                                <label>中間色</label>
                                <input type="color" id="gradient_color3" value="#ffaa00">
                            </div>
                            <div class="property-row" id="gradient_color3_position_row" style="display: none;">
                                <label>中間色位置 (%)</label>
                                <input type="number" id="gradient_color3_position" value="50" min="0" max="100">
                            </div>
                            <div class="property-row" id="gradient_angle_row">
                                <label>角度 (度)</label>
                                <input type="number" id="gradient_angle" value="0" min="0" max="360">
                            </div>
                            <div class="property-row">
                                <label>不透明度 (%)</label>
                                <input type="number" id="gradient_opacity" value="100" min="0" max="100">
                            </div>
                            <div class="property-row">
                                <label>開始位置 (%)</label>
                                <input type="number" id="gradient_ratio_start" value="0" min="0" max="100">
                            </div>
                            <div class="property-row">
                                <label>終了位置 (%)</label>
                                <input type="number" id="gradient_ratio_end" value="100" min="0" max="100">
                            </div>
                            <div class="property-row">
                                <label>ぼかし (px)</label>
                                <input type="number" id="gradient_blur" value="0" min="0" max="50">
                            </div>
                        </div>
                        <div id="sheenFillControls" style="display: none;">
                            <div class="property-grid-2">
                                <div class="property-row">
                                    <label>ベース色</label>
                                    <input type="color" id="sheen_base_color" value="#000000">
                                </div>
                                <div class="property-row">
                                    <label>ハイライト色</label>
                                    <input type="color" id="sheen_highlight_color" value="#ffffff">
                                </div>
                            </div>
                            <div class="property-row">
                                <label>光沢サイズ (%)</label>
                                <input type="number" id="sheen_size" value="10" min="0" max="100">
                            </div>
                            <div class="property-row">
                                <label>光沢角度 (度)</label>
                                <input type="number" id="sheen_angle" value="0" min="0" max="360">
                            </div>
                            <div class="property-row">
                                <label>不透明度 (%)</label>
                                <input type="number" id="sheen_opacity" value="100" min="0" max="100">
                            </div>
                        </div>
                    </div>
                </div>

                <!-- ストロークセクション -->
                <div class="property-section">
                    <div class="property-section-header">ストローク</div>
                    <div class="property-section-content">
                        <div class="property-row">
                            <label><input type="checkbox" id="stroke1_enabled">ストローク1</label>
                        </div>
                        <div class="property-grid-3">
                            <div class="property-row">
                                <label>サイズ</label>
                                <input type="number" id="stroke1_size" value="8" min="0" max="200" step="0.1">
                            </div>
                            <div class="property-row">
                                <label>カラー</label>
                                <input type="color" id="stroke1_color" value="#000000">
                            </div>
                            <div class="property-row">
                                <label>不透明度 (%)</label>
                                <input type="number" id="stroke1_opacity" value="100" min="0" max="100" step="0.1">
                            </div>
                        </div>

                        <div class="property-row" style="margin-top: 12px;">
                            <label><input type="checkbox" id="stroke2_enabled">ストローク2</label>
                        </div>
                        <div class="property-grid-3">
                            <div class="property-row">
                                <label>サイズ</label>
                                <input type="number" id="stroke2_size" value="50" min="0" max="200" step="0.1">
                            </div>
                            <div class="property-row">
                                <label>カラー</label>
                                <input type="color" id="stroke2_color" value="#ffffff">
                            </div>
                            <div class="property-row">
                                <label>不透明度 (%)</label>
                                <input type="number" id="stroke2_opacity" value="100" min="0" max="100" step="0.1">
                            </div>
                        </div>

                        <div class="property-row" style="margin-top: 12px;">
                            <label><input type="checkbox" id="stroke3_enabled">ストローク3</label>
                        </div>
                        <div class="property-grid-3">
                            <div class="property-row">
                                <label>サイズ</label>
                                <input type="number" id="stroke3_size" value="68" min="0" max="200" step="0.1">
                            </div>
                            <div class="property-row">
                                <label>カラー</label>
                                <input type="color" id="stroke3_color" value="#000000">
                            </div>
                            <div class="property-row">
                                <label>不透明度 (%)</label>
                                <input type="number" id="stroke3_opacity" value="100" min="0" max="100" step="0.1">
                            </div>
                        </div>

                        <div class="property-row" style="margin-top: 12px;">
                            <label><input type="checkbox" id="stroke4_enabled">ストローク4</label>
                        </div>
                        <div class="property-grid-3">
                            <div class="property-row">
                                <label>サイズ</label>
                                <input type="number" id="stroke4_size" value="78" min="0" max="200" step="0.1">
                            </div>
                            <div class="property-row">
                                <label>カラー</label>
                                <input type="color" id="stroke4_color" value="#000000">
                            </div>
                            <div class="property-row">
                                <label>不透明度 (%)</label>
                                <input type="number" id="stroke4_opacity" value="100" min="0" max="100" step="0.1">
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 影セクション -->
                <div class="property-section">
                    <div class="property-section-header">影</div>
                    <div class="property-section-content">
                        <div class="property-row">
                            <label><input type="checkbox" id="shadow_enabled">有効</label>
                        </div>
                        <div class="property-grid-2">
                            <div class="property-row">
                                <label>カラー</label>
                                <input type="color" id="shadow_color" value="#000000">
                            </div>
                            <div class="property-row">
                                <label>不透明度 (%)</label>
                                <input type="number" id="shadow_opacity" value="50" min="0" max="100">
                            </div>
                        </div>
                        <div class="property-grid-2">
                            <div class="property-row">
                                <label>距離</label>
                                <input type="number" id="shadow_distance" value="10" min="0" max="100" step="0.1">
                            </div>
                            <div class="property-row">
                                <label>角度 (度)</label>
                                <input type="number" id="shadow_angle" value="135" min="-180" max="180" step="0.1">
                            </div>
                        </div>
                        <div class="property-grid-2">
                            <div class="property-row">
                                <label>サイズ (%)</label>
                                <input type="number" id="shadow_size" value="90" min="0" max="200" step="0.1">
                            </div>
                            <div class="property-row">
                                <label>ぼかし</label>
                                <input type="number" id="shadow_blur" value="0" min="0" max="100" step="0.1">
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 隠しIME入力用 -->
    <input type="text" id="imeInput" autocomplete="off">

    <script>
        // グローバル変数
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let currentTool = 'select'; // 'select', 'text', 'rectangle', 'roundRect', 'ellipse', 'line', 'pen', 'chamferRect', 'triangle', 'arc'
        let textObjects = []; // { text, x, y, fontSize, fontFamily, scaleX, ... }
        let pathTextObjects = []; // { text, path, fontSize, fontFamily, ... }
        let shapeObjects = []; // { type, x, y, width, height, ... }
        let selectedObject = null;
        let isTyping = false;
        let cursorPosition = 0;
        let selectionStart = 0;
        let isComposing = false; // IME変換中かどうか
        let selectionEnd = 0;

        // レイヤー管理用
        let layers = []; // 統合されたレイヤー配列 { type: 'text'|'shape'|'pathText', object: オブジェクトへの参照, name: 表示名 }
        let lastObjectCount = 0; // レイヤーリスト更新のための前回のオブジェクト数
        let lastSelectedObject = null; // 前回選択されていたオブジェクト

        // ビューポート制御
        let viewportScale = 1;
        let viewportOffsetX = 0;
        let viewportOffsetY = 0;

        // カーソル点滅用
        let cursorVisible = true;
        setInterval(() => {
            cursorVisible = !cursorVisible;
            if (isTyping) render();
        }, 530);

        // ツール切り替え
        document.getElementById('selectTool').addEventListener('click', () => {
            switchTool('select');
        });

        document.getElementById('textTool').addEventListener('click', () => {
            switchTool('text');
        });

        document.getElementById('textVTool').addEventListener('click', () => {
            switchTool('textV');
        });

        document.getElementById('pathTextTool').addEventListener('click', () => {
            switchTool('pathText');
        });

        document.getElementById('rectangleTool').addEventListener('click', () => {
            switchTool('rectangle');
        });

        document.getElementById('roundRectTool').addEventListener('click', () => {
            switchTool('roundRect');
        });

        document.getElementById('ellipseTool').addEventListener('click', () => {
            switchTool('ellipse');
        });

        document.getElementById('lineTool').addEventListener('click', () => {
            switchTool('line');
        });

        document.getElementById('penTool').addEventListener('click', () => {
            switchTool('pen');
        });

        document.getElementById('addAnchorTool').addEventListener('click', () => {
            switchTool('addAnchor');
        });

        document.getElementById('deleteAnchorTool').addEventListener('click', () => {
            switchTool('deleteAnchor');
        });

        document.getElementById('convertAnchorTool').addEventListener('click', () => {
            switchTool('convertAnchor');
        });

        document.getElementById('chamferRectTool').addEventListener('click', () => {
            switchTool('chamferRect');
        });

        document.getElementById('triangleTool').addEventListener('click', () => {
            switchTool('triangle');
        });

        document.getElementById('arcTool').addEventListener('click', () => {
            switchTool('arc');
        });

        function switchTool(tool) {
            // テキスト編集中の場合は終了（空のテキストは削除される）
            if (isTyping && tool !== 'text' && tool !== 'textV') {
                isTyping = false;
                const imeInput = document.getElementById('imeInput');
                imeInput.classList.remove('active');
                imeInput.blur();

                // 空のテキストオブジェクトを削除
                if (selectedObject && selectedObject.text.trim() === '') {
                    const index = textObjects.indexOf(selectedObject);
                    if (index !== -1) {
                        textObjects.splice(index, 1);
                        selectedObject = null;
                    }
                }
                render();
            }

            currentTool = tool;

            // 全ツールのactiveクラスを削除
            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));

            // 選択されたツールをアクティブに
            if (tool === 'select') {
                document.getElementById('selectTool').classList.add('active');
                canvas.classList.add('selection-mode');
                canvas.style.cursor = 'default';
            } else if (tool === 'text') {
                document.getElementById('textTool').classList.add('active');
                canvas.classList.remove('selection-mode');
                canvas.style.cursor = 'crosshair';
            } else if (tool === 'textV') {
                document.getElementById('textVTool').classList.add('active');
                canvas.classList.remove('selection-mode');
                canvas.style.cursor = 'crosshair';
            } else if (tool === 'pathText') {
                document.getElementById('pathTextTool').classList.add('active');
                canvas.classList.remove('selection-mode');
                canvas.style.cursor = 'crosshair';
            } else if (tool === 'rectangle') {
                document.getElementById('rectangleTool').classList.add('active');
                canvas.classList.remove('selection-mode');
                canvas.style.cursor = 'crosshair';
            } else if (tool === 'roundRect') {
                document.getElementById('roundRectTool').classList.add('active');
                canvas.classList.remove('selection-mode');
                canvas.style.cursor = 'crosshair';
            } else if (tool === 'ellipse') {
                document.getElementById('ellipseTool').classList.add('active');
                canvas.classList.remove('selection-mode');
                canvas.style.cursor = 'crosshair';
            } else if (tool === 'line') {
                document.getElementById('lineTool').classList.add('active');
                canvas.classList.remove('selection-mode');
                canvas.style.cursor = 'crosshair';
            } else if (tool === 'pen') {
                document.getElementById('penTool').classList.add('active');
                canvas.classList.remove('selection-mode');
                canvas.style.cursor = 'crosshair';
            } else if (tool === 'addAnchor') {
                document.getElementById('addAnchorTool').classList.add('active');
                canvas.classList.remove('selection-mode');
                canvas.style.cursor = 'crosshair';
            } else if (tool === 'deleteAnchor') {
                document.getElementById('deleteAnchorTool').classList.add('active');
                canvas.classList.remove('selection-mode');
                canvas.style.cursor = 'crosshair';
            } else if (tool === 'convertAnchor') {
                document.getElementById('convertAnchorTool').classList.add('active');
                canvas.classList.remove('selection-mode');
                canvas.style.cursor = 'crosshair';
            } else if (tool === 'chamferRect') {
                document.getElementById('chamferRectTool').classList.add('active');
                canvas.classList.remove('selection-mode');
                canvas.style.cursor = 'crosshair';
            } else if (tool === 'triangle') {
                document.getElementById('triangleTool').classList.add('active');
                canvas.classList.remove('selection-mode');
                canvas.style.cursor = 'crosshair';
            } else if (tool === 'arc') {
                document.getElementById('arcTool').classList.add('active');
                canvas.classList.remove('selection-mode');
                canvas.style.cursor = 'crosshair';
            }
        }

        // レイヤー管理関数
        function updateLayersList() {
            // 全オブジェクトを収集してレイヤー配列を構築
            layers = [];

            // 図形オブジェクトを追加
            shapeObjects.forEach((obj, index) => {
                let typeName = '';
                switch(obj.type) {
                    case 'rectangle': typeName = '矩形'; break;
                    case 'roundRect': typeName = '角丸矩形'; break;
                    case 'ellipse': typeName = '楕円'; break;
                    case 'line': typeName = '線'; break;
                    case 'pen': typeName = 'ペンパス'; break;
                    case 'chamferRect': typeName = '斜角矩形'; break;
                    case 'triangle': typeName = '三角形'; break;
                    case 'arc': typeName = '円弧'; break;
                    default: typeName = '図形';
                }
                layers.push({
                    type: 'shape',
                    object: obj,
                    name: `レイヤー${layers.length + 1}（${typeName}）`
                });
            });

            // テキストオブジェクトを追加
            textObjects.forEach((obj, index) => {
                const previewText = obj.text.substring(0, 10) + (obj.text.length > 10 ? '...' : '');
                layers.push({
                    type: 'text',
                    object: obj,
                    name: `レイヤー${layers.length + 1}（テキスト${previewText ? ': ' + previewText : ''}）`
                });
            });

            // パス上文字オブジェクトを追加
            pathTextObjects.forEach((obj, index) => {
                const previewText = obj.text.substring(0, 10) + (obj.text.length > 10 ? '...' : '');
                layers.push({
                    type: 'pathText',
                    object: obj,
                    name: `レイヤー${layers.length + 1}（パス上文字${previewText ? ': ' + previewText : ''}）`
                });
            });

            // レイヤーリストのHTMLを生成
            const layersList = document.getElementById('layersList');
            layersList.innerHTML = '';

            // レイヤーを逆順で表示（上のレイヤーが上に表示される）
            for (let i = layers.length - 1; i >= 0; i--) {
                const layer = layers[i];
                const isSelected = layer.object === selectedObject;

                const layerItem = document.createElement('div');
                layerItem.className = 'layer-item' + (isSelected ? ' selected' : '');

                const layerName = document.createElement('div');
                layerName.className = 'layer-name';
                layerName.textContent = layer.name;

                const layerControls = document.createElement('div');
                layerControls.className = 'layer-controls';

                // 上移動ボタン
                const upBtn = document.createElement('div');
                upBtn.className = 'layer-btn';
                upBtn.textContent = '↑';
                upBtn.title = '前面へ';
                upBtn.onclick = (e) => {
                    e.stopPropagation();
                    moveLayerUp(i);
                };

                // 下移動ボタン
                const downBtn = document.createElement('div');
                downBtn.className = 'layer-btn';
                downBtn.textContent = '↓';
                downBtn.title = '背面へ';
                downBtn.onclick = (e) => {
                    e.stopPropagation();
                    moveLayerDown(i);
                };

                // 削除ボタン
                const deleteBtn = document.createElement('div');
                deleteBtn.className = 'layer-btn';
                deleteBtn.textContent = '×';
                deleteBtn.title = '削除';
                deleteBtn.onclick = (e) => {
                    e.stopPropagation();
                    deleteLayer(i);
                };

                layerControls.appendChild(upBtn);
                layerControls.appendChild(downBtn);
                layerControls.appendChild(deleteBtn);

                layerItem.appendChild(layerName);
                layerItem.appendChild(layerControls);

                // レイヤークリックで選択
                layerItem.onclick = () => selectLayer(i);

                layersList.appendChild(layerItem);
            }
        }

        function selectLayer(index) {
            const layer = layers[index];
            selectedObject = layer.object;
            updatePropertiesPanel();
            updateLayersList();
            render();
        }

        function moveLayerUp(index) {
            if (index >= layers.length - 1) return; // 既に最上位

            const layer = layers[index];

            // 元の配列内での位置を特定して移動
            if (layer.type === 'shape') {
                const objIndex = shapeObjects.indexOf(layer.object);
                if (objIndex !== -1 && objIndex < shapeObjects.length - 1) {
                    // 配列内で1つ後ろに移動（描画順序が後=前面）
                    [shapeObjects[objIndex], shapeObjects[objIndex + 1]] =
                    [shapeObjects[objIndex + 1], shapeObjects[objIndex]];
                }
            } else if (layer.type === 'text') {
                const objIndex = textObjects.indexOf(layer.object);
                if (objIndex !== -1 && objIndex < textObjects.length - 1) {
                    [textObjects[objIndex], textObjects[objIndex + 1]] =
                    [textObjects[objIndex + 1], textObjects[objIndex]];
                }
            } else if (layer.type === 'pathText') {
                const objIndex = pathTextObjects.indexOf(layer.object);
                if (objIndex !== -1 && objIndex < pathTextObjects.length - 1) {
                    [pathTextObjects[objIndex], pathTextObjects[objIndex + 1]] =
                    [pathTextObjects[objIndex + 1], pathTextObjects[objIndex]];
                }
            }

            updateLayersList();
            render();
        }

        function moveLayerDown(index) {
            if (index <= 0) return; // 既に最下位

            const layer = layers[index];

            // 元の配列内での位置を特定して移動
            if (layer.type === 'shape') {
                const objIndex = shapeObjects.indexOf(layer.object);
                if (objIndex !== -1 && objIndex > 0) {
                    // 配列内で1つ前に移動（描画順序が前=背面）
                    [shapeObjects[objIndex], shapeObjects[objIndex - 1]] =
                    [shapeObjects[objIndex - 1], shapeObjects[objIndex]];
                }
            } else if (layer.type === 'text') {
                const objIndex = textObjects.indexOf(layer.object);
                if (objIndex !== -1 && objIndex > 0) {
                    [textObjects[objIndex], textObjects[objIndex - 1]] =
                    [textObjects[objIndex - 1], textObjects[objIndex]];
                }
            } else if (layer.type === 'pathText') {
                const objIndex = pathTextObjects.indexOf(layer.object);
                if (objIndex !== -1 && objIndex > 0) {
                    [pathTextObjects[objIndex], pathTextObjects[objIndex - 1]] =
                    [pathTextObjects[objIndex - 1], pathTextObjects[objIndex]];
                }
            }

            updateLayersList();
            render();
        }

        function deleteLayer(index) {
            const layer = layers[index];

            // 元の配列から削除
            if (layer.type === 'shape') {
                const objIndex = shapeObjects.indexOf(layer.object);
                if (objIndex !== -1) {
                    shapeObjects.splice(objIndex, 1);
                }
            } else if (layer.type === 'text') {
                const objIndex = textObjects.indexOf(layer.object);
                if (objIndex !== -1) {
                    textObjects.splice(objIndex, 1);
                }
            } else if (layer.type === 'pathText') {
                const objIndex = pathTextObjects.indexOf(layer.object);
                if (objIndex !== -1) {
                    pathTextObjects.splice(objIndex, 1);
                }
            }

            // 選択中のオブジェクトだった場合は選択解除
            if (selectedObject === layer.object) {
                selectedObject = null;
            }

            updateLayersList();
            render();
        }

        // キャンバス解像度変更
        document.getElementById('canvasWidth').addEventListener('change', function() {
            canvas.width = parseInt(this.value);
            render();
        });

        document.getElementById('canvasHeight').addEventListener('change', function() {
            canvas.height = parseInt(this.value);
            render();
        });

        // 縦横比スライダーの値表示
        document.getElementById('prop_scaleX').addEventListener('input', function() {
            document.getElementById('scaleXValue').textContent = this.value + '%';
            if (selectedObject) {
                selectedObject.scaleX = parseInt(this.value);
                render();
            }
        });

        // プロパティ変更時のリアルタイム更新
        const propertyInputs = [
            'prop_x', 'prop_y', 'prop_fontSize', 'prop_fontFamily',
            'prop_kerning', 'prop_tracking', 'prop_rotation', 'prop_vertical',
            'prop_leading', 'prop_slant', 'prop_underline', 'prop_smallCaps', 'prop_smallCapsSize',
            'fill_color', 'fill_opacity', 'fill_enabled',
            'stroke1_enabled', 'stroke1_size', 'stroke1_color', 'stroke1_opacity',
            'stroke2_enabled', 'stroke2_size', 'stroke2_color', 'stroke2_opacity',
            'stroke3_enabled', 'stroke3_size', 'stroke3_color', 'stroke3_opacity',
            'stroke4_enabled', 'stroke4_size', 'stroke4_color', 'stroke4_opacity',
            'shadow_enabled', 'shadow_color', 'shadow_opacity', 'shadow_distance', 'shadow_angle', 'shadow_size', 'shadow_blur'
        ];

        propertyInputs.forEach(id => {
            const el = document.getElementById(id);
            if (el) {
                el.addEventListener('input', updateSelectedObjectFromProperties);
                el.addEventListener('change', updateSelectedObjectFromProperties);
            }
        });

        // 塗りタイプの変更イベント
        document.getElementById('fill_type').addEventListener('change', function() {
            const fillType = this.value;
            const solidControls = document.getElementById('solidFillControls');
            const gradientControls = document.getElementById('gradientFillControls');
            const sheenControls = document.getElementById('sheenFillControls');

            if (fillType === 'solid') {
                solidControls.style.display = 'block';
                gradientControls.style.display = 'none';
                sheenControls.style.display = 'none';
            } else if (fillType === 'gradient-linear' || fillType === 'gradient-radial') {
                solidControls.style.display = 'none';
                gradientControls.style.display = 'block';
                sheenControls.style.display = 'none';
                // 円形グラデーションの場合は角度を非表示
                document.getElementById('gradient_angle_row').style.display =
                    fillType === 'gradient-linear' ? 'flex' : 'none';
            } else if (fillType === 'sheen') {
                solidControls.style.display = 'none';
                gradientControls.style.display = 'none';
                sheenControls.style.display = 'block';
            } else {
                solidControls.style.display = 'block';
                gradientControls.style.display = 'none';
                sheenControls.style.display = 'none';
            }

            updateSelectedObjectFromProperties();
        });

        // グラデーション中間色のチェックボックス
        document.getElementById('gradient_use_color3').addEventListener('change', function() {
            const useColor3 = this.checked;
            document.getElementById('gradient_color3_row').style.display = useColor3 ? 'flex' : 'none';
            document.getElementById('gradient_color3_position_row').style.display = useColor3 ? 'flex' : 'none';
            updateSelectedObjectFromProperties();
        });

        // グラデーション関連の入力イベント
        ['gradient_color1', 'gradient_color2', 'gradient_color3', 'gradient_color3_position',
         'gradient_angle', 'gradient_opacity', 'gradient_ratio_start', 'gradient_ratio_end', 'gradient_blur'].forEach(id => {
            const el = document.getElementById(id);
            if (el) {
                el.addEventListener('input', updateSelectedObjectFromProperties);
                el.addEventListener('change', updateSelectedObjectFromProperties);
            }
        });

        // 光沢関連の入力イベント
        ['sheen_base_color', 'sheen_highlight_color', 'sheen_size', 'sheen_angle', 'sheen_opacity'].forEach(id => {
            const el = document.getElementById(id);
            if (el) {
                el.addEventListener('input', updateSelectedObjectFromProperties);
                el.addEventListener('change', updateSelectedObjectFromProperties);
            }
        });

        function updateSelectedObjectFromProperties() {
            if (!selectedObject) return;

            // 図形オブジェクトかどうかを判定
            const isShapeObject = selectedObject.type &&
                ['rectangle', 'roundRect', 'ellipse', 'polygon', 'star'].includes(selectedObject.type);

            selectedObject.x = parseFloat(document.getElementById('prop_x').value) || 0;
            selectedObject.y = parseFloat(document.getElementById('prop_y').value) || 0;

            // テキストオブジェクトのプロパティのみ更新
            if (!isShapeObject) {
                selectedObject.fontSize = parseInt(document.getElementById('prop_fontSize').value) || 72;
                selectedObject.fontFamily = document.getElementById('prop_fontFamily').value;
                selectedObject.scaleX = parseInt(document.getElementById('prop_scaleX').value) || 100;
                selectedObject.kerning = parseInt(document.getElementById('prop_kerning').value) || 0;
                selectedObject.tracking = parseInt(document.getElementById('prop_tracking').value) || 0;
                selectedObject.baselineShift = parseFloat(document.getElementById('prop_baselineShift').value) || 0;
                selectedObject.rotation = parseFloat(document.getElementById('prop_rotation').value) || 0;
                selectedObject.vertical = document.getElementById('prop_vertical').checked;
                selectedObject.leading = parseFloat(document.getElementById('prop_leading').value) || 0;
                selectedObject.slant = parseFloat(document.getElementById('prop_slant').value) || 0;
                selectedObject.underline = document.getElementById('prop_underline').checked;
                selectedObject.smallCaps = document.getElementById('prop_smallCaps').checked;
                selectedObject.smallCapsSize = parseInt(document.getElementById('prop_smallCapsSize').value) || 75;
            }

            const fillType = document.getElementById('fill_type').value;
            selectedObject.fill = {
                enabled: document.getElementById('fill_enabled').checked,
                type: fillType,
                color: document.getElementById('fill_color').value,
                opacity: parseInt(document.getElementById('fill_opacity').value) || 100
            };

            // グラデーション設定
            if (fillType === 'gradient-linear' || fillType === 'gradient-radial') {
                selectedObject.fill.gradient = {
                    type: fillType,
                    color1: document.getElementById('gradient_color1').value,
                    color2: document.getElementById('gradient_color2').value,
                    useColor3: document.getElementById('gradient_use_color3').checked,
                    color3: document.getElementById('gradient_color3').value,
                    color3Position: parseInt(document.getElementById('gradient_color3_position').value) || 50,
                    angle: parseInt(document.getElementById('gradient_angle').value) || 0,
                    opacity: parseInt(document.getElementById('gradient_opacity').value) || 100,
                    ratioStart: parseInt(document.getElementById('gradient_ratio_start').value) || 0,
                    ratioEnd: parseInt(document.getElementById('gradient_ratio_end').value) || 100,
                    blur: parseInt(document.getElementById('gradient_blur').value) || 0
                };
            }

            // 光沢設定
            if (fillType === 'sheen') {
                selectedObject.fill.sheen = {
                    baseColor: document.getElementById('sheen_base_color').value,
                    highlightColor: document.getElementById('sheen_highlight_color').value,
                    size: parseInt(document.getElementById('sheen_size').value) || 10,
                    angle: parseInt(document.getElementById('sheen_angle').value) || 0,
                    opacity: parseInt(document.getElementById('sheen_opacity').value) || 100
                };
            }

            // ストロークとシャドウの更新
            if (!isShapeObject) {
                // テキストオブジェクトの場合、複数のストロークを配列で管理
                selectedObject.strokes = [
                    {
                        enabled: document.getElementById('stroke1_enabled').checked,
                        size: parseInt(document.getElementById('stroke1_size').value) || 0,
                        color: document.getElementById('stroke1_color').value,
                        opacity: parseInt(document.getElementById('stroke1_opacity').value) || 100
                    },
                    {
                        enabled: document.getElementById('stroke2_enabled').checked,
                        size: parseInt(document.getElementById('stroke2_size').value) || 0,
                        color: document.getElementById('stroke2_color').value,
                        opacity: parseInt(document.getElementById('stroke2_opacity').value) || 100
                    },
                    {
                        enabled: document.getElementById('stroke3_enabled').checked,
                        size: parseInt(document.getElementById('stroke3_size').value) || 0,
                        color: document.getElementById('stroke3_color').value,
                        opacity: parseInt(document.getElementById('stroke3_opacity').value) || 100
                    },
                    {
                        enabled: document.getElementById('stroke4_enabled').checked,
                        size: parseInt(document.getElementById('stroke4_size').value) || 0,
                        color: document.getElementById('stroke4_color').value,
                        opacity: parseInt(document.getElementById('stroke4_opacity').value) || 100
                    }
                ];

                selectedObject.shadow = {
                    enabled: document.getElementById('shadow_enabled').checked,
                    color: document.getElementById('shadow_color').value,
                    opacity: parseInt(document.getElementById('shadow_opacity').value) || 50,
                    distance: parseInt(document.getElementById('shadow_distance').value) || 10,
                    angle: parseInt(document.getElementById('shadow_angle').value) || -45,
                    size: parseInt(document.getElementById('shadow_size').value) || 90,
                    blur: parseInt(document.getElementById('shadow_blur').value) || 0
                };
            } else {
                // 図形オブジェクトの場合も複数のストロークを配列で管理
                selectedObject.strokes = [
                    {
                        enabled: document.getElementById('stroke1_enabled').checked,
                        size: parseInt(document.getElementById('stroke1_size').value) || 0,
                        color: document.getElementById('stroke1_color').value,
                        opacity: parseInt(document.getElementById('stroke1_opacity').value) || 100
                    },
                    {
                        enabled: document.getElementById('stroke2_enabled').checked,
                        size: parseInt(document.getElementById('stroke2_size').value) || 0,
                        color: document.getElementById('stroke2_color').value,
                        opacity: parseInt(document.getElementById('stroke2_opacity').value) || 100
                    },
                    {
                        enabled: document.getElementById('stroke3_enabled').checked,
                        size: parseInt(document.getElementById('stroke3_size').value) || 0,
                        color: document.getElementById('stroke3_color').value,
                        opacity: parseInt(document.getElementById('stroke3_opacity').value) || 100
                    },
                    {
                        enabled: document.getElementById('stroke4_enabled').checked,
                        size: parseInt(document.getElementById('stroke4_size').value) || 0,
                        color: document.getElementById('stroke4_color').value,
                        opacity: parseInt(document.getElementById('stroke4_opacity').value) || 100
                    }
                ];
                // 後方互換性のため、単一のstrokeプロパティも保持
                selectedObject.stroke = selectedObject.strokes[0];
            }

            render();
        }

        // マウスイベント処理
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let dragTarget = null; // 'object' or 'handle-nw', 'handle-ne', etc.
        let dragStartObjX = 0;
        let dragStartObjY = 0;
        let dragStartWidth = 0;
        let dragStartHeight = 0;
        let isCreatingShape = false;
        let currentShape = null;

        // ペンツール関連の変数
        let isDrawingPath = false; // パス描画中
        let currentPath = null; // 現在描画中のパス
        let isDraggingHandle = false; // ハンドルをドラッグ中
        let selectedAnchorIndex = -1; // 選択中のアンカーポイントのインデックス
        let draggedHandleType = null; // 'in' or 'out'

        // パス上文字ツール関連の変数
        let isDrawingPathTextPath = false; // パス上文字用のパス描画中
        let currentPathTextPath = null; // 現在描画中のパス上文字用パス
        let isDraggingPathTextHandle = false; // パス上文字のハンドルをドラッグ中
        let selectedPathTextAnchorIndex = -1; // パス上文字の選択中アンカーポイント

        let renderScheduled = false; // render()のスケジュール管理

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (canvas.width / rect.width);
            const y = (e.clientY - rect.top) * (canvas.height / rect.height);

            dragStartX = x;
            dragStartY = y;

            if (currentTool === 'pathText') {
                // パス上文字ツール: 既存のパスを選択するか、新しいパスを作成
                if (!isDrawingPathTextPath) {
                    // まず既存のパス（線またはペンツール）を探す
                    let selectedPath = null;
                    let pathPoints = [];

                    // shapeObjectsから線またはペンツールのパスを探す（後ろから）
                    for (let i = shapeObjects.length - 1; i >= 0; i--) {
                        const obj = shapeObjects[i];

                        if (obj.type === 'line') {
                            // 線ツールで作成された線: 線に近いかチェック
                            const startX = obj.x;
                            const startY = obj.y;
                            const endX = obj.x + obj.width;
                            const endY = obj.y + obj.height;

                            // 線との距離を計算
                            const dist = distanceToLineSegment(x, y, startX, startY, endX, endY);
                            if (dist < 20) {
                                selectedPath = obj;
                                pathPoints = [
                                    { x: startX, y: startY },
                                    { x: endX, y: endY }
                                ];
                                break;
                            }
                        } else if (obj.type === 'pen') {
                            // ペンツールで作成されたパス
                            if (obj.anchors && obj.anchors.length > 0) {
                                // 新しいペンツール（ベジエパス）: アンカーポイントに近いかチェック
                                for (let j = 0; j < obj.anchors.length; j++) {
                                    const p = obj.anchors[j];
                                    const dist = Math.sqrt((x - p.x) ** 2 + (y - p.y) ** 2);
                                    if (dist < 20) {
                                        selectedPath = obj;
                                        // アンカーポイントをパスポイントに変換
                                        pathPoints = obj.anchors.map(a => ({ x: a.x, y: a.y }));
                                        break;
                                    }
                                }
                                if (selectedPath) break;
                            } else if (obj.points && obj.points.length > 0) {
                                // 古いペンツール（フリーハンド）: パス上の点に近いかチェック
                                for (let j = 0; j < obj.points.length; j++) {
                                    const p = obj.points[j];
                                    const dist = Math.sqrt((x - p.x) ** 2 + (y - p.y) ** 2);
                                    if (dist < 20) {
                                        selectedPath = obj;
                                        pathPoints = [...obj.points];
                                        break;
                                    }
                                }
                                if (selectedPath) break;
                            }
                        }
                    }

                    if (selectedPath && pathPoints.length >= 2) {
                        // パスが見つかった場合、パス上文字オブジェクトを作成
                        const newPathText = {
                            text: '',
                            path: pathPoints,
                            fontSize: 100,
                            fontFamily: 'Yu Gothic UI',
                            scaleX: 100,
                            kerning: 0,
                            tracking: 0,
                            baselineShift: 0,
                            rotation: 0,
                            leading: 0,
                            slant: 0,
                            underline: false,
                            smallCaps: false,
                            smallCapsSize: 75,
                            fill: {
                                enabled: true,
                                type: 'solid',
                                color: '#fdff00',
                                opacity: 100
                            },
                            strokes: [
                                { enabled: false, size: 8, color: '#000000', opacity: 100 },
                                { enabled: false, size: 50, color: '#ffffff', opacity: 100 },
                                { enabled: false, size: 68, color: '#000000', opacity: 100 },
                                { enabled: false, size: 78, color: '#000000', opacity: 100 }
                            ],
                            shadow: {
                                enabled: false,
                                color: '#000000',
                                opacity: 50,
                                distance: 10,
                                angle: 135,
                                size: 90,
                                blur: 0
                            }
                        };

                        pathTextObjects.push(newPathText);
                        selectedObject = newPathText;
                        updatePropertiesPanel();
                        startTyping();
                        render();
                    } else {
                        // パスが見つからなかった場合、新しいパスの作成を開始
                        isDrawingPathTextPath = true;
                        currentPathTextPath = {
                            anchors: [{
                                x: x,
                                y: y,
                                handleIn: null,
                                handleOut: null,
                                type: 'corner'
                            }]
                        };
                        isDraggingPathTextHandle = true;
                        selectedPathTextAnchorIndex = 0;
                        render();
                    }
                } else {
                    // パス描画中 - 新しいアンカーポイントを追加
                    currentPathTextPath.anchors.push({
                        x: x,
                        y: y,
                        handleIn: null,
                        handleOut: null,
                        type: 'corner'
                    });
                    isDraggingPathTextHandle = true;
                    selectedPathTextAnchorIndex = currentPathTextPath.anchors.length - 1;
                    render();
                }
            } else if (currentTool === 'text') {
                // まず既存のテキストオブジェクトをクリックしたか確認
                let clickedExistingText = false;
                for (let i = textObjects.length - 1; i >= 0; i--) {
                    const obj = textObjects[i];
                    const metrics = measureText(obj);

                    if (x >= obj.x - 10 && x <= obj.x + metrics.width + 10 &&
                        y >= obj.y - 10 && y <= obj.y + metrics.height + 10) {
                        // 既存のテキストをクリックした
                        selectedObject = obj;
                        updatePropertiesPanel();
                        startTyping();
                        clickedExistingText = true;
                        break;
                    }
                }

                // 既存のテキストをクリックしていない場合のみ新しいテキストを作成
                if (!clickedExistingText) {
                    // 新しいテキストオブジェクトを作成
                    const newText = {
                        text: '',
                        x: x,
                        y: y,
                        fontSize: 100,
                        fontFamily: 'Yu Gothic UI',
                        scaleX: 100,
                        kerning: 0,
                        tracking: 0,
                        rotation: 0,
                        vertical: false,
                        leading: 0,
                        slant: 0,
                        underline: false,
                        smallCaps: false,
                        smallCapsSize: 75,
                        fill: {
                            enabled: true,
                            type: 'solid',
                            color: '#fdff00',
                            opacity: 100
                        },
                        strokes: [
                            { enabled: false, size: 8, color: '#000000', opacity: 100 },
                            { enabled: false, size: 50, color: '#ffffff', opacity: 100 },
                            { enabled: false, size: 68, color: '#000000', opacity: 100 },
                            { enabled: false, size: 78, color: '#000000', opacity: 100 }
                        ],
                        shadow: {
                            enabled: false,
                            color: '#000000',
                            opacity: 50,
                            distance: 10,
                            angle: 135,
                            size: 90,
                            blur: 0
                        }
                    };

                    textObjects.push(newText);
                    selectedObject = newText;
                    updatePropertiesPanel();
                    startTyping();
                }
            } else if (currentTool === 'textV') {
                // まず既存のテキストオブジェクトをクリックしたか確認
                let clickedExistingText = false;
                for (let i = textObjects.length - 1; i >= 0; i--) {
                    const obj = textObjects[i];
                    const metrics = measureText(obj);

                    if (x >= obj.x - 10 && x <= obj.x + metrics.width + 10 &&
                        y >= obj.y - 10 && y <= obj.y + metrics.height + 10) {
                        // 既存のテキストをクリックした
                        selectedObject = obj;
                        updatePropertiesPanel();
                        startTyping();
                        clickedExistingText = true;
                        break;
                    }
                }

                // 既存のテキストをクリックしていない場合のみ新しいテキストを作成
                if (!clickedExistingText) {
                    // 新しい縦書きテキストオブジェクトを作成
                    const newText = {
                        text: '',
                        x: x,
                        y: y,
                        fontSize: 100,
                        fontFamily: 'Yu Gothic UI',
                        scaleX: 100,
                        kerning: 0,
                        tracking: 0,
                        rotation: 0,
                        vertical: true,
                        leading: 0,
                        slant: 0,
                        underline: false,
                        smallCaps: false,
                        smallCapsSize: 75,
                        fill: {
                            enabled: true,
                            type: 'solid',
                            color: '#fdff00',
                            opacity: 100
                        },
                        strokes: [
                            { enabled: false, size: 8, color: '#000000', opacity: 100 },
                            { enabled: false, size: 50, color: '#ffffff', opacity: 100 },
                            { enabled: false, size: 68, color: '#000000', opacity: 100 },
                            { enabled: false, size: 78, color: '#000000', opacity: 100 }
                        ],
                        shadow: {
                            enabled: false,
                            color: '#000000',
                            opacity: 50,
                            distance: 10,
                            angle: 135,
                            size: 90,
                            blur: 0
                        }
                    };

                    textObjects.push(newText);
                    selectedObject = newText;
                    updatePropertiesPanel();
                    startTyping();
                }
            } else if (currentTool === 'pen') {
                // ペンツール: ベジエパスの作成
                if (!isDrawingPath) {
                    // 新しいパスの開始
                    isDrawingPath = true;
                    currentPath = {
                        type: 'pen',
                        anchors: [{
                            x: x,
                            y: y,
                            handleIn: null,
                            handleOut: null,
                            type: 'corner'
                        }],
                        closed: false,
                        fill: {
                            enabled: false,
                            type: 'solid',
                            color: '#ffffff',
                            opacity: 100
                        },
                        // 複数ストローク設定
                        strokes: [
                            {
                                enabled: true,
                                type: 'edge',  // 'edge', 'depth', 'drop'
                                color: '#000000',
                                size: 3,
                                opacity: 100,
                                angle: 0,  // depth/dropで使用（度数）
                                join: 'round'  // 'round', 'miter', 'bevel'
                            }
                        ],
                        // 後方互換性のための単一ストローク設定
                        stroke: {
                            enabled: true,
                            size: 3,
                            color: '#000000',
                            opacity: 100
                        }
                    };
                    isDraggingHandle = true;
                    selectedAnchorIndex = 0;
                    draggedHandleType = 'out';
                } else {
                    // 既存のパスに新しいアンカーポイントを追加
                    const firstAnchor = currentPath.anchors[0];
                    const dist = Math.sqrt((x - firstAnchor.x) ** 2 + (y - firstAnchor.y) ** 2);

                    if (dist < 10) {
                        // 最初のポイントに近い場合、パスを閉じる
                        currentPath.closed = true;
                        shapeObjects.push(currentPath);
                        isDrawingPath = false;
                        currentPath = null;
                        selectedAnchorIndex = -1;
                        setTool('select');  // ペン完成後、選択ツールに切り替え
                        render();
                    } else {
                        // 新しいアンカーポイントを追加
                        currentPath.anchors.push({
                            x: x,
                            y: y,
                            handleIn: null,
                            handleOut: null,
                            type: 'corner'
                        });
                        isDraggingHandle = true;
                        selectedAnchorIndex = currentPath.anchors.length - 1;
                        draggedHandleType = 'out';
                    }
                }
            } else if (currentTool === 'deleteAnchor') {
                // アンカーポイントの削除ツール
                // パス上文字オブジェクトのアンカーポイントを探す
                for (let i = pathTextObjects.length - 1; i >= 0; i--) {
                    const obj = pathTextObjects[i];
                    // pathプロパティがアンカー配列の場合
                    if (obj.path && obj.path.length > 0 && obj.path[0].handleIn !== undefined) {
                        for (let j = 0; j < obj.path.length; j++) {
                            const anchor = obj.path[j];
                            const dist = Math.sqrt((x - anchor.x) ** 2 + (y - anchor.y) ** 2);
                            if (dist < 10) {
                                // アンカーポイントが2つ以下の場合は削除しない
                                if (obj.path.length > 2) {
                                    obj.path.splice(j, 1);
                                    render();
                                } else {
                                    alert('パスには最低2つのアンカーポイントが必要です。');
                                }
                                return;
                            }
                        }
                    }
                }

                // ペンツールで作成されたパスのアンカーポイントを探す
                for (let i = shapeObjects.length - 1; i >= 0; i--) {
                    const obj = shapeObjects[i];
                    if (obj.type === 'pen' && obj.anchors) {
                        for (let j = 0; j < obj.anchors.length; j++) {
                            const anchor = obj.anchors[j];
                            const dist = Math.sqrt((x - anchor.x) ** 2 + (y - anchor.y) ** 2);
                            if (dist < 10) {
                                // アンカーポイントが2つ以下の場合は削除しない
                                if (obj.anchors.length > 2) {
                                    obj.anchors.splice(j, 1);
                                    render();
                                } else {
                                    alert('パスには最低2つのアンカーポイントが必要です。');
                                }
                                return;
                            }
                        }
                    }
                }
            } else if (currentTool === 'addAnchor') {
                // アンカーポイントの追加ツール
                // パス上文字オブジェクトのパスの線分を探す
                for (let i = pathTextObjects.length - 1; i >= 0; i--) {
                    const obj = pathTextObjects[i];
                    // pathプロパティがアンカー配列の場合
                    if (obj.path && obj.path.length >= 2 && obj.path[0].handleIn !== undefined) {
                        // 各線分をチェック
                        for (let j = 0; j < obj.path.length - 1; j++) {
                            const p1 = obj.path[j];
                            const p2 = obj.path[j + 1];
                            const dist = distanceToLineSegment(x, y, p1.x, p1.y, p2.x, p2.y);
                            if (dist < 10) {
                                // 線分上の位置を計算（簡易的に中点を使用）
                                const t = 0.5;
                                const newX = p1.x + (p2.x - p1.x) * t;
                                const newY = p1.y + (p2.y - p1.y) * t;

                                // 新しいアンカーポイントを挿入
                                obj.path.splice(j + 1, 0, {
                                    x: newX,
                                    y: newY,
                                    handleIn: null,
                                    handleOut: null,
                                    type: 'corner'
                                });
                                render();
                                return;
                            }
                        }
                    }
                }

                // ペンツールで作成されたパスの線分を探す
                for (let i = shapeObjects.length - 1; i >= 0; i--) {
                    const obj = shapeObjects[i];
                    if (obj.type === 'pen' && obj.anchors && obj.anchors.length >= 2) {
                        // 各線分をチェック
                        for (let j = 0; j < obj.anchors.length - 1; j++) {
                            const p1 = obj.anchors[j];
                            const p2 = obj.anchors[j + 1];
                            const dist = distanceToLineSegment(x, y, p1.x, p1.y, p2.x, p2.y);
                            if (dist < 10) {
                                // 線分上の位置を計算（簡易的に中点を使用）
                                const t = 0.5; // より正確には、最も近い点のパラメータを計算すべき
                                const newX = p1.x + (p2.x - p1.x) * t;
                                const newY = p1.y + (p2.y - p1.y) * t;

                                // 新しいアンカーポイントを挿入
                                obj.anchors.splice(j + 1, 0, {
                                    x: newX,
                                    y: newY,
                                    handleIn: null,
                                    handleOut: null,
                                    type: 'corner'
                                });
                                render();
                                return;
                            }
                        }
                    }
                }
            } else if (currentTool === 'convertAnchor') {
                // アンカーポイントの切り替えツール（スムーズ⇔コーナー）
                for (let i = shapeObjects.length - 1; i >= 0; i--) {
                    const obj = shapeObjects[i];
                    if (obj.type === 'pen' && obj.anchors) {
                        for (let j = 0; j < obj.anchors.length; j++) {
                            const anchor = obj.anchors[j];
                            const dist = Math.sqrt((x - anchor.x) ** 2 + (y - anchor.y) ** 2);
                            if (dist < 10) {
                                if (anchor.type === 'corner') {
                                    // コーナー → スムーズ
                                    anchor.type = 'smooth';
                                    // デフォルトのハンドルを作成
                                    if (!anchor.handleOut) {
                                        anchor.handleOut = { x: 50, y: 0 };
                                    }
                                    if (!anchor.handleIn) {
                                        anchor.handleIn = { x: -50, y: 0 };
                                    }
                                } else {
                                    // スムーズ → コーナー
                                    anchor.type = 'corner';
                                    // ハンドルを削除
                                    anchor.handleIn = null;
                                    anchor.handleOut = null;
                                }
                                render();
                                return;
                            }
                        }
                    }
                }
            } else if (currentTool === 'rectangle' || currentTool === 'roundRect' || currentTool === 'ellipse' || currentTool === 'line' || currentTool === 'chamferRect' || currentTool === 'triangle' || currentTool === 'arc') {
                // 図形作成開始
                isCreatingShape = true;
                currentShape = {
                    type: currentTool,
                    x: x,
                    y: y,
                    width: 0,
                    height: 0,
                    radius: 20, // 角丸矩形・斜角長方形用
                    startAngle: 0, // 円弧用
                    endAngle: 90, // 円弧用
                    rotation: 0,
                    fill: {
                        enabled: true,
                        type: 'solid',
                        color: '#ffffff',
                        opacity: 100
                    },
                    strokes: [
                        { enabled: true, size: 3, color: '#000000', opacity: 100 }
                    ]
                };
            } else if (currentTool === 'select') {
                // 以前選択されていたオブジェクトを記憶
                const previouslySelected = selectedObject;
                const wasTyping = isTyping;

                // テキスト入力中の場合は一時的に終了
                if (isTyping) {
                    isTyping = false;
                    const imeInput = document.getElementById('imeInput');
                    imeInput.classList.remove('active');
                    imeInput.blur();

                    // 空のテキストオブジェクトを削除
                    if (selectedObject && selectedObject.text === '') {
                        const index = textObjects.indexOf(selectedObject);
                        if (index > -1) {
                            textObjects.splice(index, 1);
                        }
                        selectedObject = null;
                    }
                }

                // ハンドルクリックチェック
                const handle = getHandleAt(x, y);
                if (handle && selectedObject) {
                    isDragging = true;
                    dragTarget = handle;
                    dragStartObjX = selectedObject.x;
                    dragStartObjY = selectedObject.y;

                    // 図形オブジェクトの場合
                    if (selectedObject.type && selectedObject.type !== 'pen') {
                        dragStartWidth = selectedObject.width;
                        dragStartHeight = selectedObject.height;
                    } else {
                        // テキストオブジェクトの場合
                        const metrics = measureText(selectedObject);
                        dragStartWidth = metrics.width;
                        dragStartHeight = metrics.height;
                    }
                } else if (selectObjectAt(x, y)) {
                    // オブジェクト選択成功 - ドラッグ開始
                    isDragging = true;
                    dragTarget = 'object';
                    dragStartObjX = selectedObject.x;
                    dragStartObjY = selectedObject.y;
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (canvas.width / rect.width);
            const y = (e.clientY - rect.top) * (canvas.height / rect.height);

            if (isDraggingPathTextHandle && currentPathTextPath && selectedPathTextAnchorIndex >= 0) {
                // パス上文字ツール: ベジエハンドルをドラッグ中
                const anchor = currentPathTextPath.anchors[selectedPathTextAnchorIndex];
                anchor.handleOut = { x: x - anchor.x, y: y - anchor.y };
                anchor.type = 'smooth';
                // スムーズポイントの場合、反対側のハンドルも調整
                if (anchor.handleIn) {
                    const length = Math.sqrt(anchor.handleIn.x ** 2 + anchor.handleIn.y ** 2);
                    const outLength = Math.sqrt(anchor.handleOut.x ** 2 + anchor.handleOut.y ** 2);
                    if (outLength > 0) {
                        anchor.handleIn = {
                            x: -(anchor.handleOut.x / outLength) * length,
                            y: -(anchor.handleOut.y / outLength) * length
                        };
                    }
                }
                scheduleRender();
            } else if (isDraggingHandle && currentPath && selectedAnchorIndex >= 0) {
                // ペンツール: ベジエハンドルをドラッグ中
                const anchor = currentPath.anchors[selectedAnchorIndex];
                if (draggedHandleType === 'out') {
                    anchor.handleOut = { x: x - anchor.x, y: y - anchor.y };
                    anchor.type = 'smooth';
                    // スムーズポイントの場合、反対側のハンドルも調整
                    if (anchor.handleIn) {
                        const length = Math.sqrt(anchor.handleIn.x ** 2 + anchor.handleIn.y ** 2);
                        const outLength = Math.sqrt(anchor.handleOut.x ** 2 + anchor.handleOut.y ** 2);
                        if (outLength > 0) {
                            anchor.handleIn = {
                                x: -(anchor.handleOut.x / outLength) * length,
                                y: -(anchor.handleOut.y / outLength) * length
                            };
                        }
                    }
                } else if (draggedHandleType === 'in') {
                    anchor.handleIn = { x: x - anchor.x, y: y - anchor.y };
                    anchor.type = 'smooth';
                    // スムーズポイントの場合、反対側のハンドルも調整
                    if (anchor.handleOut) {
                        const length = Math.sqrt(anchor.handleOut.x ** 2 + anchor.handleOut.y ** 2);
                        const inLength = Math.sqrt(anchor.handleIn.x ** 2 + anchor.handleIn.y ** 2);
                        if (inLength > 0) {
                            anchor.handleOut = {
                                x: -(anchor.handleIn.x / inLength) * length,
                                y: -(anchor.handleIn.y / inLength) * length
                            };
                        }
                    }
                }
                scheduleRender();
            } else if (isCreatingShape && currentShape) {
                // 図形のサイズを更新
                currentShape.width = x - currentShape.x;
                currentShape.height = y - currentShape.y;
                scheduleRender();
            } else if (isDragging && selectedObject) {
                const dx = x - dragStartX;
                const dy = y - dragStartY;

                if (dragTarget === 'object') {
                    // オブジェクトを移動
                    selectedObject.x = dragStartObjX + dx;
                    selectedObject.y = dragStartObjY + dy;
                    updatePropertiesPanel();
                    scheduleRender();
                } else if (dragTarget && dragTarget.startsWith('handle-')) {
                    const handleType = dragTarget.replace('handle-', '');
                    if (handleType === 'rotate') {
                        // 回転処理
                        rotateObject(x, y);
                    } else {
                        // リサイズ処理
                        resizeObject(handleType, dx, dy);
                    }
                }
            } else {
                // カーソル形状を更新
                if (currentTool === 'select' && selectedObject) {
                    const handle = getHandleAt(x, y);
                    if (handle) {
                        const handleType = handle.replace('handle-', '');
                        if (handleType === 'rotate') {
                            canvas.style.cursor = 'grab';
                        } else if (handleType === 'nw' || handleType === 'se') {
                            canvas.style.cursor = 'nwse-resize';
                        } else if (handleType === 'ne' || handleType === 'sw') {
                            canvas.style.cursor = 'nesw-resize';
                        }
                    } else {
                        // オブジェクト上かチェック
                        const metrics = measureText(selectedObject);
                        if (x >= selectedObject.x - 10 && x <= selectedObject.x + metrics.width + 10 &&
                            y >= selectedObject.y - metrics.height && y <= selectedObject.y + 10) {
                            canvas.style.cursor = 'move';
                        } else {
                            canvas.style.cursor = 'default';
                        }
                    }
                }
            }
        });

        canvas.addEventListener('mouseup', () => {
            if (isDraggingPathTextHandle) {
                // パス上文字ツール: ハンドルのドラッグ終了
                isDraggingPathTextHandle = false;
                render();
            } else if (isDraggingHandle) {
                // ペンツール: ハンドルのドラッグ終了
                isDraggingHandle = false;
                draggedHandleType = null;
                render();
            } else if (isCreatingShape && currentShape) {
                // 図形を確定
                if (Math.abs(currentShape.width) > 5 || Math.abs(currentShape.height) > 5) {
                    // widthやheightが負の値の場合、x、yを調整して正規化
                    if (currentShape.width < 0) {
                        currentShape.x += currentShape.width;
                        currentShape.width = -currentShape.width;
                    }
                    if (currentShape.height < 0) {
                        currentShape.y += currentShape.height;
                        currentShape.height = -currentShape.height;
                    }
                    shapeObjects.push(currentShape);
                }
                isCreatingShape = false;
                currentShape = null;
                render();
            }

            isDragging = false;
            dragTarget = null;
        });

        canvas.addEventListener('dblclick', (e) => {
            if (currentTool === 'pathText' && isDrawingPathTextPath && currentPathTextPath && currentPathTextPath.anchors.length >= 2) {
                // パス上文字ツール: ダブルクリックでパスを確定してテキスト入力モードへ
                const newPathText = {
                    text: '',
                    path: currentPathTextPath.anchors,
                    fontSize: 100,
                    fontFamily: 'Yu Gothic UI',
                    scaleX: 100,
                    kerning: 0,
                    tracking: 0,
                    baselineShift: 0,
                    rotation: 0,
                    leading: 0,
                    slant: 0,
                    underline: false,
                    smallCaps: false,
                    smallCapsSize: 75,
                    fill: {
                        enabled: true,
                        type: 'solid',
                        color: '#fdff00',
                        opacity: 100
                    },
                    strokes: [
                        { enabled: false, size: 8, color: '#000000', opacity: 100 },
                        { enabled: false, size: 50, color: '#ffffff', opacity: 100 },
                        { enabled: false, size: 68, color: '#000000', opacity: 100 },
                        { enabled: false, size: 78, color: '#000000', opacity: 100 }
                    ],
                    shadow: {
                        enabled: false,
                        color: '#000000',
                        opacity: 50,
                        distance: 10,
                        angle: 135,
                        size: 90,
                        blur: 0
                    }
                };

                pathTextObjects.push(newPathText);
                selectedObject = newPathText;
                isDrawingPathTextPath = false;
                currentPathTextPath = null;
                isDraggingPathTextHandle = false;
                selectedPathTextAnchorIndex = -1;
                updatePropertiesPanel();
                startTyping();
                render();
            } else if (currentTool === 'select' && selectedObject) {
                // ダブルクリックでテキスト編集モード
                startTyping();
            }
        });

        function getHandleAt(x, y) {
            if (!selectedObject) return null;

            const handleSize = 6;

            // 図形オブジェクトの場合
            if (selectedObject.type) {
                const minX = Math.min(selectedObject.x, selectedObject.x + selectedObject.width);
                const minY = Math.min(selectedObject.y, selectedObject.y + selectedObject.height);
                const maxX = Math.max(selectedObject.x, selectedObject.x + selectedObject.width);
                const maxY = Math.max(selectedObject.y, selectedObject.y + selectedObject.height);

                const handles = {
                    'handle-rotate': [minX + (maxX - minX) / 2, minY - 22],
                    'handle-nw': [minX - 2, minY - 2],
                    'handle-ne': [maxX + 2, minY - 2],
                    'handle-sw': [minX - 2, maxY + 2],
                    'handle-se': [maxX + 2, maxY + 2]
                };

                for (const [name, [hx, hy]] of Object.entries(handles)) {
                    if (Math.abs(x - hx) <= handleSize && Math.abs(y - hy) <= handleSize) {
                        return name;
                    }
                }
            } else {
                // テキストオブジェクトの場合
                const metrics = measureText(selectedObject);
                const handles = {
                    'handle-rotate': [selectedObject.x + metrics.width / 2, selectedObject.y - 22],
                    'handle-nw': [selectedObject.x - 2, selectedObject.y - 2],
                    'handle-ne': [selectedObject.x + metrics.width + 2, selectedObject.y - 2],
                    'handle-sw': [selectedObject.x - 2, selectedObject.y + metrics.height + 2],
                    'handle-se': [selectedObject.x + metrics.width + 2, selectedObject.y + metrics.height + 2]
                };

                for (const [name, [hx, hy]] of Object.entries(handles)) {
                    if (Math.abs(x - hx) <= handleSize && Math.abs(y - hy) <= handleSize) {
                        return name;
                    }
                }
            }

            return null;
        }

        function resizeObject(handleType, dx, dy) {
            if (!selectedObject) return;

            // 図形オブジェクトの場合
            if (selectedObject.type && selectedObject.type !== 'pen') {
                // 図形のリサイズ処理
                if (handleType === 'se') {
                    // 右下: widthとheightを変更
                    selectedObject.width = dragStartWidth + dx;
                    selectedObject.height = dragStartHeight + dy;
                } else if (handleType === 'ne') {
                    // 右上: widthを増やし、heightを減らし、yを調整
                    selectedObject.width = dragStartWidth + dx;
                    selectedObject.height = dragStartHeight - dy;
                    selectedObject.y = dragStartObjY + dy;
                } else if (handleType === 'sw') {
                    // 左下: widthを減らし、xを調整、heightを増やす
                    selectedObject.width = dragStartWidth - dx;
                    selectedObject.x = dragStartObjX + dx;
                    selectedObject.height = dragStartHeight + dy;
                } else if (handleType === 'nw') {
                    // 左上: widthとheightを減らし、xとyを調整
                    selectedObject.width = dragStartWidth - dx;
                    selectedObject.x = dragStartObjX + dx;
                    selectedObject.height = dragStartHeight - dy;
                    selectedObject.y = dragStartObjY + dy;
                }
            } else {
                // テキストオブジェクトの場合
                const newFontSize = selectedObject.fontSize;

                // フォントサイズを変更してリサイズ
                if (handleType === 'se' || handleType === 'ne') {
                    // 右方向のリサイズ
                    const scaleFactor = (dragStartWidth + dx) / dragStartWidth;
                    selectedObject.fontSize = Math.max(10, Math.round(dragStartHeight * scaleFactor));
                } else if (handleType === 'sw' || handleType === 'nw') {
                    // 左方向のリサイズ
                    const scaleFactor = (dragStartWidth - dx) / dragStartWidth;
                    selectedObject.fontSize = Math.max(10, Math.round(dragStartHeight * scaleFactor));
                    // 位置も調整
                    const metrics = measureText(selectedObject);
                    selectedObject.x = dragStartObjX + (dragStartWidth - metrics.width);
                }
            }

            updatePropertiesPanel();
            render();
        }

        function rotateObject(x, y) {
            if (!selectedObject) return;

            // オブジェクトの中心点を計算
            let centerX, centerY;
            if (selectedObject.type) {
                // 図形オブジェクト
                const minX = Math.min(selectedObject.x, selectedObject.x + selectedObject.width);
                const minY = Math.min(selectedObject.y, selectedObject.y + selectedObject.height);
                const maxX = Math.max(selectedObject.x, selectedObject.x + selectedObject.width);
                const maxY = Math.max(selectedObject.y, selectedObject.y + selectedObject.height);
                centerX = minX + (maxX - minX) / 2;
                centerY = minY + (maxY - minY) / 2;
            } else {
                // テキストオブジェクト
                const metrics = measureText(selectedObject);
                centerX = selectedObject.x + metrics.width / 2;
                centerY = selectedObject.y + metrics.height / 2;
            }

            // マウス位置と中心点からの角度を計算
            const angle = Math.atan2(y - centerY, x - centerX) * 180 / Math.PI;
            // 角度を調整（上向きを0度とする）
            selectedObject.rotation = angle + 90;

            updatePropertiesPanel();
            render();
        }

        function selectObjectAt(x, y) {
            // テキストオブジェクトをチェック（後ろから）
            for (let i = textObjects.length - 1; i >= 0; i--) {
                const obj = textObjects[i];

                // テキストが空の場合はスキップ（編集中以外）
                if (obj.text.trim() === '' && obj !== selectedObject) {
                    continue;
                }

                const metrics = measureText(obj);

                if (x >= obj.x - 10 && x <= obj.x + metrics.width + 10 &&
                    y >= obj.y - 10 && y <= obj.y + metrics.height + 10) {
                    selectedObject = obj;
                    updatePropertiesPanel();
                    render();
                    return true;
                }
            }

            // パス上文字オブジェクトをチェック（後ろから）
            for (let i = pathTextObjects.length - 1; i >= 0; i--) {
                const obj = pathTextObjects[i];
                if (obj.path && obj.path.length > 0) {
                    // パスポイントの近くをクリックしたかチェック
                    for (let j = 0; j < obj.path.length; j++) {
                        const p = obj.path[j];
                        const dist = Math.sqrt((x - p.x) ** 2 + (y - p.y) ** 2);
                        if (dist < 20) {
                            selectedObject = obj;
                            updatePropertiesPanel();
                            render();
                            return true;
                        }
                    }
                }
            }

            // 図形オブジェクトをチェック（後ろから）
            for (let i = shapeObjects.length - 1; i >= 0; i--) {
                const obj = shapeObjects[i];
                if (isPointInShape(x, y, obj)) {
                    selectedObject = obj;
                    render();
                    return true;
                }
            }

            // 何も選択されなかった
            selectedObject = null;
            render();
            return false;
        }

        // 図形内の点かどうかを判定する関数
        function isPointInShape(x, y, obj) {
            // ペンツールで作成されたパスの判定
            if (obj.type === 'pen' && obj.anchors && obj.anchors.length > 0) {
                // アンカーポイントに近いかチェック
                for (let i = 0; i < obj.anchors.length; i++) {
                    const anchor = obj.anchors[i];
                    const dist = Math.sqrt((x - anchor.x) ** 2 + (y - anchor.y) ** 2);
                    if (dist < 15) {
                        return true;
                    }
                }

                // パスの線分に近いかチェック
                for (let i = 0; i < obj.anchors.length - 1; i++) {
                    const p1 = obj.anchors[i];
                    const p2 = obj.anchors[i + 1];
                    const dist = distanceToLineSegment(x, y, p1.x, p1.y, p2.x, p2.y);
                    if (dist < 15) {
                        return true;
                    }
                }

                // 閉じたパスの場合、最後と最初のポイントを結ぶ線分もチェック
                if (obj.closed && obj.anchors.length > 2) {
                    const p1 = obj.anchors[obj.anchors.length - 1];
                    const p2 = obj.anchors[0];
                    const dist = distanceToLineSegment(x, y, p1.x, p1.y, p2.x, p2.y);
                    if (dist < 15) {
                        return true;
                    }
                }

                return false;
            }

            // 線ツールの判定
            if (obj.type === 'line') {
                const startX = obj.x;
                const startY = obj.y;
                const endX = obj.x + obj.width;
                const endY = obj.y + obj.height;
                const dist = distanceToLineSegment(x, y, startX, startY, endX, endY);
                return dist < 15;
            }

            const minX = Math.min(obj.x, obj.x + obj.width);
            const minY = Math.min(obj.y, obj.y + obj.height);
            const maxX = Math.max(obj.x, obj.x + obj.width);
            const maxY = Math.max(obj.y, obj.y + obj.height);

            // まず矩形範囲外ならfalse
            if (x < minX - 10 || x > maxX + 10 || y < minY - 10 || y > maxY + 10) {
                return false;
            }

            // 図形タイプごとの詳細な判定
            if (obj.type === 'rectangle') {
                return true; // 矩形範囲内ならOK
            } else if (obj.type === 'roundRect') {
                // 角丸矩形は簡易的に矩形として扱う
                return true;
            } else if (obj.type === 'ellipse') {
                // 楕円の判定
                const centerX = obj.x + obj.width / 2;
                const centerY = obj.y + obj.height / 2;
                const radiusX = Math.abs(obj.width) / 2;
                const radiusY = Math.abs(obj.height) / 2;
                const dx = (x - centerX) / radiusX;
                const dy = (y - centerY) / radiusY;
                return (dx * dx + dy * dy) <= 1.1; // 10%のマージンを追加
            } else if (obj.type === 'polygon') {
                // 正多角形の判定
                const sides = obj.sides || 5;
                const centerX = obj.x + obj.width / 2;
                const centerY = obj.y + obj.height / 2;
                const radius = Math.min(Math.abs(obj.width), Math.abs(obj.height)) / 2;

                // Canvas APIのisPointInPathを使用
                ctx.beginPath();
                for (let i = 0; i < sides; i++) {
                    const angle = (Math.PI * 2 * i / sides) - Math.PI / 2;
                    const px = centerX + radius * Math.cos(angle);
                    const py = centerY + radius * Math.sin(angle);
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                return ctx.isPointInPath(x, y);
            } else if (obj.type === 'star') {
                // 星形の判定
                const points = (obj.sides || 5) * 2;
                const centerX = obj.x + obj.width / 2;
                const centerY = obj.y + obj.height / 2;
                const outerRadius = Math.min(Math.abs(obj.width), Math.abs(obj.height)) / 2;
                const innerRadius = outerRadius * 0.4;

                // Canvas APIのisPointInPathを使用
                ctx.beginPath();
                for (let i = 0; i < points; i++) {
                    const angle = (Math.PI * 2 * i / points) - Math.PI / 2;
                    const radius = i % 2 === 0 ? outerRadius : innerRadius;
                    const px = centerX + radius * Math.cos(angle);
                    const py = centerY + radius * Math.sin(angle);
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                return ctx.isPointInPath(x, y);
            }

            return true; // デフォルトは矩形判定
        }

        function startTyping() {
            if (!selectedObject) return;

            isTyping = true;
            isComposing = false; // 入力開始時にリセット
            cursorPosition = selectedObject.text.length;

            // IME入力をフォーカス（Canvas上で透明に）
            const imeInput = document.getElementById('imeInput');
            const rect = canvas.getBoundingClientRect();

            // Canvas上のテキストオブジェクトの位置にIME入力を配置
            let objX, objY;
            if (selectedObject.path && selectedObject.path.length > 0) {
                // パス上文字の場合、パスの最初のポイントを使用
                objX = selectedObject.path[0].x;
                objY = selectedObject.path[0].y;
            } else {
                // 通常のテキストの場合
                objX = selectedObject.x;
                objY = selectedObject.y;
            }

            imeInput.style.left = (rect.left + objX * (rect.width / canvas.width)) + 'px';
            imeInput.style.top = (rect.top + objY * (rect.height / canvas.height)) + 'px';

            imeInput.value = selectedObject.text;
            imeInput.classList.add('active');

            // 少し遅延させてフォーカス（他のイベントが完了してから）
            setTimeout(() => {
                if (isTyping) { // まだタイピング中の場合のみフォーカス
                    imeInput.focus();
                    imeInput.select();
                    console.log('✅ テキスト入力開始:', selectedObject.text);
                }
            }, 50); // 遅延を50msに増加
        }

        // IME入力処理
        document.getElementById('imeInput').addEventListener('input', (e) => {
            if (selectedObject && isTyping) {
                selectedObject.text = e.target.value;
                cursorPosition = e.target.selectionStart;
                selectionStart = e.target.selectionStart;
                selectionEnd = e.target.selectionEnd;
                render();
            }
        });

        // 選択範囲の変更を追跡
        document.getElementById('imeInput').addEventListener('select', (e) => {
            if (selectedObject && isTyping) {
                selectionStart = e.target.selectionStart;
                selectionEnd = e.target.selectionEnd;
                cursorPosition = e.target.selectionStart;
                render();
            }
        });

        document.getElementById('imeInput').addEventListener('click', (e) => {
            if (selectedObject && isTyping) {
                selectionStart = e.target.selectionStart;
                selectionEnd = e.target.selectionEnd;
                cursorPosition = e.target.selectionStart;
                render();
            }
        });

        // IME変換開始
        document.getElementById('imeInput').addEventListener('compositionstart', (e) => {
            isComposing = true;
            console.log('🎌 IME変換開始');
        });

        // IME変換終了
        document.getElementById('imeInput').addEventListener('compositionend', (e) => {
            isComposing = false;
            console.log('🎌 IME変換終了');
            if (selectedObject) {
                selectedObject.text = e.target.value;
                render();
            }
        });

        // IME入力のblurイベント
        document.getElementById('imeInput').addEventListener('blur', (e) => {
            console.log('🔵 IME入力フィールドがblur, isComposing:', isComposing);

            // IME変換中の場合はblurを無視
            if (isComposing) {
                console.log('⚠️ IME変換中のためblurを無視');
                // フォーカスを戻す
                setTimeout(() => {
                    if (isTyping) {
                        e.target.focus();
                    }
                }, 10);
                return;
            }

            if (isTyping) {
                isTyping = false;
                e.target.classList.remove('active');

                // 空のテキストオブジェクトを削除（レガシータイトルと同じ動作）
                if (selectedObject && selectedObject.text.trim() === '') {
                    const index = textObjects.indexOf(selectedObject);
                    if (index > -1) {
                        textObjects.splice(index, 1);
                        selectedObject = null;
                        console.log('🗑️ 空のテキストオブジェクトを削除');
                    }
                } else if (selectedObject) {
                    console.log('✅ テキスト入力完了:', selectedObject.text);
                }

                render();
            }
        });

        // キーボードイベント
        document.addEventListener('keydown', (e) => {
            if (isTyping && selectedObject) {
                if (e.key === 'Escape') {
                    isTyping = false;
                    const imeInput = document.getElementById('imeInput');
                    imeInput.blur();
                    imeInput.classList.remove('active');

                    // 空のテキストオブジェクトを削除
                    if (selectedObject.text.trim() === '') {
                        const index = textObjects.indexOf(selectedObject);
                        if (index > -1) {
                            textObjects.splice(index, 1);
                            selectedObject = null;
                            console.log('🗑️ 空のテキストオブジェクトを削除（Escape）');
                        }
                    }

                    render();
                }
            } else if (isDrawingPathTextPath && currentPathTextPath) {
                // パス上文字ツールでパス描画中
                if (e.key === 'Escape' || e.key === 'Enter' || e.key === 't' || e.key === 'T') {
                    // パスを確定してテキスト入力モードへ
                    if (currentPathTextPath.anchors.length >= 2) {
                        const newPathText = {
                            text: '',
                            path: currentPathTextPath.anchors,
                            fontSize: 100,
                            fontFamily: 'Yu Gothic UI',
                            scaleX: 100,
                            kerning: 0,
                            tracking: 0,
                            baselineShift: 0,
                            rotation: 0,
                            leading: 0,
                            slant: 0,
                            underline: false,
                            smallCaps: false,
                            smallCapsSize: 75,
                            fill: {
                                enabled: true,
                                type: 'solid',
                                color: '#fdff00',
                                opacity: 100
                            },
                            strokes: [
                                { enabled: false, size: 8, color: '#000000', opacity: 100 },
                                { enabled: false, size: 50, color: '#ffffff', opacity: 100 },
                                { enabled: false, size: 68, color: '#000000', opacity: 100 },
                                { enabled: false, size: 78, color: '#000000', opacity: 100 }
                            ],
                            shadow: {
                                enabled: false,
                                color: '#000000',
                                opacity: 50,
                                distance: 10,
                                angle: 135,
                                size: 90,
                                blur: 0
                            }
                        };

                        pathTextObjects.push(newPathText);
                        selectedObject = newPathText;
                        isDrawingPathTextPath = false;
                        currentPathTextPath = null;
                        isDraggingPathTextHandle = false;
                        selectedPathTextAnchorIndex = -1;
                        updatePropertiesPanel();
                        startTyping();
                        render();
                    } else {
                        // アンカーポイントが不足している場合はキャンセル
                        isDrawingPathTextPath = false;
                        currentPathTextPath = null;
                        isDraggingPathTextHandle = false;
                        selectedPathTextAnchorIndex = -1;
                        render();
                    }
                }
            } else if (isDrawingPath && currentPath) {
                // ペンツールでパス描画中
                if (e.key === 'Escape' || e.key === 'Enter') {
                    // パスを確定
                    if (currentPath.anchors.length >= 2) {
                        shapeObjects.push(currentPath);
                    }
                    isDrawingPath = false;
                    currentPath = null;
                    selectedAnchorIndex = -1;
                    isDraggingHandle = false;
                    draggedHandleType = null;
                    setTool('select');  // ペン完成後、選択ツールに切り替え
                    render();
                }
            } else if (selectedObject && !isTyping) {
                // 選択モードでのキーボードショートカット
                if (e.key === 'Delete' || e.key === 'Backspace') {
                    const index = textObjects.indexOf(selectedObject);
                    if (index > -1) {
                        textObjects.splice(index, 1);
                        selectedObject = null;
                        render();
                    }
                } else if (e.key === 'Enter') {
                    startTyping();
                }
            }
        });

        function updatePropertiesPanel() {
            if (!selectedObject) return;

            // 図形オブジェクトかどうかを判定
            const isShapeObject = selectedObject.type &&
                ['rectangle', 'roundRect', 'ellipse', 'polygon', 'star'].includes(selectedObject.type);

            document.getElementById('prop_x').value = selectedObject.x.toFixed(1);
            document.getElementById('prop_y').value = selectedObject.y.toFixed(1);

            // テキストオブジェクトのプロパティ
            if (!isShapeObject) {
                document.getElementById('prop_fontSize').value = selectedObject.fontSize;
                document.getElementById('prop_fontFamily').value = selectedObject.fontFamily;
                document.getElementById('prop_scaleX').value = selectedObject.scaleX;
                document.getElementById('scaleXValue').textContent = selectedObject.scaleX + '%';
                document.getElementById('prop_kerning').value = selectedObject.kerning;
                document.getElementById('prop_tracking').value = selectedObject.tracking;
                document.getElementById('prop_baselineShift').value = selectedObject.baselineShift || 0;
                document.getElementById('prop_rotation').value = selectedObject.rotation;
                document.getElementById('prop_vertical').checked = selectedObject.vertical || false;
                document.getElementById('prop_leading').value = selectedObject.leading || 0;
                document.getElementById('prop_slant').value = selectedObject.slant || 0;
                document.getElementById('prop_underline').checked = selectedObject.underline || false;
                document.getElementById('prop_smallCaps').checked = selectedObject.smallCaps || false;
                document.getElementById('prop_smallCapsSize').value = selectedObject.smallCapsSize || 75;
            }

            document.getElementById('fill_enabled').checked = selectedObject.fill.enabled;
            document.getElementById('fill_color').value = selectedObject.fill.color;
            document.getElementById('fill_opacity').value = selectedObject.fill.opacity;

            // 塗りタイプとグラデーション設定を更新
            if (selectedObject.fill.type) {
                document.getElementById('fill_type').value = selectedObject.fill.type;

                // UIの表示切り替え
                const fillType = selectedObject.fill.type;
                const solidControls = document.getElementById('solidFillControls');
                const gradientControls = document.getElementById('gradientFillControls');

                if (fillType === 'gradient-linear' || fillType === 'gradient-radial') {
                    solidControls.style.display = 'none';
                    gradientControls.style.display = 'block';

                    // グラデーション値を更新
                    if (selectedObject.fill.gradient) {
                        const g = selectedObject.fill.gradient;
                        document.getElementById('gradient_color1').value = g.color1 || '#fdff00';
                        document.getElementById('gradient_color2').value = g.color2 || '#ff6600';
                        document.getElementById('gradient_use_color3').checked = g.useColor3 || false;
                        document.getElementById('gradient_color3').value = g.color3 || '#ffaa00';
                        document.getElementById('gradient_color3_position').value = g.color3Position || 50;
                        document.getElementById('gradient_angle').value = g.angle || 0;
                        document.getElementById('gradient_opacity').value = g.opacity || 100;
                        document.getElementById('gradient_ratio_start').value = g.ratioStart || 0;
                        document.getElementById('gradient_ratio_end').value = g.ratioEnd || 100;
                        document.getElementById('gradient_blur').value = g.blur || 0;

                        // 中間色の表示制御
                        document.getElementById('gradient_color3_row').style.display = g.useColor3 ? 'flex' : 'none';
                        document.getElementById('gradient_color3_position_row').style.display = g.useColor3 ? 'flex' : 'none';
                    }

                    // 角度の表示制御
                    document.getElementById('gradient_angle_row').style.display =
                        fillType === 'gradient-linear' ? 'flex' : 'none';
                } else {
                    solidControls.style.display = 'block';
                    gradientControls.style.display = 'none';
                }
            }

            // ストロークとシャドウはテキストオブジェクトのみ
            if (!isShapeObject) {
                if (selectedObject.strokes && selectedObject.strokes.length >= 4) {
                    document.getElementById('stroke1_enabled').checked = selectedObject.strokes[0].enabled;
                    document.getElementById('stroke1_size').value = selectedObject.strokes[0].size;
                    document.getElementById('stroke1_color').value = selectedObject.strokes[0].color;
                    document.getElementById('stroke1_opacity').value = selectedObject.strokes[0].opacity || 100;

                    document.getElementById('stroke2_enabled').checked = selectedObject.strokes[1].enabled;
                    document.getElementById('stroke2_size').value = selectedObject.strokes[1].size;
                    document.getElementById('stroke2_color').value = selectedObject.strokes[1].color;
                    document.getElementById('stroke2_opacity').value = selectedObject.strokes[1].opacity || 100;

                    document.getElementById('stroke3_enabled').checked = selectedObject.strokes[2].enabled;
                    document.getElementById('stroke3_size').value = selectedObject.strokes[2].size;
                    document.getElementById('stroke3_color').value = selectedObject.strokes[2].color;
                    document.getElementById('stroke3_opacity').value = selectedObject.strokes[2].opacity || 100;

                    document.getElementById('stroke4_enabled').checked = selectedObject.strokes[3].enabled;
                    document.getElementById('stroke4_size').value = selectedObject.strokes[3].size;
                    document.getElementById('stroke4_color').value = selectedObject.strokes[3].color;
                    document.getElementById('stroke4_opacity').value = selectedObject.strokes[3].opacity || 100;
                }

                if (selectedObject.shadow) {
                    document.getElementById('shadow_enabled').checked = selectedObject.shadow.enabled;
                    document.getElementById('shadow_color').value = selectedObject.shadow.color;
                    document.getElementById('shadow_opacity').value = selectedObject.shadow.opacity;
                    document.getElementById('shadow_distance').value = selectedObject.shadow.distance;
                    document.getElementById('shadow_angle').value = selectedObject.shadow.angle;
                    document.getElementById('shadow_size').value = selectedObject.shadow.size || 90;
                    document.getElementById('shadow_blur').value = selectedObject.shadow.blur || 0;
                }
            } else {
                // 図形オブジェクトのストローク設定（単一のstrokeプロパティ）
                if (selectedObject.stroke) {
                    // 図形のストロークをstroke1に表示
                    document.getElementById('stroke1_enabled').checked = selectedObject.stroke.enabled;
                    document.getElementById('stroke1_size').value = selectedObject.stroke.size;
                    document.getElementById('stroke1_color').value = selectedObject.stroke.color;
                    document.getElementById('stroke1_opacity').value = selectedObject.stroke.opacity || 100;

                    // 他のストロークは無効化
                    document.getElementById('stroke2_enabled').checked = false;
                    document.getElementById('stroke3_enabled').checked = false;
                    document.getElementById('stroke4_enabled').checked = false;
                }
            }
        }

        function measureText(obj) {
            ctx.font = `${obj.fontSize}px "${obj.fontFamily}"`;

            if (obj.vertical) {
                // 縦書きの場合
                const charCount = (obj.text || '|').length;
                return {
                    width: obj.fontSize * (obj.scaleX / 100),
                    height: obj.fontSize * charCount
                };
            } else {
                // 横書きの場合
                const text = obj.text || '|';
                const metrics = ctx.measureText(text);
                let width = metrics.width;

                // カーニングを考慮した幅
                const kerning = obj.kerning || 0;
                if (kerning !== 0 && text.length > 1) {
                    width += kerning * (text.length - 1);
                }

                return {
                    width: width * (obj.scaleX / 100),
                    height: obj.fontSize
                };
            }
        }

        // requestAnimationFrameを使ったスムーズな描画
        function scheduleRender() {
            if (!renderScheduled) {
                renderScheduled = true;
                requestAnimationFrame(() => {
                    renderScheduled = false;
                    render();
                });
            }
        }

        function render() {
            // チェッカーボード背景を描画（レガシータイトルと同じ）
            drawCheckerboardBackground();

            // セーフマージン描画
            if (document.getElementById('safeMarginEnabled').checked) {
                drawSafeMargins();
            }

            // 全図形オブジェクトを描画
            shapeObjects.forEach(obj => {
                drawShapeObject(obj, obj === selectedObject);
            });

            // 図形作成中の場合
            if (isCreatingShape && currentShape) {
                drawShapeObject(currentShape, false);
            }

            // ペンツールで描画中の場合
            if (isDrawingPath && currentPath) {
                drawPathWithAnchors(currentPath, true);
            }

            // パス上文字ツールでパス描画中の場合
            if (isDrawingPathTextPath && currentPathTextPath) {
                drawPathTextPathWithAnchors(currentPathTextPath, true);
            }

            // 全テキストオブジェクトを描画
            textObjects.forEach(obj => {
                drawTextObject(obj, obj === selectedObject);
            });

            // 全パス上文字オブジェクトを描画
            pathTextObjects.forEach(obj => {
                drawPathTextObject(obj, obj === selectedObject);
            });

            // テキスト選択範囲の描画（入力中の場合）
            if (isTyping && selectedObject && selectionStart !== selectionEnd) {
                drawTextSelection();
            }

            // カーソル描画（入力中の場合）
            if (isTyping && selectedObject && cursorVisible) {
                drawCursor();
            }

            // オブジェクト数が変わった場合、または選択オブジェクトが変わった場合、レイヤーリストを更新
            const currentObjectCount = shapeObjects.length + textObjects.length + pathTextObjects.length;
            if (currentObjectCount !== lastObjectCount || selectedObject !== lastSelectedObject) {
                lastObjectCount = currentObjectCount;
                lastSelectedObject = selectedObject;
                updateLayersList();
            }
        }

        // ベジエパスを描画する関数
        function drawPathWithAnchors(pathObj, showAnchors) {
            if (!pathObj || !pathObj.anchors || pathObj.anchors.length === 0) return;

            ctx.save();

            // パスを描画する関数
            const drawPath = () => {
                ctx.beginPath();
                const firstAnchor = pathObj.anchors[0];
                ctx.moveTo(firstAnchor.x, firstAnchor.y);

                for (let i = 1; i < pathObj.anchors.length; i++) {
                    const prevAnchor = pathObj.anchors[i - 1];
                    const currAnchor = pathObj.anchors[i];

                    if (prevAnchor.handleOut && currAnchor.handleIn) {
                        // ベジエ曲線
                        const cp1x = prevAnchor.x + prevAnchor.handleOut.x;
                        const cp1y = prevAnchor.y + prevAnchor.handleOut.y;
                        const cp2x = currAnchor.x + currAnchor.handleIn.x;
                        const cp2y = currAnchor.y + currAnchor.handleIn.y;
                        ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, currAnchor.x, currAnchor.y);
                    } else if (prevAnchor.handleOut) {
                        // 2次ベジエ曲線
                        const cpx = prevAnchor.x + prevAnchor.handleOut.x;
                        const cpy = prevAnchor.y + prevAnchor.handleOut.y;
                        ctx.quadraticCurveTo(cpx, cpy, currAnchor.x, currAnchor.y);
                    } else {
                        // 直線
                        ctx.lineTo(currAnchor.x, currAnchor.y);
                    }
                }

                // パスを閉じる場合
                if (pathObj.closed && pathObj.anchors.length > 2) {
                    const lastAnchor = pathObj.anchors[pathObj.anchors.length - 1];
                    const firstAnchor = pathObj.anchors[0];

                    if (lastAnchor.handleOut && firstAnchor.handleIn) {
                        const cp1x = lastAnchor.x + lastAnchor.handleOut.x;
                        const cp1y = lastAnchor.y + lastAnchor.handleOut.y;
                        const cp2x = firstAnchor.x + firstAnchor.handleIn.x;
                        const cp2y = firstAnchor.y + firstAnchor.handleIn.y;
                        ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, firstAnchor.x, firstAnchor.y);
                    } else {
                        ctx.lineTo(firstAnchor.x, firstAnchor.y);
                    }
                    ctx.closePath();
                }
            };

            // 複数ストロークのレンダリング（外側から内側へ）
            if (pathObj.strokes && pathObj.strokes.length > 0) {
                // ストロークを幅でソート（大きい順）
                const sortedStrokes = [...pathObj.strokes].sort((a, b) => (b.size || 0) - (a.size || 0));

                sortedStrokes.forEach(stroke => {
                    if (!stroke.enabled) return;

                    ctx.save();
                    drawPath();

                    // ストロークタイプに応じて描画
                    if (stroke.type === 'depth' || stroke.type === 'drop') {
                        // 奥行き/ドロップシャドウ: オフセットして描画
                        const angle = (stroke.angle || 0) * Math.PI / 180;
                        const offset = stroke.size / 2;
                        ctx.translate(
                            Math.cos(angle) * offset,
                            Math.sin(angle) * offset
                        );
                        drawPath();
                    }

                    ctx.strokeStyle = hexToRgba(stroke.color, stroke.opacity / 100);
                    ctx.lineWidth = stroke.size;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = stroke.join || 'round';
                    ctx.stroke();
                    ctx.restore();
                });

                // 塗りつぶし（最後に描画）
                if (pathObj.fill && pathObj.fill.enabled) {
                    drawPath();
                    ctx.fillStyle = hexToRgba(pathObj.fill.color, pathObj.fill.opacity / 100);
                    ctx.fill();
                }
            } else {
                // 後方互換性: 単一ストローク
                drawPath();
                if (pathObj.fill && pathObj.fill.enabled) {
                    ctx.fillStyle = hexToRgba(pathObj.fill.color, pathObj.fill.opacity / 100);
                    ctx.fill();
                }
                if (pathObj.stroke && pathObj.stroke.enabled) {
                    ctx.strokeStyle = hexToRgba(pathObj.stroke.color, pathObj.stroke.opacity / 100);
                    ctx.lineWidth = pathObj.stroke.size;
                    ctx.stroke();
                }
            }

            // アンカーポイントとハンドルを表示
            if (showAnchors) {
                pathObj.anchors.forEach((anchor, index) => {
                    // アンカーポイント
                    ctx.fillStyle = index === selectedAnchorIndex ? '#ff0000' : '#ffffff';
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(anchor.x, anchor.y, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();

                    // ハンドルを描画
                    if (anchor.handleOut) {
                        const outX = anchor.x + anchor.handleOut.x;
                        const outY = anchor.y + anchor.handleOut.y;

                        // ハンドルライン
                        ctx.strokeStyle = '#0099ff';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(anchor.x, anchor.y);
                        ctx.lineTo(outX, outY);
                        ctx.stroke();

                        // ハンドルポイント
                        ctx.fillStyle = '#0099ff';
                        ctx.beginPath();
                        ctx.arc(outX, outY, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    if (anchor.handleIn) {
                        const inX = anchor.x + anchor.handleIn.x;
                        const inY = anchor.y + anchor.handleIn.y;

                        // ハンドルライン
                        ctx.strokeStyle = '#0099ff';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(anchor.x, anchor.y);
                        ctx.lineTo(inX, inY);
                        ctx.stroke();

                        // ハンドルポイント
                        ctx.fillStyle = '#0099ff';
                        ctx.beginPath();
                        ctx.arc(inX, inY, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
            }

            ctx.restore();
        }

        // パス上文字ツールのパス描画関数
        function drawPathTextPathWithAnchors(pathObj, showAnchors) {
            if (!pathObj || !pathObj.anchors || pathObj.anchors.length === 0) return;

            ctx.save();

            // パスを描画
            ctx.beginPath();
            const firstAnchor = pathObj.anchors[0];
            ctx.moveTo(firstAnchor.x, firstAnchor.y);

            for (let i = 1; i < pathObj.anchors.length; i++) {
                const prevAnchor = pathObj.anchors[i - 1];
                const currAnchor = pathObj.anchors[i];

                if (prevAnchor.handleOut && currAnchor.handleIn) {
                    // ベジエ曲線
                    const cp1x = prevAnchor.x + prevAnchor.handleOut.x;
                    const cp1y = prevAnchor.y + prevAnchor.handleOut.y;
                    const cp2x = currAnchor.x + currAnchor.handleIn.x;
                    const cp2y = currAnchor.y + currAnchor.handleIn.y;
                    ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, currAnchor.x, currAnchor.y);
                } else if (prevAnchor.handleOut) {
                    // 2次ベジエ曲線
                    const cpx = prevAnchor.x + prevAnchor.handleOut.x;
                    const cpy = prevAnchor.y + prevAnchor.handleOut.y;
                    ctx.quadraticCurveTo(cpx, cpy, currAnchor.x, currAnchor.y);
                } else {
                    // 直線
                    ctx.lineTo(currAnchor.x, currAnchor.y);
                }
            }

            // パスを描画（ストロークのみ）
            ctx.strokeStyle = '#0099ff';
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.stroke();

            // アンカーポイントとハンドルを表示
            if (showAnchors) {
                pathObj.anchors.forEach((anchor, index) => {
                    // アンカーポイント
                    ctx.fillStyle = index === selectedPathTextAnchorIndex ? '#ff0000' : '#ffffff';
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(anchor.x, anchor.y, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();

                    // ハンドルを描画
                    if (anchor.handleOut) {
                        const outX = anchor.x + anchor.handleOut.x;
                        const outY = anchor.y + anchor.handleOut.y;

                        // ハンドルライン
                        ctx.strokeStyle = '#0099ff';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(anchor.x, anchor.y);
                        ctx.lineTo(outX, outY);
                        ctx.stroke();

                        // ハンドルポイント
                        ctx.fillStyle = '#0099ff';
                        ctx.beginPath();
                        ctx.arc(outX, outY, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    if (anchor.handleIn) {
                        const inX = anchor.x + anchor.handleIn.x;
                        const inY = anchor.y + anchor.handleIn.y;

                        // ハンドルライン
                        ctx.strokeStyle = '#0099ff';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(anchor.x, anchor.y);
                        ctx.lineTo(inX, inY);
                        ctx.stroke();

                        // ハンドルポイント
                        ctx.fillStyle = '#0099ff';
                        ctx.beginPath();
                        ctx.arc(inX, inY, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
            }

            ctx.restore();
        }

        function drawShapeObject(obj, isSelected) {
            // 新しいペンツール（ベジエパス）の場合
            if (obj.type === 'pen' && obj.anchors) {
                drawPathWithAnchors(obj, isSelected);
                return;
            }

            ctx.save();

            const x = obj.x;
            const y = obj.y;
            const w = obj.width;
            const h = obj.height;

            // 回転を適用
            if (obj.rotation && obj.rotation !== 0) {
                const centerX = x + w / 2;
                const centerY = y + h / 2;
                ctx.translate(centerX, centerY);
                ctx.rotate(obj.rotation * Math.PI / 180);
                ctx.translate(-centerX, -centerY);
            }

            // 塗り
            if (obj.fill && obj.fill.enabled) {
                if (obj.fill.type === 'gradient-linear' && obj.fill.gradient) {
                    // 線形グラデーション
                    const grad = obj.fill.gradient;
                    const angle = (grad.angle || 0) * Math.PI / 180;
                    const centerX = x + w / 2;
                    const centerY = y + h / 2;
                    const length = Math.sqrt(w * w + h * h) / 2;
                    const x0 = centerX - length * Math.cos(angle);
                    const y0 = centerY - length * Math.sin(angle);
                    const x1 = centerX + length * Math.cos(angle);
                    const y1 = centerY + length * Math.sin(angle);

                    const gradient = ctx.createLinearGradient(x0, y0, x1, y1);
                    const opacity = (grad.opacity || 100) / 100;
                    const ratioStart = (grad.ratioStart || 0) / 100;
                    const ratioEnd = (grad.ratioEnd || 100) / 100;

                    // ratioStartとratioEndを考慮したカラーストップ
                    gradient.addColorStop(ratioStart, hexToRgba(grad.color1, opacity));
                    if (grad.useColor3 && grad.color3) {
                        const pos = ratioStart + (ratioEnd - ratioStart) * (grad.color3Position || 50) / 100;
                        gradient.addColorStop(pos, hexToRgba(grad.color3, opacity));
                    }
                    gradient.addColorStop(ratioEnd, hexToRgba(grad.color2, opacity));

                    // ぼかし効果を適用
                    if (grad.blur && grad.blur > 0) {
                        ctx.filter = `blur(${grad.blur}px)`;
                    }

                    ctx.fillStyle = gradient;
                } else if (obj.fill.type === 'gradient-radial' && obj.fill.gradient) {
                    // 円形グラデーション
                    const grad = obj.fill.gradient;
                    const centerX = x + w / 2;
                    const centerY = y + h / 2;
                    const radius = Math.max(Math.abs(w), Math.abs(h)) / 2;
                    const ratioStart = (grad.ratioStart || 0) / 100;
                    const ratioEnd = (grad.ratioEnd || 100) / 100;

                    const gradient = ctx.createRadialGradient(
                        centerX, centerY, radius * ratioStart,
                        centerX, centerY, radius * ratioEnd
                    );
                    const opacity = (grad.opacity || 100) / 100;

                    gradient.addColorStop(0, hexToRgba(grad.color1, opacity));
                    if (grad.useColor3 && grad.color3) {
                        const pos = (grad.color3Position || 50) / 100;
                        gradient.addColorStop(pos, hexToRgba(grad.color3, opacity));
                    }
                    gradient.addColorStop(1, hexToRgba(grad.color2, opacity));

                    // ぼかし効果を適用
                    if (grad.blur && grad.blur > 0) {
                        ctx.filter = `blur(${grad.blur}px)`;
                    }

                    ctx.fillStyle = gradient;
                } else {
                    // ベタ塗り
                    const opacity = obj.fill.opacity / 100;
                    if (opacity < 1) {
                        const rgb = hexToRgb(obj.fill.color);
                        ctx.fillStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`;
                    } else {
                        ctx.fillStyle = obj.fill.color;
                    }
                }
            }

            // パス描画用のヘルパー関数
            const drawShapePath = () => {
                if (obj.type === 'rectangle') {
                    ctx.beginPath();
                    ctx.rect(x, y, w, h);
                } else if (obj.type === 'roundRect') {
                    const radius = Math.min(obj.radius || 20, Math.abs(w) / 2, Math.abs(h) / 2);
                    ctx.beginPath();
                    ctx.roundRect(x, y, w, h, radius);
                } else if (obj.type === 'ellipse') {
                    ctx.beginPath();
                    ctx.ellipse(x + w/2, y + h/2, Math.abs(w/2), Math.abs(h/2), 0, 0, 2 * Math.PI);
                } else if (obj.type === 'line') {
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + w, y + h);
                } else if (obj.type === 'pen') {
                    if (obj.points && obj.points.length > 1) {
                        ctx.beginPath();
                        ctx.moveTo(obj.points[0].x, obj.points[0].y);
                        for (let i = 1; i < obj.points.length; i++) {
                            ctx.lineTo(obj.points[i].x, obj.points[i].y);
                        }
                    }
                } else if (obj.type === 'chamferRect') {
                    const chamfer = Math.min(obj.radius || 20, Math.abs(w) / 2, Math.abs(h) / 2);
                    ctx.beginPath();
                    const x1 = x, y1 = y;
                    const x2 = x + w, y2 = y + h;
                    ctx.moveTo(x1 + chamfer, y1);
                    ctx.lineTo(x2 - chamfer, y1);
                    ctx.lineTo(x2, y1 + chamfer);
                    ctx.lineTo(x2, y2 - chamfer);
                    ctx.lineTo(x2 - chamfer, y2);
                    ctx.lineTo(x1 + chamfer, y2);
                    ctx.lineTo(x1, y2 - chamfer);
                    ctx.lineTo(x1, y1 + chamfer);
                    ctx.closePath();
                } else if (obj.type === 'triangle') {
                    ctx.beginPath();
                    ctx.moveTo(x + w / 2, y);
                    ctx.lineTo(x + w, y + h);
                    ctx.lineTo(x, y + h);
                    ctx.closePath();
                }
            };

            // 塗りつぶし
            if (obj.fill && obj.fill.enabled) {
                drawShapePath();
                if (obj.type === 'rectangle') {
                    ctx.fillRect(x, y, w, h);
                } else {
                    ctx.fill();
                }
            }

            // 複数ストローク対応（外側から内側へ）
            if (obj.strokes && Array.isArray(obj.strokes)) {
                const enabledStrokes = obj.strokes.filter(s => s.enabled && s.size > 0);
                // 大きいサイズから小さいサイズへ描画（逆順）
                for (let i = enabledStrokes.length - 1; i >= 0; i--) {
                    const stroke = enabledStrokes[i];
                    const strokeOpacity = (stroke.opacity || 100) / 100;
                    if (strokeOpacity < 1) {
                        const rgb = hexToRgb(stroke.color);
                        ctx.strokeStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${strokeOpacity})`;
                    } else {
                        ctx.strokeStyle = stroke.color;
                    }
                    ctx.lineWidth = stroke.size;
                    ctx.lineJoin = 'round';
                    ctx.lineCap = 'round';
                    drawShapePath();
                    ctx.stroke();
                }
            } else if (obj.stroke && obj.stroke.enabled) {
                // 単一ストローク（後方互換性のため）
                const strokeOpacity = (obj.stroke.opacity || 100) / 100;
                if (strokeOpacity < 1) {
                    const rgb = hexToRgb(obj.stroke.color);
                    ctx.strokeStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${strokeOpacity})`;
                } else {
                    ctx.strokeStyle = obj.stroke.color;
                }
                ctx.lineWidth = obj.stroke.size;
                drawShapePath();
                ctx.stroke();
            }

            // 円弧は特殊処理
            if (obj.type === 'arc') {
                // 円弧
                const centerX = x + w / 2;
                const centerY = y + h / 2;
                const radiusX = Math.abs(w / 2);
                const radiusY = Math.abs(h / 2);
                const startAngle = (obj.startAngle || 0) * Math.PI / 180;
                const endAngle = (obj.endAngle || 90) * Math.PI / 180;
                ctx.beginPath();
                ctx.ellipse(centerX, centerY, radiusX, radiusY, 0, startAngle, endAngle);
                if (obj.stroke && obj.stroke.enabled) {
                    ctx.stroke();
                }
                if (obj.fill && obj.fill.enabled) {
                    ctx.lineTo(centerX, centerY);
                    ctx.closePath();
                    ctx.fill();
                }
            }

            // フィルターをリセット
            ctx.filter = 'none';

            // 選択ボックス
            if (isSelected) {
                ctx.strokeStyle = '#0099ff';
                ctx.lineWidth = 1;
                ctx.setLineDash([]);

                const minX = Math.min(x, x + w);
                const minY = Math.min(y, y + h);
                const maxX = Math.max(x, x + w);
                const maxY = Math.max(y, y + h);

                ctx.strokeRect(minX - 2, minY - 2, maxX - minX + 4, maxY - minY + 4);

                // ハンドル
                const handleSize = 6;
                const handles = [
                    [minX - 2, minY - 2],
                    [maxX + 2, minY - 2],
                    [minX - 2, maxY + 2],
                    [maxX + 2, maxY + 2]
                ];

                ctx.fillStyle = '#ffffff';
                ctx.strokeStyle = '#0099ff';
                ctx.lineWidth = 1;
                handles.forEach(([hx, hy]) => {
                    ctx.fillRect(hx - handleSize/2, hy - handleSize/2, handleSize, handleSize);
                    ctx.strokeRect(hx - handleSize/2, hy - handleSize/2, handleSize, handleSize);
                });

                // 回転ハンドル（上部中央から20px上）
                const rotateHandleX = minX + (maxX - minX) / 2;
                const rotateHandleY = minY - 22;

                // 回転ハンドルへの接続線
                ctx.beginPath();
                ctx.moveTo(rotateHandleX, minY - 2);
                ctx.lineTo(rotateHandleX, rotateHandleY + handleSize/2);
                ctx.stroke();

                // 回転ハンドル（円形）
                ctx.beginPath();
                ctx.arc(rotateHandleX, rotateHandleY, handleSize/2, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
            }

            ctx.restore();
        }

        function drawCheckerboardBackground() {
            const squareSize = 16;
            const color1 = '#3a3a3a';
            const color2 = '#2a2a2a';

            for (let y = 0; y < canvas.height; y += squareSize) {
                for (let x = 0; x < canvas.width; x += squareSize) {
                    const isEven = ((x / squareSize) + (y / squareSize)) % 2 === 0;
                    ctx.fillStyle = isEven ? color1 : color2;
                    ctx.fillRect(x, y, squareSize, squareSize);
                }
            }
        }

        function drawSafeMargins() {
            const actionMargin = parseFloat(document.getElementById('actionSafeMargin').value) / 100;
            const titleMargin = parseFloat(document.getElementById('titleSafeMargin').value) / 100;
            const marginColor = document.getElementById('safeMarginColor').value;
            const opacity = parseFloat(document.getElementById('safeMarginOpacity').value) / 100;

            const rgb = hexToRgb(marginColor);
            ctx.strokeStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`;
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);

            // アクションセーフ
            const actionX = canvas.width * actionMargin;
            const actionY = canvas.height * actionMargin;
            const actionW = canvas.width * (1 - actionMargin * 2);
            const actionH = canvas.height * (1 - actionMargin * 2);
            ctx.strokeRect(actionX, actionY, actionW, actionH);

            // タイトルセーフ
            const titleX = canvas.width * titleMargin;
            const titleY = canvas.height * titleMargin;
            const titleW = canvas.width * (1 - titleMargin * 2);
            const titleH = canvas.height * (1 - titleMargin * 2);
            ctx.strokeRect(titleX, titleY, titleW, titleH);

            ctx.setLineDash([]);
        }

        function drawTextObject(obj, isSelected) {
            if (!obj.text && !isTyping) return;

            ctx.save();

            // 描画設定
            ctx.font = `${obj.fontSize}px "${obj.fontFamily}"`;
            ctx.textBaseline = 'top';
            ctx.textAlign = 'left';

            const text = obj.text || '|';

            if (obj.vertical) {
                // 縦書き描画
                const chars = text.split('');
                for (let i = 0; i < chars.length; i++) {
                    ctx.save();

                    // 各文字の位置
                    const charY = obj.y + (i * obj.fontSize);
                    ctx.translate(obj.x, charY);
                    ctx.rotate(obj.rotation * Math.PI / 180);

                    const char = chars[i];

                    // シャドウ描画
                    if (obj.shadow && obj.shadow.enabled) {
                        const angle = obj.shadow.angle * Math.PI / 180;
                        const offsetX = Math.cos(angle) * obj.shadow.distance;
                        const offsetY = Math.sin(angle) * obj.shadow.distance;
                        const opacity = obj.shadow.opacity / 100;

                        const rgb = hexToRgb(obj.shadow.color);
                        ctx.fillStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`;
                        ctx.fillText(char, offsetX, offsetY);
                    }

                    // ストローク描画
                    if (obj.strokes) {
                        for (let j = obj.strokes.length - 1; j >= 0; j--) {
                            const stroke = obj.strokes[j];
                            if (stroke.enabled && stroke.size > 0) {
                                ctx.strokeStyle = stroke.color;
                                ctx.lineWidth = stroke.size;
                                ctx.lineJoin = 'round';
                                ctx.miterLimit = 2;
                                ctx.strokeText(char, 0, 0);
                            }
                        }
                    }

                    // 塗り描画
                    if (obj.fill && obj.fill.enabled) {
                        const fillType = obj.fill.type || 'solid';

                        if (fillType === 'gradient-linear' || fillType === 'gradient-radial') {
                            // グラデーション描画
                            const gradient = obj.fill.gradient;
                            if (gradient) {
                                const charMetrics = ctx.measureText(char);
                                const charWidth = obj.fontSize;
                                const charHeight = obj.fontSize;

                                let fillGradient;
                                const ratioStart = (gradient.ratioStart || 0) / 100;
                                const ratioEnd = (gradient.ratioEnd || 100) / 100;

                                if (fillType === 'gradient-linear') {
                                    const angle = (gradient.angle || 0) * Math.PI / 180;
                                    const cos = Math.cos(angle);
                                    const sin = Math.sin(angle);
                                    const maxDist = Math.abs(charWidth * cos) + Math.abs(charHeight * sin);

                                    const x1 = charWidth/2 - (cos * maxDist/2);
                                    const y1 = charHeight/2 - (sin * maxDist/2);
                                    const x2 = charWidth/2 + (cos * maxDist/2);
                                    const y2 = charHeight/2 + (sin * maxDist/2);

                                    fillGradient = ctx.createLinearGradient(x1, y1, x2, y2);
                                } else {
                                    const centerX = charWidth / 2;
                                    const centerY = charHeight / 2;
                                    const radius = Math.max(charWidth, charHeight) / 2;
                                    fillGradient = ctx.createRadialGradient(
                                        centerX, centerY, radius * ratioStart,
                                        centerX, centerY, radius * ratioEnd
                                    );
                                }

                                const opacity = (gradient.opacity || 100) / 100;
                                const rgb1 = hexToRgb(gradient.color1);
                                const rgb2 = hexToRgb(gradient.color2);

                                fillGradient.addColorStop(ratioStart, `rgba(${rgb1.r}, ${rgb1.g}, ${rgb1.b}, ${opacity})`);

                                if (gradient.useColor3) {
                                    const rgb3 = hexToRgb(gradient.color3);
                                    const color3Pos = (gradient.color3Position || 50) / 100;
                                    const adjustedPos = ratioStart + (ratioEnd - ratioStart) * color3Pos;
                                    fillGradient.addColorStop(adjustedPos, `rgba(${rgb3.r}, ${rgb3.g}, ${rgb3.b}, ${opacity})`);
                                }

                                fillGradient.addColorStop(ratioEnd, `rgba(${rgb2.r}, ${rgb2.g}, ${rgb2.b}, ${opacity})`);

                                ctx.fillStyle = fillGradient;

                                // ぼかし効果
                                if (gradient.blur && gradient.blur > 0) {
                                    ctx.filter = `blur(${gradient.blur}px)`;
                                }
                            } else {
                                ctx.fillStyle = obj.fill.color;
                            }
                        } else {
                            // ベタ塗り
                            const opacity = obj.fill.opacity / 100;
                            if (opacity < 1) {
                                const rgb = hexToRgb(obj.fill.color);
                                ctx.fillStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`;
                            } else {
                                ctx.fillStyle = obj.fill.color;
                            }
                        }

                        ctx.fillText(char, 0, 0);

                        // ぼかしをリセット
                        if (obj.fill.gradient && obj.fill.gradient.blur > 0) {
                            ctx.filter = 'none';
                        }
                    }

                    ctx.restore();
                }
            } else {
                // 横書き描画
                const scaleX = obj.scaleX / 100;
                const kerning = obj.kerning || 0;
                ctx.translate(obj.x, obj.y);
                ctx.rotate(obj.rotation * Math.PI / 180);
                ctx.scale(scaleX, 1);

                // カーニングを考慮した文字位置の計算
                const renderWithKerning = (renderFunc) => {
                    if (kerning !== 0) {
                        // カーニングありの場合、文字ごとに描画
                        let xOffset = 0;
                        for (let i = 0; i < text.length; i++) {
                            const char = text[i];
                            renderFunc(char, xOffset, 0);
                            const charWidth = ctx.measureText(char).width;
                            xOffset += charWidth + kerning;
                        }
                    } else {
                        // カーニングなしの場合、一括描画
                        renderFunc(text, 0, 0);
                    }
                };

                // シャドウ描画
                if (obj.shadow && obj.shadow.enabled) {
                    const angle = obj.shadow.angle * Math.PI / 180;
                    const offsetX = Math.cos(angle) * obj.shadow.distance / scaleX;
                    const offsetY = Math.sin(angle) * obj.shadow.distance;
                    const opacity = obj.shadow.opacity / 100;

                    const rgb = hexToRgb(obj.shadow.color);
                    ctx.fillStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`;
                    renderWithKerning((txt, x, y) => ctx.fillText(txt, x + offsetX, y + offsetY));
                }

                // ストローク描画（外側から内側へ）
                if (obj.strokes) {
                    for (let i = obj.strokes.length - 1; i >= 0; i--) {
                        const stroke = obj.strokes[i];
                        if (stroke.enabled && stroke.size > 0) {
                            ctx.strokeStyle = stroke.color;
                            ctx.lineWidth = stroke.size;
                            ctx.lineJoin = 'round';
                            ctx.miterLimit = 2;
                            renderWithKerning((txt, x, y) => ctx.strokeText(txt, x, y));
                        }
                    }
                }

                // フェース（塗り）描画
                if (obj.fill && obj.fill.enabled) {
                    const fillType = obj.fill.type || 'solid';

                    if (fillType === 'gradient-linear' || fillType === 'gradient-radial') {
                        // グラデーション描画
                        const gradient = obj.fill.gradient;
                        if (gradient) {
                            const metrics = ctx.measureText(text);
                            const textWidth = metrics.width;
                            const textHeight = obj.fontSize;

                            let fillGradient;
                            const ratioStart = (gradient.ratioStart || 0) / 100;
                            const ratioEnd = (gradient.ratioEnd || 100) / 100;

                            if (fillType === 'gradient-linear') {
                                const angle = (gradient.angle || 0) * Math.PI / 180;
                                const cos = Math.cos(angle);
                                const sin = Math.sin(angle);
                                const maxDist = Math.abs(textWidth * cos) + Math.abs(textHeight * sin);

                                const x1 = textWidth/2 - (cos * maxDist/2);
                                const y1 = textHeight/2 - (sin * maxDist/2);
                                const x2 = textWidth/2 + (cos * maxDist/2);
                                const y2 = textHeight/2 + (sin * maxDist/2);

                                fillGradient = ctx.createLinearGradient(x1, y1, x2, y2);
                            } else {
                                const centerX = textWidth / 2;
                                const centerY = textHeight / 2;
                                const radius = Math.max(textWidth, textHeight) / 2;
                                fillGradient = ctx.createRadialGradient(
                                    centerX, centerY, radius * ratioStart,
                                    centerX, centerY, radius * ratioEnd
                                );
                            }

                            const opacity = (gradient.opacity || 100) / 100;
                            const rgb1 = hexToRgb(gradient.color1);
                            const rgb2 = hexToRgb(gradient.color2);

                            fillGradient.addColorStop(ratioStart, `rgba(${rgb1.r}, ${rgb1.g}, ${rgb1.b}, ${opacity})`);

                            if (gradient.useColor3) {
                                const rgb3 = hexToRgb(gradient.color3);
                                const color3Pos = (gradient.color3Position || 50) / 100;
                                const adjustedPos = ratioStart + (ratioEnd - ratioStart) * color3Pos;
                                fillGradient.addColorStop(adjustedPos, `rgba(${rgb3.r}, ${rgb3.g}, ${rgb3.b}, ${opacity})`);
                            }

                            fillGradient.addColorStop(ratioEnd, `rgba(${rgb2.r}, ${rgb2.g}, ${rgb2.b}, ${opacity})`);

                            ctx.fillStyle = fillGradient;

                            // ぼかし効果
                            if (gradient.blur && gradient.blur > 0) {
                                ctx.filter = `blur(${gradient.blur}px)`;
                            }
                        } else {
                            ctx.fillStyle = obj.fill.color;
                        }
                    } else {
                        // ベタ塗り
                        const opacity = obj.fill.opacity / 100;
                        if (opacity < 1) {
                            const rgb = hexToRgb(obj.fill.color);
                            ctx.fillStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`;
                        } else {
                            ctx.fillStyle = obj.fill.color;
                        }
                    }

                    renderWithKerning((txt, x, y) => ctx.fillText(txt, x, y));

                    // ぼかしをリセット
                    if (obj.fill.gradient && obj.fill.gradient.blur > 0) {
                        ctx.filter = 'none';
                    }
                }
            }

            ctx.restore();

            // 選択ボックス描画（レガシータイトルと同じスタイル）
            if (isSelected) {
                const metrics = measureText(obj);
                ctx.strokeStyle = '#0099ff';
                ctx.lineWidth = 1;
                ctx.setLineDash([]);
                ctx.strokeRect(obj.x - 2, obj.y - 2, metrics.width + 4, metrics.height + 4);

                // ハンドル（レガシータイトル風）
                const handleSize = 6;
                const handles = [
                    [obj.x - 2, obj.y - 2], // 左上
                    [obj.x + metrics.width + 2, obj.y - 2], // 右上
                    [obj.x - 2, obj.y + metrics.height + 2], // 左下
                    [obj.x + metrics.width + 2, obj.y + metrics.height + 2], // 右下
                ];

                ctx.fillStyle = '#ffffff';
                ctx.strokeStyle = '#0099ff';
                ctx.lineWidth = 1;
                handles.forEach(([hx, hy]) => {
                    ctx.fillRect(hx - handleSize/2, hy - handleSize/2, handleSize, handleSize);
                    ctx.strokeRect(hx - handleSize/2, hy - handleSize/2, handleSize, handleSize);
                });

                // 回転ハンドル（上部中央から20px上）
                const rotateHandleX = obj.x + metrics.width / 2;
                const rotateHandleY = obj.y - 22;

                // 回転ハンドルへの接続線
                ctx.beginPath();
                ctx.moveTo(rotateHandleX, obj.y - 2);
                ctx.lineTo(rotateHandleX, rotateHandleY + handleSize/2);
                ctx.stroke();

                // 回転ハンドル（円形）
                ctx.beginPath();
                ctx.arc(rotateHandleX, rotateHandleY, handleSize/2, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
            }
        }

        function drawPathTextObject(obj, isSelected) {
            if (!obj.path || obj.path.length < 2) return;

            ctx.save();
            ctx.font = `${obj.fontSize}px "${obj.fontFamily}"`;
            ctx.textBaseline = 'top';
            ctx.textAlign = 'left';

            const text = obj.text || '';
            const scaleX = obj.scaleX / 100;
            const isVertical = obj.verticalText || false;

            // パスの全長を計算（ベジェ曲線対応）
            let totalLength = 0;
            const pathSegments = [];

            // pathがアンカー配列かどうかを判定
            const hasAnchors = obj.path[0].handleIn !== undefined || obj.path[0].handleOut !== undefined;

            if (obj.bezierPath || hasAnchors) {
                // ベジェ曲線パスの場合（アンカー形式も含む）
                for (let i = 0; i < obj.path.length - 1; i++) {
                    const p1 = obj.path[i];
                    const p2 = obj.path[i + 1];

                    // アンカー形式の場合、ベジェ曲線かどうかを判定
                    const isBezierSegment = hasAnchors && (p1.handleOut || p2.handleIn);

                    if (isBezierSegment) {
                        // ベジェ曲線セグメントの長さを計算（サブディビジョン法）
                        const subdivisions = 50;
                        let segmentLength = 0;
                        let prevPoint = { x: p1.x, y: p1.y };

                        const points = [];
                        for (let t = 0; t <= subdivisions; t++) {
                            const ratio = t / subdivisions;
                            let point;

                            if (p1.handleOut && p2.handleIn) {
                                // ベジエ3次曲線
                                const cp1x = p1.x + (p1.handleOut?.x || 0);
                                const cp1y = p1.y + (p1.handleOut?.y || 0);
                                const cp2x = p2.x + (p2.handleIn?.x || 0);
                                const cp2y = p2.y + (p2.handleIn?.y || 0);
                                const t2 = ratio * ratio;
                                const t3 = t2 * ratio;
                                const mt = 1 - ratio;
                                const mt2 = mt * mt;
                                const mt3 = mt2 * mt;
                                point = {
                                    x: p1.x * mt3 + cp1x * 3 * mt2 * ratio + cp2x * 3 * mt * t2 + p2.x * t3,
                                    y: p1.y * mt3 + cp1y * 3 * mt2 * ratio + cp2y * 3 * mt * t2 + p2.y * t3
                                };
                            } else if (p1.handleOut) {
                                // 2次ベジエ曲線
                                const cpx = p1.x + (p1.handleOut?.x || 0);
                                const cpy = p1.y + (p1.handleOut?.y || 0);
                                const t2 = ratio * ratio;
                                const mt = 1 - ratio;
                                const mt2 = mt * mt;
                                point = {
                                    x: p1.x * mt2 + cpx * 2 * mt * ratio + p2.x * t2,
                                    y: p1.y * mt2 + cpy * 2 * mt * ratio + p2.y * t2
                                };
                            } else {
                                // 直線
                                point = {
                                    x: p1.x + (p2.x - p1.x) * ratio,
                                    y: p1.y + (p2.y - p1.y) * ratio
                                };
                            }

                            points.push(point);

                            if (t > 0) {
                                const dx = point.x - prevPoint.x;
                                const dy = point.y - prevPoint.y;
                                segmentLength += Math.sqrt(dx * dx + dy * dy);
                            }
                            prevPoint = point;
                        }

                        pathSegments.push({
                            start: p1,
                            end: p2,
                            length: segmentLength,
                            startDist: totalLength,
                            isBezier: true,
                            subdivisions: points
                        });
                        totalLength += segmentLength;
                    } else {
                        // 直線セグメント
                        const dx = p2.x - p1.x;
                        const dy = p2.y - p1.y;
                        const segmentLength = Math.sqrt(dx * dx + dy * dy);
                        pathSegments.push({
                            start: p1,
                            end: p2,
                            length: segmentLength,
                            startDist: totalLength,
                            isBezier: false
                        });
                        totalLength += segmentLength;
                    }
                }
            } else {
                // 直線パスの場合
                for (let i = 0; i < obj.path.length - 1; i++) {
                    const p1 = obj.path[i];
                    const p2 = obj.path[i + 1];
                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const segmentLength = Math.sqrt(dx * dx + dy * dy);
                    pathSegments.push({
                        start: p1,
                        end: p2,
                        length: segmentLength,
                        startDist: totalLength,
                        isBezier: false
                    });
                    totalLength += segmentLength;
                }
            }

            // 各文字をパスに沿って配置
            let currentDist = 0;
            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                const charWidth = ctx.measureText(char).width * scaleX;

                // 現在の距離に対応するパスセグメントを見つける
                let segment = null;
                let segmentT = 0;
                for (let j = 0; j < pathSegments.length; j++) {
                    const seg = pathSegments[j];
                    if (currentDist >= seg.startDist && currentDist <= seg.startDist + seg.length) {
                        segment = seg;
                        segmentT = (currentDist - seg.startDist) / seg.length;
                        break;
                    }
                }

                if (segment) {
                    let x, y, angle;

                    if (segment.isBezier) {
                        // ベジェ曲線セグメントの場合
                        const result = getPointAndTangentOnBezier(segment, segmentT);
                        x = result.x;
                        y = result.y;
                        angle = result.angle;
                    } else {
                        // 直線セグメントの場合
                        x = segment.start.x + (segment.end.x - segment.start.x) * segmentT;
                        y = segment.start.y + (segment.end.y - segment.start.y) * segmentT;
                        angle = Math.atan2(segment.end.y - segment.start.y, segment.end.x - segment.start.x);
                    }

                    ctx.save();
                    ctx.translate(x, y);

                    // 縦書きの場合は90度回転
                    if (isVertical) {
                        ctx.rotate(angle + Math.PI / 2 + obj.rotation * Math.PI / 180);
                    } else {
                        ctx.rotate(angle + obj.rotation * Math.PI / 180);
                    }

                    ctx.scale(scaleX, 1);

                    // ベースラインシフトを適用
                    const baselineShift = obj.baselineShift || 0;

                    // シャドウ描画
                    if (obj.shadow && obj.shadow.enabled) {
                        const shadowAngle = obj.shadow.angle * Math.PI / 180;
                        const offsetX = Math.cos(shadowAngle) * obj.shadow.distance;
                        const offsetY = Math.sin(shadowAngle) * obj.shadow.distance + baselineShift;
                        const opacity = obj.shadow.opacity / 100;
                        const rgb = hexToRgb(obj.shadow.color);
                        ctx.fillStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`;
                        ctx.fillText(char, offsetX, offsetY);
                    }

                    // ストローク描画
                    if (obj.strokes) {
                        for (let j = obj.strokes.length - 1; j >= 0; j--) {
                            const stroke = obj.strokes[j];
                            if (stroke.enabled && stroke.size > 0) {
                                ctx.strokeStyle = stroke.color;
                                ctx.lineWidth = stroke.size;
                                ctx.lineJoin = 'round';
                                ctx.miterLimit = 2;
                                ctx.strokeText(char, 0, baselineShift);
                            }
                        }
                    }

                    // 塗り描画
                    if (obj.fill && obj.fill.enabled) {
                        const fillType = obj.fill.type || 'solid';

                        if (fillType === 'gradient-linear' || fillType === 'gradient-radial') {
                            // グラデーション描画
                            const gradient = obj.fill.gradient;
                            if (gradient) {
                                const charMetrics = ctx.measureText(char);
                                const charWidth = obj.fontSize;
                                const charHeight = obj.fontSize;

                                let fillGradient;
                                const ratioStart = (gradient.ratioStart || 0) / 100;
                                const ratioEnd = (gradient.ratioEnd || 100) / 100;

                                if (fillType === 'gradient-linear') {
                                    const gradAngle = (gradient.angle || 0) * Math.PI / 180;
                                    const cos = Math.cos(gradAngle);
                                    const sin = Math.sin(gradAngle);
                                    const maxDist = Math.abs(charWidth * cos) + Math.abs(charHeight * sin);

                                    const x1 = charWidth/2 - (cos * maxDist/2);
                                    const y1 = charHeight/2 - (sin * maxDist/2) + baselineShift;
                                    const x2 = charWidth/2 + (cos * maxDist/2);
                                    const y2 = charHeight/2 + (sin * maxDist/2) + baselineShift;

                                    fillGradient = ctx.createLinearGradient(x1, y1, x2, y2);
                                } else {
                                    const centerX = charWidth / 2;
                                    const centerY = charHeight / 2 + baselineShift;
                                    const radius = Math.max(charWidth, charHeight) / 2;
                                    fillGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
                                }

                                const opacity = (gradient.opacity || 100) / 100;
                                const rgb1 = hexToRgb(gradient.color1);
                                const rgb2 = hexToRgb(gradient.color2);

                                fillGradient.addColorStop(ratioStart, `rgba(${rgb1.r}, ${rgb1.g}, ${rgb1.b}, ${opacity})`);

                                if (gradient.useColor3) {
                                    const rgb3 = hexToRgb(gradient.color3);
                                    const color3Pos = (gradient.color3Position || 50) / 100;
                                    const adjustedPos = ratioStart + (ratioEnd - ratioStart) * color3Pos;
                                    fillGradient.addColorStop(adjustedPos, `rgba(${rgb3.r}, ${rgb3.g}, ${rgb3.b}, ${opacity})`);
                                }

                                fillGradient.addColorStop(ratioEnd, `rgba(${rgb2.r}, ${rgb2.g}, ${rgb2.b}, ${opacity})`);

                                ctx.fillStyle = fillGradient;
                            }
                        } else if (fillType === 'solid') {
                            const opacity = obj.fill.opacity / 100;
                            if (opacity < 1) {
                                const rgb = hexToRgb(obj.fill.color);
                                ctx.fillStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`;
                            } else {
                                ctx.fillStyle = obj.fill.color;
                            }
                        } else {
                            ctx.fillStyle = obj.fill.color;
                        }
                        ctx.fillText(char, 0, baselineShift);
                    }

                    ctx.restore();
                }

                currentDist += charWidth + (obj.kerning || 0);
            }

            ctx.restore();

            // 選択時はパスを表示
            if (isSelected) {
                ctx.strokeStyle = '#0099ff';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(obj.path[0].x, obj.path[0].y);

                if (obj.bezierPath) {
                    // ベジェ曲線として描画
                    for (let i = 0; i < obj.path.length - 1; i++) {
                        const p1 = obj.path[i];
                        const p2 = obj.path[i + 1];

                        if (p1.handleOut && p2.handleIn) {
                            const cp1x = p1.x + p1.handleOut.x;
                            const cp1y = p1.y + p1.handleOut.y;
                            const cp2x = p2.x + p2.handleIn.x;
                            const cp2y = p2.y + p2.handleIn.y;
                            ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y);
                        } else {
                            ctx.lineTo(p2.x, p2.y);
                        }
                    }
                } else {
                    // 直線として描画
                    for (let i = 1; i < obj.path.length; i++) {
                        ctx.lineTo(obj.path[i].x, obj.path[i].y);
                    }
                }

                ctx.stroke();
                ctx.setLineDash([]);

                // パスポイントを表示
                obj.path.forEach(point => {
                    ctx.fillStyle = '#ffffff';
                    ctx.strokeStyle = '#0099ff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                });
            }
        }

        // ベジェ曲線上の点を計算（3次ベジエ）
        function getBezierPoint(p1, p2, t) {
            if (!p1.handleOut && !p2.handleIn) {
                // ハンドルがない場合は線形補間
                return {
                    x: p1.x + (p2.x - p1.x) * t,
                    y: p1.y + (p2.y - p1.y) * t
                };
            }

            const cp1x = p1.x + (p1.handleOut ? p1.handleOut.x : 0);
            const cp1y = p1.y + (p1.handleOut ? p1.handleOut.y : 0);
            const cp2x = p2.x + (p2.handleIn ? p2.handleIn.x : 0);
            const cp2y = p2.y + (p2.handleIn ? p2.handleIn.y : 0);

            // 3次ベジェ曲線の計算
            const t1 = 1 - t;
            const t1_2 = t1 * t1;
            const t1_3 = t1_2 * t1;
            const t_2 = t * t;
            const t_3 = t_2 * t;

            const x = t1_3 * p1.x + 3 * t1_2 * t * cp1x + 3 * t1 * t_2 * cp2x + t_3 * p2.x;
            const y = t1_3 * p1.y + 3 * t1_2 * t * cp1y + 3 * t1 * t_2 * cp2y + t_3 * p2.y;

            return { x, y };
        }

        // ベジェ曲線セグメント上の点と接線を取得
        function getPointAndTangentOnBezier(segment, segmentT) {
            const p1 = segment.start;
            const p2 = segment.end;

            // サブディビジョンポイントから補間
            if (segment.subdivisions) {
                const subdivisions = segment.subdivisions;
                const index = segmentT * (subdivisions.length - 1);
                const i1 = Math.floor(index);
                const i2 = Math.min(i1 + 1, subdivisions.length - 1);
                const localT = index - i1;

                const pt1 = subdivisions[i1];
                const pt2 = subdivisions[i2];

                const x = pt1.x + (pt2.x - pt1.x) * localT;
                const y = pt1.y + (pt2.y - pt1.y) * localT;
                const angle = Math.atan2(pt2.y - pt1.y, pt2.x - pt1.x);

                return { x, y, angle };
            }

            // フォールバック：ベジェ曲線から直接計算
            const point = getBezierPoint(p1, p2, segmentT);

            // 接線を計算（微小なdt で近似）
            const dt = 0.01;
            const t2 = Math.min(segmentT + dt, 1.0);
            const point2 = getBezierPoint(p1, p2, t2);

            const angle = Math.atan2(point2.y - point.y, point2.x - point.x);

            return {
                x: point.x,
                y: point.y,
                angle: angle
            };
        }

        function drawTextSelection() {
            if (!selectedObject) return;

            ctx.save();
            ctx.font = `${selectedObject.fontSize}px "${selectedObject.fontFamily}"`;

            const start = Math.min(selectionStart, selectionEnd);
            const end = Math.max(selectionStart, selectionEnd);

            const textBeforeSelection = selectedObject.text.substring(0, start);
            const selectedText = selectedObject.text.substring(start, end);

            const metricsBeforeSelection = ctx.measureText(textBeforeSelection);
            const metricsSelectedText = ctx.measureText(selectedText);

            const selectionX = selectedObject.x + metricsBeforeSelection.width * (selectedObject.scaleX / 100);
            const selectionWidth = metricsSelectedText.width * (selectedObject.scaleX / 100);
            const selectionY = selectedObject.y;
            const selectionHeight = selectedObject.fontSize;

            // 青いハイライト（レガシータイトルと同じ）
            ctx.fillStyle = 'rgba(0, 102, 204, 0.3)';
            ctx.fillRect(selectionX, selectionY, selectionWidth, selectionHeight);

            ctx.restore();
        }

        function drawCursor() {
            if (!selectedObject) return;

            ctx.save();
            ctx.font = `${selectedObject.fontSize}px "${selectedObject.fontFamily}"`;

            // パス上文字の場合
            if (selectedObject.path && selectedObject.path.length >= 2) {
                const text = selectedObject.text || '';
                const scaleX = selectedObject.scaleX / 100;

                // パスの全長を計算
                let totalLength = 0;
                const pathSegments = [];
                for (let i = 0; i < selectedObject.path.length - 1; i++) {
                    const p1 = selectedObject.path[i];
                    const p2 = selectedObject.path[i + 1];
                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const segmentLength = Math.sqrt(dx * dx + dy * dy);
                    pathSegments.push({
                        start: p1,
                        end: p2,
                        length: segmentLength,
                        startDist: totalLength
                    });
                    totalLength += segmentLength;
                }

                // カーソル位置までの距離を計算
                let currentDist = 0;
                for (let i = 0; i < cursorPosition && i < text.length; i++) {
                    const char = text[i];
                    const charWidth = ctx.measureText(char).width * scaleX;
                    currentDist += charWidth + (selectedObject.kerning || 0);
                }

                // カーソル位置のパスセグメントを見つける
                let segment = null;
                let segmentT = 0;
                for (let j = 0; j < pathSegments.length; j++) {
                    const seg = pathSegments[j];
                    if (currentDist >= seg.startDist && currentDist <= seg.startDist + seg.length) {
                        segment = seg;
                        segmentT = (currentDist - seg.startDist) / seg.length;
                        break;
                    }
                }

                // カーソルを描画
                if (segment) {
                    const x = segment.start.x + (segment.end.x - segment.start.x) * segmentT;
                    const y = segment.start.y + (segment.end.y - segment.start.y) * segmentT;
                    const angle = Math.atan2(segment.end.y - segment.start.y, segment.end.x - segment.start.x);

                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(angle + selectedObject.rotation * Math.PI / 180);

                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(0, selectedObject.fontSize);
                    ctx.stroke();

                    ctx.restore();
                } else if (cursorPosition === 0) {
                    // カーソルが先頭の場合
                    const p = selectedObject.path[0];
                    const p2 = selectedObject.path[1];
                    const angle = Math.atan2(p2.y - p.y, p2.x - p.x);

                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.rotate(angle + selectedObject.rotation * Math.PI / 180);

                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(0, selectedObject.fontSize);
                    ctx.stroke();

                    ctx.restore();
                }
            } else {
                // 通常のテキストの場合
                if (selectedObject.vertical) {
                    // 縦書きの場合：カーソルは下に移動し、横線で表示
                    const cursorX = selectedObject.x;
                    const cursorY = selectedObject.y + cursorPosition * selectedObject.fontSize;

                    // カーソル描画（横線）
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(cursorX, cursorY);
                    ctx.lineTo(cursorX + selectedObject.fontSize, cursorY);
                    ctx.stroke();
                } else {
                    // 横書きの場合：カーソルは右に移動し、縦線で表示
                    const textBeforeCursor = selectedObject.text.substring(0, cursorPosition);
                    const metrics = ctx.measureText(textBeforeCursor);
                    const cursorX = selectedObject.x + metrics.width * (selectedObject.scaleX / 100);
                    const cursorY = selectedObject.y;

                    // より目立つカーソル（レガシータイトルと同じ）
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(cursorX, cursorY);
                    ctx.lineTo(cursorX, cursorY + selectedObject.fontSize);
                    ctx.stroke();
                }
            }

            ctx.restore();
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 0, g: 0, b: 0 };
        }

        function hexToRgba(hex, alpha = 1) {
            const rgb = hexToRgb(hex);
            return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha})`;
        }

        // 点から線分への最短距離を計算
        function distanceToLineSegment(px, py, x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const lengthSquared = dx * dx + dy * dy;

            if (lengthSquared === 0) {
                // 線分が点の場合
                return Math.sqrt((px - x1) ** 2 + (py - y1) ** 2);
            }

            // 線分上の最も近い点のパラメータt (0 <= t <= 1)
            let t = ((px - x1) * dx + (py - y1) * dy) / lengthSquared;
            t = Math.max(0, Math.min(1, t));

            // 線分上の最も近い点
            const nearestX = x1 + t * dx;
            const nearestY = y1 + t * dy;

            // 点から最も近い点までの距離
            return Math.sqrt((px - nearestX) ** 2 + (py - nearestY) ** 2);
        }

        // プロパティセクションの折りたたみ
        document.querySelectorAll('.property-section-header').forEach(header => {
            header.addEventListener('click', () => {
                header.classList.toggle('collapsed');
                const content = header.nextElementSibling;
                content.classList.toggle('hidden');
            });
        });

        // PRTL書き出し（既存のPRTLGeneratorV2を使用）
        function exportPRTL() {
            if (textObjects.length === 0) {
                alert('テキストオブジェクトがありません');
                return;
            }

            // 最初のテキストオブジェクトを使用（複数対応は後で実装）
            const obj = textObjects[0];

            const config = {
                width: canvas.width,
                height: canvas.height,
                text: obj.text,
                fontFamily: obj.fontFamily,
                fontSize: obj.fontSize,
                scaleX: obj.scaleX,
                kerning: obj.kerning || 0,
                posX: obj.x,
                posY: obj.y,
                textAlign: 'left',
                fillType: obj.fill.type || 'solid',
                fillColor: obj.fill.color,
                fillGradient: obj.fill.gradient,
                stroke4_enabled: obj.strokes[3].enabled,
                stroke4_size: obj.strokes[3].size,
                stroke4_color: obj.strokes[3].color,
                stroke3_enabled: obj.strokes[2].enabled,
                stroke3_size: obj.strokes[2].size,
                stroke3_color: obj.strokes[2].color,
                stroke2_enabled: obj.strokes[1].enabled,
                stroke2_size: obj.strokes[1].size,
                stroke2_color: obj.strokes[1].color,
                stroke1_enabled: obj.strokes[0].enabled,
                stroke1_size: obj.strokes[0].size,
                stroke1_color: obj.strokes[0].color,
                shadow_enabled: obj.shadow.enabled,
                shadow_offset: obj.shadow.distance,
                shadow_angle: obj.shadow.angle,
                shadow_color: obj.shadow.color,
                shadow_opacity: obj.shadow.opacity
            };

            const generator = new PRTLGeneratorV2();
            const prtlXML = generator.generatePRTL(config);

            // UTF-8エンコード
            const encoder = new TextEncoder();
            const utf8Array = encoder.encode(prtlXML);

            const blob = new Blob([utf8Array], { type: 'application/octet-stream' });
            const link = document.createElement('a');
            link.download = `NLT_${Date.now()}.prtl`;
            link.href = URL.createObjectURL(blob);
            link.click();

            console.log('✅ PRTL書き出し完了');
        }

        // PRTL読み込み
        function importPRTL(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const content = e.target.result;
                    parsePRTLFile(content);
                    console.log('✅ PRTL読み込み完了');
                } catch (error) {
                    console.error('❌ PRTL読み込みエラー:', error);
                    alert('PRTLファイルの読み込みに失敗しました: ' + error.message);
                }
            };
            reader.readAsText(file, 'UTF-16');
        }

        // PRTLファイルを解析してオブジェクトを作成
        function parsePRTLFile(xmlString) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlString, 'text/xml');

            // エラーチェック
            const parseError = xmlDoc.querySelector('parsererror');
            if (parseError) {
                throw new Error('XML解析エラー');
            }

            // TextLineを取得
            const textLines = xmlDoc.querySelectorAll('TextLine');

            textLines.forEach((textLine, index) => {
                const baseProps = textLine.querySelector('BaseProperties');
                const splineData = textLine.querySelector('SplineData');
                const enclosingType = textLine.querySelector('EnclosingObjectType')?.textContent;
                const trString = textLine.querySelector('TRString')?.textContent || '';
                const verticalText = baseProps?.querySelector('verticalText')?.textContent === 'true';

                // スタイル情報を取得
                const charAttrs = textLine.querySelector('CharacterAttributes');
                const styleRef = charAttrs?.getAttribute('StyleRef');
                const textRef = charAttrs?.getAttribute('TextRef');
                const txKerning = parseFloat(charAttrs?.getAttribute('TXKerning') || '0');

                // TextDescriptionからフォント情報を取得
                const textDesc = xmlDoc.querySelector(`TextDescription[Reference="${textRef}"]`);
                const typeSpec = textDesc?.querySelector('TypeSpec');
                const fontSize = parseInt(typeSpec?.querySelector('size')?.textContent || '72');
                const txWidth = parseFloat(typeSpec?.querySelector('txWidth')?.textContent || '100');
                const fontFamily = typeSpec?.querySelector('fifontFamilyName')?.textContent || 'Arial';

                // スタイル情報を取得（fill, stroke, shadowなど）
                const style = xmlDoc.querySelector(`Style[ID="${styleRef}"]`);
                const fillShader = getShaderFromStyle(xmlDoc, style, 15); // painter 15 = fill
                const strokeShader1 = getShaderFromStyle(xmlDoc, style, 13); // painter 13 = stroke
                const strokeShader2 = getShaderFromStyle(xmlDoc, style, 12); // painter 12 = stroke

                if (enclosingType === 'spline' && splineData) {
                    // パス上文字ツール
                    const path = parseSplineData(splineData);

                    if (path.length > 0) {
                        const pathTextObj = {
                            text: trString,
                            path: path,
                            bezierPath: true, // ベジェ曲線パスであることを示す
                            fontSize: fontSize,
                            fontFamily: fontFamily,
                            scaleX: txWidth,
                            kerning: txKerning,
                            verticalText: verticalText,
                            rotation: 0,
                            baselineShift: 0,
                            fill: fillShader || {
                                enabled: true,
                                type: 'solid',
                                color: '#ff3b3b',
                                opacity: 100
                            },
                            strokes: [
                                strokeShader1 || { enabled: false, size: 0, color: '#000000' },
                                strokeShader2 || { enabled: false, size: 0, color: '#000000' },
                                { enabled: false, size: 0, color: '#000000' },
                                { enabled: false, size: 0, color: '#000000' }
                            ],
                            shadow: {
                                enabled: false,
                                distance: 0,
                                angle: 0,
                                color: '#000000',
                                opacity: 100
                            }
                        };

                        pathTextObjects.push(pathTextObj);
                    }
                } else {
                    // 通常のテキスト（block, box, normalなど）
                    const txBase = parseFloat(baseProps?.querySelector('txBase')?.textContent || fontSize);
                    const xPos = parseFloat(baseProps?.querySelector('XPos')?.textContent || '960');
                    const yPos = txBase; // txBaseをY位置として使用

                    const textObj = {
                        text: trString,
                        x: xPos,
                        y: yPos,
                        fontSize: fontSize,
                        fontFamily: fontFamily,
                        scaleX: txWidth,
                        scaleY: 100,
                        kerning: txKerning,
                        rotation: 0,
                        baselineShift: 0,
                        fill: fillShader || {
                            enabled: true,
                            type: 'solid',
                            color: '#ff3b3b',
                            opacity: 100
                        },
                        strokes: [
                            strokeShader1 || { enabled: false, size: 0, color: '#000000' },
                            strokeShader2 || { enabled: false, size: 0, color: '#000000' },
                            { enabled: false, size: 0, color: '#000000' },
                            { enabled: false, size: 0, color: '#000000' }
                        ],
                        shadow: {
                            enabled: false,
                            distance: 0,
                            angle: 0,
                            color: '#000000',
                            opacity: 100
                        }
                    };

                    textObjects.push(textObj);
                }
            });

            // 再描画
            render();
        }

        // SplineDataを解析してベジェパスに変換
        function parseSplineData(splineData) {
            const polyPoints = splineData.querySelector('PolyPoints');
            if (!polyPoints) return [];

            const controlPoints = polyPoints.querySelectorAll('ControlPoint');
            const path = [];

            // crsrX, crsrYをオフセットとして取得
            const offsetX = parseFloat(splineData.querySelector('crsrX')?.textContent || '0');
            const offsetY = parseFloat(splineData.querySelector('crsrY')?.textContent || '0');

            controlPoints.forEach((cp, index) => {
                const cpElement = cp.querySelector('cp');
                const forwardElement = cp.querySelector('forward');
                const backwardElement = cp.querySelector('backward');

                const x = parseFloat(cpElement?.getAttribute('x') || '0') + offsetX;
                const y = parseFloat(cpElement?.getAttribute('y') || '0') + offsetY;

                const forwardX = parseFloat(forwardElement?.getAttribute('x') || '0');
                const forwardY = parseFloat(forwardElement?.getAttribute('y') || '0');
                const backwardX = parseFloat(backwardElement?.getAttribute('x') || '0');
                const backwardY = parseFloat(backwardElement?.getAttribute('y') || '0');

                path.push({
                    x: x,
                    y: y,
                    handleOut: forwardX !== 0 || forwardY !== 0 ? { x: forwardX, y: forwardY } : null,
                    handleIn: backwardX !== 0 || backwardY !== 0 ? { x: backwardX, y: backwardY } : null
                });
            });

            return path;
        }

        // スタイルからシェーダー情報を取得
        function getShaderFromStyle(xmlDoc, style, painterNumber) {
            if (!style) return null;

            const shaderList = style.querySelector('ShaderList');
            const shaderRef = shaderList?.querySelector(`ShaderRef[PainterNumber="${painterNumber}"]`)?.querySelector('shaderRef')?.textContent;

            if (!shaderRef || shaderRef === '0') return null;

            const shader = xmlDoc.querySelector(`Shader[cReference="${shaderRef}"]`);
            if (!shader) return null;

            const colorSpec = shader.querySelector('ColorSpec[index="0"]');
            const red = parseInt(colorSpec?.querySelector('red')?.textContent || '255');
            const green = parseInt(colorSpec?.querySelector('green')?.textContent || '255');
            const blue = parseInt(colorSpec?.querySelector('blue')?.textContent || '255');

            const color = `#${red.toString(16).padStart(2, '0')}${green.toString(16).padStart(2, '0')}${blue.toString(16).padStart(2, '0')}`;

            // Painter 15はfill、それ以外はstroke
            if (painterNumber === 15) {
                return {
                    enabled: true,
                    type: 'solid',
                    color: color,
                    opacity: 100
                };
            } else {
                // strokeの場合、fragmentリストからサイズを取得
                const fragmentList = style.querySelector('FragmentList');
                const fragments = fragmentList?.querySelectorAll('Fragment');
                let strokeSize = 0;

                fragments?.forEach(frag => {
                    const annotation = frag.querySelector('annotation')?.textContent;
                    if ((painterNumber === 13 && annotation === '1') ||
                        (painterNumber === 12 && annotation === '2')) {
                        strokeSize = parseFloat(frag.querySelector('size')?.textContent || '0');
                    }
                });

                return {
                    enabled: strokeSize > 0,
                    size: strokeSize,
                    color: color
                };
            }
        }

        // PRTLGeneratorV2クラス（既存のものを再利用）
        class PRTLGeneratorV2 {
            constructor() {
                this.nextStyleID = 4096;
                this.nextShaderID = 4096;
                this.nextTextDescID = 4096;
            }

            generatePRTL(config) {
                const width = config.width || 1920;
                const height = config.height || 1080;

                const textDescriptions = this._buildTextDescriptions(config);
                const shaders = this._buildShaders(config);
                const styles = this._buildStyles(config);
                const layers = this._buildLayers(config);

                return this._buildPRTLDocument(width, height, textDescriptions, shaders, styles, layers);
            }

            _buildPRTLDocument(width, height, textDescriptions, shaders, styles, layers) {
                return `<?xml version="1.0" encoding="UTF-16" ?>` +
                    `<Adobe_Root>` +
                        `<Adobe_Title>` +
                            `<Version>20080702</Version>` +
                            `<Motion_Settings>` +
                                `<Play_Forward>true</Play_Forward>` +
                                `<Start_on_Screen>false</Start_on_Screen>` +
                                `<Pre_Roll>0</Pre_Roll>` +
                                `<Ease_In>0</Ease_In>` +
                                `<End_off_Screen>false</End_off_Screen>` +
                                `<Post_Roll>0</Post_Roll>` +
                                `<Ease_Out>0</Ease_Out>` +
                            `</Motion_Settings>` +
                        `</Adobe_Title>` +
                        `<InscriberLayouts Version="1.0">` +
                            `<Layout>` +
                                this._buildLayoutHeader(width, height) +
                                textDescriptions +
                                styles +
                                shaders +
                                this._buildTextures() +
                                this._buildLogos() +
                                layers +
                                this._buildVLS() +
                            `</Layout>` +
                        `</InscriberLayouts>` +
                    `</Adobe_Root>`;
            }

            _buildLayoutHeader(width, height) {
                return `<LayoutEffectInfo Version="2">` +
                        `<EffectType>0</EffectType>` +
                        `<Indic>false</Indic>` +
                        `<Ligatures>false</Ligatures>` +
                        `<HindiDigits>false</HindiDigits>` +
                    `</LayoutEffectInfo>` +
                    `<LayoutDimension Version="2">` +
                        `<pXPIXELS>${width}</pXPIXELS>` +
                        `<pYLINES>${height}</pYLINES>` +
                        `<pSCREENAR>1</pSCREENAR>` +
                        `<growthDirection>growRightDown</growthDirection>` +
                    `</LayoutDimension>` +
                    `<LayoutAttributes>` +
                        `<SafeTitleArea>` +
                            `<left>0.1</left><top>0.1</top><right>0.9</right><bottom>0.9</bottom>` +
                        `</SafeTitleArea>` +
                        `<SafeActionArea>` +
                            `<left>0.05</left><top>0.05</top><right>0.95</right><bottom>0.95</bottom>` +
                        `</SafeActionArea>` +
                    `</LayoutAttributes>` +
                    `<Background Version="4">` +
                        `<ShaderReference>4098</ShaderReference>` +
                        `<On>false</On>` +
                        `<paintingRange>normalLayout</paintingRange>` +
                    `</Background>` +
                    `<DefaultStyle><Reference>${this.nextStyleID}</Reference></DefaultStyle>` +
                    `<DefaultTextDescription><Reference>${this.nextTextDescID}</Reference></DefaultTextDescription>` +
                    `<GraphicObjectDefaults>` +
                        `<endCapType>square</endCapType>` +
                        `<joinTypeClosed>round</joinTypeClosed>` +
                        `<joinTypeOpen>round</joinTypeOpen>` +
                        `<lineWidth>5</lineWidth>` +
                        `<miterLimit>5</miterLimit>` +
                        `<windBeziers>false</windBeziers>` +
                        `<roundCornerFillets>37.5 37.5 37.5 37.5 37.5 37.5 37.5 37.5 </roundCornerFillets>` +
                        `<clippedCornerFillets>37.5 37.5 37.5 37.5 37.5 37.5 37.5 37.5 </clippedCornerFillets>` +
                    `</GraphicObjectDefaults>` +
                    this._buildTextChainDefaults();
            }

            _buildTextChainDefaults() {
                const defaults = `<leading>0</leading>` +
                    `<boxCanGrow>false</boxCanGrow>` +
                    `<wordWrap>true</wordWrap>` +
                    `<lockedLinesX>false</lockedLinesX>` +
                    `<lockedLinesY>false</lockedLinesY>` +
                    `<Alignment>left</Alignment>` +
                    `<tabModeStyle>Word</tabModeStyle>` +
                    `<implicitTabSpacing>100</implicitTabSpacing>` +
                    `<implicitTabType>left</implicitTabType>` +
                    `<rtl>false</rtl>` +
                    `<tabs></tabs>`;

                return `<TextChainDefaults>` +
                    `<normal>${defaults}</normal>` +
                    `<boxNormal>${defaults.replace('<wordWrap>true</wordWrap>', '<wordWrap>true</wordWrap>').replace('<lockedLinesX>false</lockedLinesX>', '<lockedLinesX>true</lockedLinesX>').replace('<lockedLinesY>false</lockedLinesY>', '<lockedLinesY>true</lockedLinesY>')}</boxNormal>` +
                    `<blockNormal>${defaults.replace('<wordWrap>true</wordWrap>', '<wordWrap>false</wordWrap>').replace('<lockedLinesX>false</lockedLinesX>', '<lockedLinesX>true</lockedLinesX>').replace('<lockedLinesY>false</lockedLinesY>', '<lockedLinesY>true</lockedLinesY>')}</blockNormal>` +
                    `<spline>${defaults}</spline>` +
                `</TextChainDefaults>`;
            }

            _buildTextDescriptions(config) {
                const ref = this.nextTextDescID;
                const fontFamily = config.fontFamily || 'Yu Gothic UI';
                const fontSize = config.fontSize || 72;
                const scaleX = config.scaleX || 100;
                const kerning = config.kerning || 0;

                return `<TextDescriptions Version="4">` +
                    `<TextDescription Reference="${ref}">` +
                        `<TypeSpec>` +
                            `<size>${fontSize * 8}</size>` +
                            `<txHeight>${fontSize}</txHeight>` +
                            `<txKern>${kerning}</txKern>` +
                            `<baselineShift>0</baselineShift>` +
                            `<leading>0</leading>` +
                            `<txSCaps>${fontSize}</txSCaps>` +
                            `<txSCapsOn>false</txSCapsOn>` +
                            `<txSlant>0</txSlant>` +
                            `<txUnderline>false</txUnderline>` +
                            `<txWidth>${scaleX}</txWidth>` +
                            `<linked>false</linked>` +
                            `<fiBold>0</fiBold>` +
                            `<fiItalic>0</fiItalic>` +
                            `<fifullName>${this._escapeXML(fontFamily)}</fifullName>` +
                            `<fifontFamilyName>${this._escapeXML(fontFamily)}</fifontFamilyName>` +
                            `<fifontStyle>Regular</fifontStyle>` +
                            `<fifontType>5</fifontType>` +
                            `<ficategory>1</ficategory>` +
                        `</TypeSpec>` +
                    `</TextDescription>` +
                `</TextDescriptions>`;
            }

            _buildStyles(config) {
                const styleID = this.nextStyleID;
                const textDescRef = this.nextTextDescID;

                let fragments = '';
                let shaderRefs = {};
                let nextPainter = 10;
                let nextShaderRef = this.nextShaderID;

                if (config.stroke4_enabled) {
                    fragments += `<Fragment>` +
                        `<size>${config.stroke4_size}</size>` +
                        `<offset>0</offset>` +
                        `<angle>0</angle>` +
                        `<ghost>false</ghost>` +
                        `<isExtendedShadowFragment>false</isExtendedShadowFragment>` +
                        `<eFragmentType>2</eFragmentType>` +
                        `<fragmentOff>false</fragmentOff>` +
                        `<placeHolder>false</placeHolder>` +
                        `<annotation>4</annotation>` +
                        `<placeHolderShaderIndex>4294967295</placeHolderShaderIndex>` +
                        `<painterMix>${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} </painterMix>` +
                    `</Fragment>`;
                    shaderRefs[nextPainter++] = nextShaderRef++;
                }

                if (config.stroke3_enabled) {
                    fragments += `<Fragment>` +
                        `<size>${config.stroke3_size}</size>` +
                        `<offset>0</offset>` +
                        `<angle>0</angle>` +
                        `<ghost>false</ghost>` +
                        `<isExtendedShadowFragment>false</isExtendedShadowFragment>` +
                        `<eFragmentType>2</eFragmentType>` +
                        `<fragmentOff>false</fragmentOff>` +
                        `<placeHolder>false</placeHolder>` +
                        `<annotation>3</annotation>` +
                        `<placeHolderShaderIndex>4294967295</placeHolderShaderIndex>` +
                        `<painterMix>${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} </painterMix>` +
                    `</Fragment>`;
                    shaderRefs[nextPainter++] = nextShaderRef++;
                }

                if (config.stroke2_enabled) {
                    fragments += `<Fragment>` +
                        `<size>${config.stroke2_size}</size>` +
                        `<offset>0</offset>` +
                        `<angle>0</angle>` +
                        `<ghost>false</ghost>` +
                        `<isExtendedShadowFragment>false</isExtendedShadowFragment>` +
                        `<eFragmentType>2</eFragmentType>` +
                        `<fragmentOff>false</fragmentOff>` +
                        `<placeHolder>false</placeHolder>` +
                        `<annotation>2</annotation>` +
                        `<placeHolderShaderIndex>4294967295</placeHolderShaderIndex>` +
                        `<painterMix>${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} </painterMix>` +
                    `</Fragment>`;
                    shaderRefs[nextPainter++] = nextShaderRef++;
                }

                if (config.stroke1_enabled) {
                    fragments += `<Fragment>` +
                        `<size>${config.stroke1_size}</size>` +
                        `<offset>0</offset>` +
                        `<angle>0</angle>` +
                        `<ghost>false</ghost>` +
                        `<isExtendedShadowFragment>false</isExtendedShadowFragment>` +
                        `<eFragmentType>2</eFragmentType>` +
                        `<fragmentOff>false</fragmentOff>` +
                        `<placeHolder>false</placeHolder>` +
                        `<annotation>1</annotation>` +
                        `<placeHolderShaderIndex>4294967295</placeHolderShaderIndex>` +
                        `<painterMix>${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} </painterMix>` +
                    `</Fragment>`;
                    shaderRefs[nextPainter++] = nextShaderRef++;
                }

                fragments += `<Fragment>` +
                    `<size>0</size>` +
                    `<offset>0</offset>` +
                    `<angle>0</angle>` +
                    `<ghost>false</ghost>` +
                    `<isExtendedShadowFragment>false</isExtendedShadowFragment>` +
                    `<eFragmentType>0</eFragmentType>` +
                    `<fragmentOff>false</fragmentOff>` +
                    `<placeHolder>false</placeHolder>` +
                    `<annotation>65538</annotation>` +
                    `<placeHolderShaderIndex>4294967295</placeHolderShaderIndex>` +
                    `<painterMix>15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 </painterMix>` +
                `</Fragment>`;
                shaderRefs[15] = nextShaderRef++;

                const shadowOff = config.shadow_enabled ? 'false' : 'true';
                fragments += `<Fragment>` +
                    `<size>0</size>` +
                    `<offset>${config.shadow_offset || 10}</offset>` +
                    `<angle>${config.shadow_angle || -45}</angle>` +
                    `<ghost>false</ghost>` +
                    `<isExtendedShadowFragment>true</isExtendedShadowFragment>` +
                    `<eFragmentType>0</eFragmentType>` +
                    `<fragmentOff>${shadowOff}</fragmentOff>` +
                    `<placeHolder>false</placeHolder>` +
                    `<annotation>65537</annotation>` +
                    `<placeHolderShaderIndex>4294967295</placeHolderShaderIndex>` +
                    `<painterMix>0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 </painterMix>` +
                `</Fragment>`;
                if (config.shadow_enabled) {
                    shaderRefs[0] = nextShaderRef++;
                }

                let shaderList = '';
                for (let i = 0; i <= 15; i++) {
                    const ref = shaderRefs[i] || 0;
                    shaderList += `<ShaderRef PainterNumber="${i}"><shaderRef>${ref}</shaderRef></ShaderRef>`;
                }
                shaderList += `<ShaderRef PainterNumber="-1"><shaderRef>0</shaderRef></ShaderRef>`;

                config._shaderRefs = shaderRefs;
                config._nextShaderRef = nextShaderRef;

                return `<Styles>` +
                    `<Style ID="${styleID}">` +
                        `<StyleBase Version="4">` +
                            `<type>50000</type>` +
                            `<positionDominance>0</positionDominance>` +
                            `<lineGradient>false</lineGradient>` +
                            `<styleRef>${styleID}</styleRef>` +
                            `<faceDistortX>0</faceDistortX>` +
                            `<faceDistortY>0</faceDistortY>` +
                            `<shadow_softness>30</shadow_softness>` +
                            `<personality>0</personality>` +
                            `<linked>false</linked>` +
                            `<EmbellishmentSizeRule>false</EmbellishmentSizeRule>` +
                            `<PainterRampType>Basic</PainterRampType>` +
                        `</StyleBase>` +
                        `<FragmentList Version="5">` +
                            fragments +
                        `</FragmentList>` +
                        `<ShaderList Version="1">` +
                            shaderList +
                        `</ShaderList>` +
                    `</Style>` +
                `</Styles>`;
            }

            _buildShaders(config) {
                let shaders = '<Shaders>';
                const shaderRefs = config._shaderRefs || {};

                for (const [painter, shaderRef] of Object.entries(shaderRefs)) {
                    const painterNum = parseInt(painter);

                    if (painterNum === 15) {
                        shaders += this._buildFaceShader(shaderRef, config);
                    } else if (painterNum === 0) {
                        shaders += this._buildShadowShader(shaderRef, config);
                    } else if (painterNum >= 10 && painterNum <= 13) {
                        const strokeNum = 14 - painterNum;
                        const strokeColor = config[`stroke${strokeNum}_color`] || '#000000';
                        shaders += this._buildStrokeShader(shaderRef, strokeColor);
                    }
                }

                shaders += '</Shaders>';
                return shaders;
            }

            _buildStrokeShader(shaderRef, color) {
                const rgb = this._parseColor(color);

                let colorSpecs = '';
                for (let i = 0; i <= 4; i++) {
                    colorSpecs += `<ColorSpec index="${i}">` +
                        `<red>${rgb.r}</red>` +
                        `<green>${rgb.g}</green>` +
                        `<blue>${rgb.b}</blue>` +
                        `<xpar>0</xpar>` +
                    `</ColorSpec>`;
                }

                return `<Shader Version="4">` +
                    `<cReference>${shaderRef}</cReference>` +
                    `<textureRef>0</textureRef>` +
                    `<colorOption>4</colorOption>` +
                    `<shaderOn>true</shaderOn>` +
                    `<glintSize>10</glintSize>` +
                    `<glintOffset>0</glintOffset>` +
                    `<rampPosTop>75</rampPosTop>` +
                    `<rampPosBottom>25</rampPosBottom>` +
                    `<rampAngle>0</rampAngle>` +
                    `<bevelBalance>0</bevelBalance>` +
                    `<rampCycle>0</rampCycle>` +
                    `<classicStyle>0</classicStyle>` +
                    `<rampType>0</rampType>` +
                    colorSpecs +
                    `<glintAngle>0</glintAngle>` +
                    `<bevelSize>0</bevelSize>` +
                    `<bevelDirection>0</bevelDirection>` +
                    `<bevelPipe>false</bevelPipe>` +
                    `<bevelAngle>0</bevelAngle>` +
                    `<bevelShape>1</bevelShape>` +
                    `<bevelShining>0</bevelShining>` +
                    `<bevelLight>false</bevelLight>` +
                    `<bevelMerge>true</bevelMerge>` +
                    `<sheenOn>false</sheenOn>` +
                `</Shader>`;
            }

            _buildFaceShader(shaderRef, config) {
                const fillType = config.fillType || 'solid';
                const gradient = config.fillGradient;

                let colorOption, rampType, rampAngle, rampPosTop, rampPosBottom;
                let colorSpecs = '';

                if ((fillType === 'gradient-linear' || fillType === 'gradient-radial') && gradient) {
                    // グラデーション設定
                    colorOption = 0;
                    rampType = -1;
                    rampAngle = gradient.angle || 0;

                    // 比率の設定（ratioStart/ratioEndから計算）
                    const ratioStart = gradient.ratioStart || 0;
                    const ratioEnd = gradient.ratioEnd || 100;

                    if (fillType === 'gradient-linear') {
                        // 線形グラデーション：デフォルト値75/25をベースに調整
                        rampPosTop = 100 - ratioStart;
                        rampPosBottom = 100 - ratioEnd;
                    } else {
                        // 円形グラデーション：デフォルト値85.8696/44.5652をベースに調整
                        const baseTop = 85.8696;
                        const baseBottom = 44.5652;
                        const range = baseTop - baseBottom;
                        rampPosTop = baseTop - (ratioStart / 100 * range);
                        rampPosBottom = baseBottom - (ratioEnd / 100 * range);
                    }

                    // ColorSpecの生成（グラデーション用）
                    const rgb1 = this._parseColor(gradient.color1 || '#fdff00');
                    const rgb2 = this._parseColor(gradient.color2 || '#ff6600');

                    // index 0: 開始色
                    colorSpecs += `<ColorSpec index="0">` +
                        `<red>${rgb1.r}</red>` +
                        `<green>${rgb1.g}</green>` +
                        `<blue>${rgb1.b}</blue>` +
                        `<xpar>0</xpar>` +
                    `</ColorSpec>`;

                    // index 1: 補間用（開始色）
                    colorSpecs += `<ColorSpec index="1">` +
                        `<red>${rgb1.r}</red>` +
                        `<green>${rgb1.g}</green>` +
                        `<blue>${rgb1.b}</blue>` +
                        `<xpar>0</xpar>` +
                    `</ColorSpec>`;

                    if (gradient.useColor3) {
                        // index 2: 中間色
                        const rgb3 = this._parseColor(gradient.color3 || '#ffaa00');
                        colorSpecs += `<ColorSpec index="2">` +
                            `<red>${rgb3.r}</red>` +
                            `<green>${rgb3.g}</green>` +
                            `<blue>${rgb3.b}</blue>` +
                            `<xpar>0</xpar>` +
                        `</ColorSpec>`;
                    } else {
                        // 中間色なし：補間
                        const midR = Math.round((rgb1.r + rgb2.r) / 2);
                        const midG = Math.round((rgb1.g + rgb2.g) / 2);
                        const midB = Math.round((rgb1.b + rgb2.b) / 2);
                        colorSpecs += `<ColorSpec index="2">` +
                            `<red>${midR}</red>` +
                            `<green>${midG}</green>` +
                            `<blue>${midB}</blue>` +
                            `<xpar>0</xpar>` +
                        `</ColorSpec>`;
                    }

                    // index 3: 補間用（終了色）
                    colorSpecs += `<ColorSpec index="3">` +
                        `<red>${rgb2.r}</red>` +
                        `<green>${rgb2.g}</green>` +
                        `<blue>${rgb2.b}</blue>` +
                        `<xpar>0</xpar>` +
                    `</ColorSpec>`;

                    // index 4: 終了色
                    colorSpecs += `<ColorSpec index="4">` +
                        `<red>${rgb2.r}</red>` +
                        `<green>${rgb2.g}</green>` +
                        `<blue>${rgb2.b}</blue>` +
                        `<xpar>0</xpar>` +
                    `</ColorSpec>`;
                } else {
                    // ベタ塗り設定
                    colorOption = 4;
                    rampType = 0;
                    rampAngle = 0;
                    rampPosTop = 75;
                    rampPosBottom = 25;

                    const rgb = this._parseColor(config.fillColor || '#ffffff');
                    for (let i = 0; i <= 4; i++) {
                        colorSpecs += `<ColorSpec index="${i}">` +
                            `<red>${rgb.r}</red>` +
                            `<green>${rgb.g}</green>` +
                            `<blue>${rgb.b}</blue>` +
                            `<xpar>0</xpar>` +
                        `</ColorSpec>`;
                    }
                }

                return `<Shader Version="4">` +
                    `<cReference>${shaderRef}</cReference>` +
                    `<textureRef>0</textureRef>` +
                    `<colorOption>${colorOption}</colorOption>` +
                    `<shaderOn>true</shaderOn>` +
                    `<glintSize>10</glintSize>` +
                    `<glintOffset>0</glintOffset>` +
                    `<rampPosTop>${rampPosTop}</rampPosTop>` +
                    `<rampPosBottom>${rampPosBottom}</rampPosBottom>` +
                    `<rampAngle>${rampAngle}</rampAngle>` +
                    `<bevelBalance>0</bevelBalance>` +
                    `<rampCycle>0</rampCycle>` +
                    `<classicStyle>0</classicStyle>` +
                    `<rampType>${rampType}</rampType>` +
                    colorSpecs +
                    `<glintAngle>0</glintAngle>` +
                    `<bevelSize>0</bevelSize>` +
                    `<bevelDirection>0</bevelDirection>` +
                    `<bevelPipe>false</bevelPipe>` +
                    `<bevelAngle>0</bevelAngle>` +
                    `<bevelShape>1</bevelShape>` +
                    `<bevelShining>0</bevelShining>` +
                    `<bevelLight>false</bevelLight>` +
                    `<bevelMerge>true</bevelMerge>` +
                    `<sheenOn>false</sheenOn>` +
                `</Shader>`;
            }

            _buildShadowShader(shaderRef, config) {
                const rgb = this._parseColor(config.shadow_color || '#000000');
                const opacity = config.shadow_opacity || 50;
                const xpar = Math.round((100 - opacity) * 255 / 100);

                let colorSpecs = '';
                for (let i = 0; i <= 4; i++) {
                    colorSpecs += `<ColorSpec index="${i}">` +
                        `<red>${rgb.r}</red>` +
                        `<green>${rgb.g}</green>` +
                        `<blue>${rgb.b}</blue>` +
                        `<xpar>${i === 0 ? xpar : 0}</xpar>` +
                    `</ColorSpec>`;
                }

                return `<Shader Version="4">` +
                    `<cReference>${shaderRef}</cReference>` +
                    `<textureRef>0</textureRef>` +
                    `<colorOption>0</colorOption>` +
                    `<shaderOn>true</shaderOn>` +
                    `<glintSize>0</glintSize>` +
                    `<glintOffset>0</glintOffset>` +
                    `<rampPosTop>75</rampPosTop>` +
                    `<rampPosBottom>25</rampPosBottom>` +
                    `<rampAngle>0</rampAngle>` +
                    `<bevelBalance>0</bevelBalance>` +
                    `<rampCycle>0</rampCycle>` +
                    `<classicStyle>0</classicStyle>` +
                    `<rampType>0</rampType>` +
                    colorSpecs +
                    `<glintAngle>0</glintAngle>` +
                    `<bevelSize>0</bevelSize>` +
                    `<bevelDirection>0</bevelDirection>` +
                    `<bevelPipe>false</bevelPipe>` +
                    `<bevelAngle>0</bevelAngle>` +
                    `<bevelShape>1</bevelShape>` +
                    `<bevelShining>0</bevelShining>` +
                    `<bevelLight>false</bevelLight>` +
                    `<bevelMerge>true</bevelMerge>` +
                    `<sheenOn>false</sheenOn>` +
                `</Shader>`;
            }

            _buildLayers(config) {
                const text = config.text || 'サンプル';
                const posX = config.posX || 960;
                const posY = config.posY || 540;
                const textAlign = config.textAlign || 'left';
                const styleRef = this.nextStyleID;
                const textRef = this.nextTextDescID;
                const fontSize = config.fontSize || 72;
                const txBase = fontSize * 1.2;
                const kerning = config.kerning || 0;

                return `<Layers>` +
                    `<Layer>` +
                        `<DrawPage></DrawPage>` +
                        `<TextPage>` +
                            `<TextChain>` +
                                `<ChainProperty>` +
                                    `<Position><x>${posX}</x><y>${posY}</y></Position>` +
                                    `<Size><x>1000</x><y>200</y></Size>` +
                                    `<wordWrap>false</wordWrap>` +
                                    `<Alignment>${textAlign}</Alignment>` +
                                `</ChainProperty>` +
                                `<ChainTabs></ChainTabs>` +
                                `<TextLine Version="2" objectID="1" persistentID="1">` +
                                    `<BaseProperties Version="5">` +
                                        `<txBase>${txBase}</txBase>` +
                                        `<XPos>${posX}</XPos>` +
                                        `<angle>0</angle>` +
                                        `<verticalText>false</verticalText>` +
                                        `<objectLeading>0</objectLeading>` +
                                    `</BaseProperties>` +
                                    `<EnclosingObjectType>block</EnclosingObjectType>` +
                                    `<Alignment>${textAlign}</Alignment>` +
                                    `<RTL>false</RTL>` +
                                    `<TRString>${this._escapeXML(text)}</TRString>` +
                                    `<RunLengthEncodedCharacterAttributes>` +
                                        `<CharacterAttributes ` +
                                            `RunCount="${text.length}" ` +
                                            `StyleRef="${styleRef}" ` +
                                            `TextRef="${textRef}" ` +
                                            `TXKerning="${kerning}" ` +
                                            `TXPostKerning="${kerning}" ` +
                                            `BaselineShifting="0" />` +
                                    `</RunLengthEncodedCharacterAttributes>` +
                                    `<tagName></tagName>` +
                                `</TextLine>` +
                            `</TextChain>` +
                        `</TextPage>` +
                        `<MergeGroups></MergeGroups>` +
                    `</Layer>` +
                `</Layers>`;
            }

            _buildTextures() {
                return `<Textures></Textures>`;
            }

            _buildLogos() {
                return `<Logos></Logos>`;
            }

            _buildVLS() {
                return `<VLS>` +
                    `<FileReference Version="1">` +
                        `<fileString></fileString>` +
                        `<seClass>2</seClass>` +
                        `<seCode>1000</seCode>` +
                    `</FileReference>` +
                `</VLS>`;
            }

            _parseColor(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : { r: 255, g: 255, b: 255 };
            }

            _escapeXML(str) {
                if (!str) return '';
                return String(str)
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&apos;');
            }
        }

        // 整列関数
        function alignCenter() {
            if (!selectedObject) {
                alert('オブジェクトを選択してください');
                return;
            }

            const metrics = measureText(selectedObject);
            selectedObject.x = (canvas.width - metrics.width) / 2;
            updatePropertiesPanel();
            render();
        }

        function alignMiddle() {
            if (!selectedObject) {
                alert('オブジェクトを選択してください');
                return;
            }

            const metrics = measureText(selectedObject);
            selectedObject.y = (canvas.height - metrics.height) / 2 + metrics.height;
            updatePropertiesPanel();
            render();
        }

        // レイヤー管理関数
        function bringToFront() {
            if (!selectedObject) return;

            // テキストオブジェクトの場合
            const textIndex = textObjects.indexOf(selectedObject);
            if (textIndex > -1 && textIndex < textObjects.length - 1) {
                textObjects.splice(textIndex, 1);
                textObjects.push(selectedObject);
                render();
                return;
            }

            // 図形オブジェクトの場合
            const shapeIndex = shapeObjects.indexOf(selectedObject);
            if (shapeIndex > -1 && shapeIndex < shapeObjects.length - 1) {
                shapeObjects.splice(shapeIndex, 1);
                shapeObjects.push(selectedObject);
                render();
            }
        }

        function sendToBack() {
            if (!selectedObject) return;

            // テキストオブジェクトの場合
            const textIndex = textObjects.indexOf(selectedObject);
            if (textIndex > 0) {
                textObjects.splice(textIndex, 1);
                textObjects.unshift(selectedObject);
                render();
                return;
            }

            // 図形オブジェクトの場合
            const shapeIndex = shapeObjects.indexOf(selectedObject);
            if (shapeIndex > 0) {
                shapeObjects.splice(shapeIndex, 1);
                shapeObjects.unshift(selectedObject);
                render();
            }
        }

        function bringForward() {
            if (!selectedObject) return;

            // テキストオブジェクトの場合
            const textIndex = textObjects.indexOf(selectedObject);
            if (textIndex > -1 && textIndex < textObjects.length - 1) {
                const temp = textObjects[textIndex + 1];
                textObjects[textIndex + 1] = textObjects[textIndex];
                textObjects[textIndex] = temp;
                render();
                return;
            }

            // 図形オブジェクトの場合
            const shapeIndex = shapeObjects.indexOf(selectedObject);
            if (shapeIndex > -1 && shapeIndex < shapeObjects.length - 1) {
                const temp = shapeObjects[shapeIndex + 1];
                shapeObjects[shapeIndex + 1] = shapeObjects[shapeIndex];
                shapeObjects[shapeIndex] = temp;
                render();
            }
        }

        function sendBackward() {
            if (!selectedObject) return;

            // テキストオブジェクトの場合
            const textIndex = textObjects.indexOf(selectedObject);
            if (textIndex > 0) {
                const temp = textObjects[textIndex - 1];
                textObjects[textIndex - 1] = textObjects[textIndex];
                textObjects[textIndex] = temp;
                render();
                return;
            }

            // 図形オブジェクトの場合
            const shapeIndex = shapeObjects.indexOf(selectedObject);
            if (shapeIndex > 0) {
                const temp = shapeObjects[shapeIndex - 1];
                shapeObjects[shapeIndex - 1] = shapeObjects[shapeIndex];
                shapeObjects[shapeIndex] = temp;
                render();
            }
        }

        // ビューコントロール関数
        function zoomIn() {
            viewportScale *= 1.2;
            applyViewportTransform();
        }

        function zoomOut() {
            viewportScale /= 1.2;
            applyViewportTransform();
        }

        function fitToScreen() {
            const container = document.querySelector('.canvas-area');
            const scaleX = (container.clientWidth - 40) / canvas.width;
            const scaleY = (container.clientHeight - 40) / canvas.height;
            viewportScale = Math.min(scaleX, scaleY);
            viewportOffsetX = 0;
            viewportOffsetY = 0;
            applyViewportTransform();
        }

        function resetView() {
            viewportScale = 1;
            viewportOffsetX = 0;
            viewportOffsetY = 0;
            applyViewportTransform();
        }

        function applyViewportTransform() {
            canvas.style.transform = `scale(${viewportScale}) translate(${viewportOffsetX}px, ${viewportOffsetY}px)`;
        }

        // キーボードショートカット
        document.addEventListener('keydown', (e) => {
            // IME入力中はショートカットを無効化
            if (isTyping) return;

            if (e.ctrlKey || e.metaKey) {
                // ズーム・ビュー操作
                if (e.key === '=' || e.key === '+') {
                    e.preventDefault();
                    zoomIn();
                } else if (e.key === '-') {
                    e.preventDefault();
                    zoomOut();
                } else if (e.key === '0') {
                    e.preventDefault();
                    fitToScreen();
                } else if (e.key === 'r' || e.key === 'R') {
                    e.preventDefault();
                    resetView();
                }
                // レイヤー管理
                else if (e.key === ']') {
                    e.preventDefault();
                    bringToFront();
                } else if (e.key === '[') {
                    e.preventDefault();
                    sendToBack();
                }
            } else {
                // 「T」キーでパスを確定してテキスト入力開始
                if ((e.key === 't' || e.key === 'T') && isDrawingPath && currentPath) {
                    e.preventDefault();
                    // パスを確定
                    if (currentPath.anchors.length >= 2) {
                        shapeObjects.push(currentPath);
                        console.log('パスを確定しました。テキスト入力を開始します。');
                    }
                    isDrawingPath = false;
                    currentPath = null;
                    selectedAnchorIndex = -1;
                    isDraggingHandle = false;
                    render();

                    // テキストツールに切り替えてユーザーに通知
                    switchTool('text');
                    // ステータスメッセージを表示（3秒間）
                    showStatusMessage('パスを確定しました。テキストツールに切り替わりました。');
                    return;
                }

                // ツール切り替え
                if (e.key === 'v' || e.key === 'V') {
                    switchTool('select');
                } else if (e.key === 'T' && e.shiftKey) {
                    switchTool('pathText');
                } else if (e.key === 't' || e.key === 'T') {
                    switchTool('text');
                } else if (e.key === 'r' || e.key === 'R') {
                    switchTool('rectangle');
                } else if (e.key === 'u' || e.key === 'U') {
                    switchTool('roundRect');
                } else if (e.key === 'e' || e.key === 'E') {
                    switchTool('ellipse');
                } else if (e.key === 'l' || e.key === 'L') {
                    switchTool('line');
                } else if (e.key === 'p' || e.key === 'P') {
                    switchTool('pen');
                } else if (e.key === 'b' || e.key === 'B') {
                    switchTool('chamferRect');
                } else if (e.key === 'a' || e.key === 'A') {
                    switchTool('triangle');
                } else if (e.key === 'c' || e.key === 'C') {
                    switchTool('arc');
                }
            }
        });

        // 初期表示を画面に合わせる
        setTimeout(fitToScreen, 100);

        // 初期レンダリング
        render();
    </script>

    <!-- ステータスメッセージ -->
    <div id="statusMessage" class="status-message"></div>

    <script>
        // ステータスメッセージを表示する関数
        function showStatusMessage(message, duration = 3000) {
            const statusEl = document.getElementById('statusMessage');
            statusEl.textContent = message;
            statusEl.classList.add('show');

            setTimeout(() => {
                statusEl.classList.remove('show');
            }, duration);
        }
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NLT - Neo Legacy Title Generator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: #1e1e1e;
            color: #fff;
            padding: 20px;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 20px;
        }
        .panel {
            background: #2d2d2d;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        h1 {
            font-size: 24px;
            margin-bottom: 20px;
            color: #4a9eff;
        }
        h2 {
            font-size: 16px;
            margin: 20px 0 10px;
            color: #aaa;
            border-bottom: 1px solid #444;
            padding-bottom: 5px;
        }
        .control-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 13px;
            color: #aaa;
        }
        input[type="text"],
        input[type="number"],
        select,
        textarea {
            width: 100%;
            padding: 8px;
            background: #1e1e1e;
            border: 1px solid #444;
            border-radius: 4px;
            color: #fff;
            font-size: 14px;
        }
        textarea {
            resize: vertical;
            min-height: 80px;
            font-family: inherit;
        }
        input[type="color"] {
            width: 100%;
            height: 40px;
            border: 1px solid #444;
            border-radius: 4px;
            cursor: pointer;
        }
        input[type="range"] {
            width: 100%;
        }
        button {
            width: 100%;
            padding: 12px;
            background: #4a9eff;
            border: none;
            border-radius: 4px;
            color: #fff;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
        }
        button:hover {
            background: #3a8eef;
        }
        button:active {
            transform: scale(0.98);
        }
        .btn-secondary {
            background: #555;
            margin-top: 10px;
        }
        .btn-secondary:hover {
            background: #666;
        }
        #canvas {
            border: 1px solid #444;
            border-radius: 4px;
            max-width: 100%;
            display: block;
        }
        .canvas-wrapper {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 600px;
            background: #1e1e1e;
            border-radius: 4px;
        }
        .color-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .checkbox-group input[type="checkbox"] {
            width: auto;
        }
        .value-display {
            font-size: 12px;
            color: #888;
            margin-top: 2px;
        }
        .gradient-stops {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 10px;
        }
        .gradient-stop {
            display: grid;
            grid-template-columns: 60px 1fr auto;
            gap: 10px;
            align-items: center;
        }
        .gradient-stop input[type="number"] {
            width: 100%;
        }
        .resolution-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- 左パネル: コントロール -->
        <div class="panel">
            <h1>NLT Generator</h1>

            <h2>解像度</h2>
            <div class="resolution-group">
                <div class="control-group">
                    <label>幅</label>
                    <input type="number" id="canvasWidth" value="1920" min="1">
                </div>
                <div class="control-group">
                    <label>高さ</label>
                    <input type="number" id="canvasHeight" value="1080" min="1">
                </div>
            </div>

            <h2>テキスト</h2>
            <div class="control-group">
                <label>テキスト内容</label>
                <textarea id="textContent">レガシータイトル</textarea>
            </div>

            <div class="control-group">
                <label>フォント</label>
                <select id="fontFamily">
                    <option value="Yu Gothic UI">Yu Gothic UI</option>
                    <option value="Arial">Arial</option>
                    <option value="Meiryo">Meiryo</option>
                    <option value="MS Gothic">MS Gothic</option>
                    <option value="Hiragino Sans">Hiragino Sans</option>
                </select>
            </div>

            <div class="control-group">
                <label>フォントサイズ (pt)</label>
                <input type="number" id="fontSize" value="72" min="1" max="500">
            </div>

            <div class="control-group">
                <label>横幅スケール (%)</label>
                <input type="range" id="scaleX" value="100" min="10" max="200" step="1">
                <div class="value-display" id="scaleXValue">100%</div>
            </div>

            <h2>位置とアライメント</h2>
            <div class="control-group">
                <label>水平位置</label>
                <input type="number" id="posX" value="960" step="1">
            </div>

            <div class="control-group">
                <label>垂直位置</label>
                <input type="number" id="posY" value="540" step="1">
            </div>

            <div class="control-group">
                <label>テキストアライメント</label>
                <select id="textAlign">
                    <option value="left">左揃え (left)</option>
                    <option value="center" selected>中央揃え (center)</option>
                    <option value="right">右揃え (right)</option>
                </select>
            </div>

            <h2>塗りスタイル</h2>
            <div class="control-group">
                <label>塗りタイプ</label>
                <select id="fillType">
                    <option value="solid" selected>単色 (Solid)</option>
                    <option value="gradient-linear">線形グラデーション (Linear)</option>
                    <option value="gradient-radial">円形グラデーション (Radial)</option>
                    <option value="sheen">光沢 (Sheen)</option>
                </select>
            </div>

            <div id="solidControls">
                <div class="control-group">
                    <label>塗り色</label>
                    <input type="color" id="fillColor" value="#fdff00">
                </div>
            </div>

            <div id="gradientControls" style="display: none;">
                <div class="gradient-stops">
                    <div class="gradient-stop">
                        <label>開始</label>
                        <input type="color" id="gradientStart" value="#ff0000">
                        <span>0%</span>
                    </div>
                    <div class="gradient-stop">
                        <label>中間</label>
                        <input type="color" id="gradientMiddle" value="#ffff00">
                        <span>50%</span>
                    </div>
                    <div class="gradient-stop">
                        <label>終端</label>
                        <input type="color" id="gradientEnd" value="#0000ff">
                        <span>100%</span>
                    </div>
                </div>
                <div class="control-group">
                    <label>グラデーション角度 (度)</label>
                    <input type="range" id="gradientAngle" value="0" min="0" max="360" step="1">
                    <div class="value-display" id="gradientAngleValue">0°</div>
                </div>
            </div>

            <div id="sheenControls" style="display: none;">
                <div class="control-group">
                    <label>ベース色</label>
                    <input type="color" id="sheenBase" value="#000000">
                </div>
                <div class="control-group">
                    <label>ハイライト色</label>
                    <input type="color" id="sheenHighlight" value="#ffffff">
                </div>
                <div class="control-group">
                    <label>光沢サイズ (0-100)</label>
                    <input type="range" id="glintSize" value="10" min="0" max="100" step="1">
                    <div class="value-display" id="glintSizeValue">10</div>
                </div>
                <div class="control-group">
                    <label>光沢角度 (度)</label>
                    <input type="range" id="glintAngle" value="0" min="0" max="360" step="1">
                    <div class="value-display" id="glintAngleValue">0°</div>
                </div>
            </div>

            <h2>ストローク（フラグメント）</h2>
            <div class="control-group">
                <label>プリセット</label>
                <select id="strokePreset" onchange="applyStrokePreset()">
                    <option value="custom">カスタム</option>
                    <option value="legacy-standard" selected>レガシー標準（4層）</option>
                    <option value="simple">シンプル（2層）</option>
                    <option value="none">ストロークなし</option>
                </select>
            </div>

            <!-- インナーストローク4 -->
            <div class="control-group">
                <div class="checkbox-group">
                    <input type="checkbox" id="stroke4_enabled" checked>
                    <label>インナーストローク4</label>
                </div>
                <div class="color-row">
                    <div>
                        <label>サイズ (pt)</label>
                        <input type="number" id="stroke4_size" value="78" min="0" max="200">
                    </div>
                    <div>
                        <label>色</label>
                        <input type="color" id="stroke4_color" value="#000000">
                    </div>
                </div>
            </div>

            <!-- インナーストローク3 -->
            <div class="control-group">
                <div class="checkbox-group">
                    <input type="checkbox" id="stroke3_enabled" checked>
                    <label>インナーストローク3</label>
                </div>
                <div class="color-row">
                    <div>
                        <label>サイズ (pt)</label>
                        <input type="number" id="stroke3_size" value="68" min="0" max="200">
                    </div>
                    <div>
                        <label>色</label>
                        <input type="color" id="stroke3_color" value="#000000">
                    </div>
                </div>
            </div>

            <!-- インナーストローク2 -->
            <div class="control-group">
                <div class="checkbox-group">
                    <input type="checkbox" id="stroke2_enabled" checked>
                    <label>インナーストローク2</label>
                </div>
                <div class="color-row">
                    <div>
                        <label>サイズ (pt)</label>
                        <input type="number" id="stroke2_size" value="38" min="0" max="200">
                    </div>
                    <div>
                        <label>色</label>
                        <input type="color" id="stroke2_color" value="#ffffff">
                    </div>
                </div>
            </div>

            <!-- インナーストローク1 -->
            <div class="control-group">
                <div class="checkbox-group">
                    <input type="checkbox" id="stroke1_enabled" checked>
                    <label>インナーストローク1</label>
                </div>
                <div class="color-row">
                    <div>
                        <label>サイズ (pt)</label>
                        <input type="number" id="stroke1_size" value="8" min="0" max="200">
                    </div>
                    <div>
                        <label>色</label>
                        <input type="color" id="stroke1_color" value="#000000">
                    </div>
                </div>
            </div>

            <!-- シャドウ -->
            <div class="control-group">
                <div class="checkbox-group">
                    <input type="checkbox" id="shadow_enabled">
                    <label>シャドウ</label>
                </div>
                <div class="color-row">
                    <div>
                        <label>オフセット</label>
                        <input type="number" id="shadow_offset" value="10" min="0" max="100">
                    </div>
                    <div>
                        <label>角度 (度)</label>
                        <input type="number" id="shadow_angle" value="-45" min="-180" max="180">
                    </div>
                </div>
                <div class="control-group">
                    <label>シャドウ色</label>
                    <input type="color" id="shadow_color" value="#000000">
                </div>
                <div class="control-group">
                    <label>不透明度 (%)</label>
                    <input type="range" id="shadow_opacity" value="50" min="0" max="100" step="1">
                    <div class="value-display" id="shadowOpacityValue">50%</div>
                </div>
            </div>

            <button onclick="updatePreview()">プレビュー更新</button>
            <button onclick="exportPRTL()">PRTL書き出し</button>
            <button class="btn-secondary" onclick="testPRTL()">PRTL構造テスト</button>
        </div>

        <!-- 右パネル: プレビュー -->
        <div class="panel">
            <h1>プレビュー</h1>
            <div class="canvas-wrapper">
                <canvas id="canvas" width="1920" height="1080"></canvas>
            </div>
        </div>
    </div>

    <script>
        // グローバル変数
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // UIイベントリスナー
        document.getElementById('fillType').addEventListener('change', function() {
            const fillType = this.value;
            document.getElementById('solidControls').style.display = fillType === 'solid' ? 'block' : 'none';
            document.getElementById('gradientControls').style.display = fillType.startsWith('gradient') ? 'block' : 'none';
            document.getElementById('sheenControls').style.display = fillType === 'sheen' ? 'block' : 'none';
        });

        document.getElementById('scaleX').addEventListener('input', function() {
            document.getElementById('scaleXValue').textContent = this.value + '%';
        });

        document.getElementById('gradientAngle').addEventListener('input', function() {
            document.getElementById('gradientAngleValue').textContent = this.value + '°';
        });

        document.getElementById('glintSize').addEventListener('input', function() {
            document.getElementById('glintSizeValue').textContent = this.value;
        });

        document.getElementById('glintAngle').addEventListener('input', function() {
            document.getElementById('glintAngleValue').textContent = this.value + '°';
        });

        document.getElementById('canvasWidth').addEventListener('change', function() {
            canvas.width = parseInt(this.value);
            updatePreview();
        });

        document.getElementById('canvasHeight').addEventListener('change', function() {
            canvas.height = parseInt(this.value);
            updatePreview();
        });

        document.getElementById('shadow_opacity').addEventListener('input', function() {
            document.getElementById('shadowOpacityValue').textContent = this.value + '%';
        });

        /**
         * ストロークプリセットを適用
         */
        function applyStrokePreset() {
            const preset = document.getElementById('strokePreset').value;

            if (preset === 'legacy-standard') {
                // レガシー標準（4層）- 参考PRTLの標準設定
                document.getElementById('stroke4_enabled').checked = true;
                document.getElementById('stroke4_size').value = 78;
                document.getElementById('stroke4_color').value = '#000000';

                document.getElementById('stroke3_enabled').checked = true;
                document.getElementById('stroke3_size').value = 68;
                document.getElementById('stroke3_color').value = '#000000';

                document.getElementById('stroke2_enabled').checked = true;
                document.getElementById('stroke2_size').value = 38;
                document.getElementById('stroke2_color').value = '#ffffff';

                document.getElementById('stroke1_enabled').checked = true;
                document.getElementById('stroke1_size').value = 8;
                document.getElementById('stroke1_color').value = '#000000';

                document.getElementById('shadow_enabled').checked = false;
            } else if (preset === 'simple') {
                // シンプル（2層）
                document.getElementById('stroke4_enabled').checked = false;
                document.getElementById('stroke3_enabled').checked = false;

                document.getElementById('stroke2_enabled').checked = true;
                document.getElementById('stroke2_size').value = 30;
                document.getElementById('stroke2_color').value = '#000000';

                document.getElementById('stroke1_enabled').checked = true;
                document.getElementById('stroke1_size').value = 10;
                document.getElementById('stroke1_color').value = '#ffffff';

                document.getElementById('shadow_enabled').checked = false;
            } else if (preset === 'none') {
                // ストロークなし
                document.getElementById('stroke4_enabled').checked = false;
                document.getElementById('stroke3_enabled').checked = false;
                document.getElementById('stroke2_enabled').checked = false;
                document.getElementById('stroke1_enabled').checked = false;
                document.getElementById('shadow_enabled').checked = false;
            }

            updatePreview();
        }

        /**
         * PRTLGeneratorV2 - 完全新規実装版
         * PRTL仕様書CGPT03.txtに完全準拠した実装
         */
        class PRTLGeneratorV2 {
            constructor() {
                this.nextStyleID = 4096;
                this.nextShaderID = 4096;
                this.nextTextDescID = 4096;
            }

            /**
             * テキストオブジェクトからPRTLを生成
             */
            generatePRTL(config) {
                const width = config.width || 1920;
                const height = config.height || 1080;

                // 各セクションを生成
                const textDescriptions = this._buildTextDescriptions(config);
                const shaders = this._buildShaders(config);
                const styles = this._buildStyles(config);
                const layers = this._buildLayers(config);

                // 完全なPRTL XMLを構築
                return this._buildPRTLDocument(width, height, textDescriptions, shaders, styles, layers);
            }

            /**
             * PRTL XMLドキュメントの構築
             */
            _buildPRTLDocument(width, height, textDescriptions, shaders, styles, layers) {
                return `<?xml version="1.0" encoding="UTF-16" ?>` +
                    `<Adobe_Root>` +
                        `<Adobe_Title>` +
                            `<Version>20080702</Version>` +
                            `<Motion_Settings>` +
                                `<Play_Forward>true</Play_Forward>` +
                                `<Start_on_Screen>false</Start_on_Screen>` +
                                `<Pre_Roll>0</Pre_Roll>` +
                                `<Ease_In>0</Ease_In>` +
                                `<End_off_Screen>false</End_off_Screen>` +
                                `<Post_Roll>0</Post_Roll>` +
                                `<Ease_Out>0</Ease_Out>` +
                            `</Motion_Settings>` +
                        `</Adobe_Title>` +
                        `<InscriberLayouts Version="1.0">` +
                            `<Layout>` +
                                this._buildLayoutHeader(width, height) +
                                textDescriptions +
                                styles +
                                shaders +
                                this._buildTextures() +
                                this._buildLogos() +
                                layers +
                                this._buildVLS() +
                            `</Layout>` +
                        `</InscriberLayouts>` +
                    `</Adobe_Root>`;
            }

            /**
             * Layoutヘッダー部分
             */
            _buildLayoutHeader(width, height) {
                return `<LayoutEffectInfo Version="2">` +
                        `<EffectType>0</EffectType>` +
                        `<Indic>false</Indic>` +
                        `<Ligatures>false</Ligatures>` +
                        `<HindiDigits>false</HindiDigits>` +
                    `</LayoutEffectInfo>` +
                    `<LayoutDimension Version="2">` +
                        `<pXPIXELS>${width}</pXPIXELS>` +
                        `<pYLINES>${height}</pYLINES>` +
                        `<pSCREENAR>1</pSCREENAR>` +
                        `<growthDirection>growRightDown</growthDirection>` +
                    `</LayoutDimension>` +
                    `<LayoutAttributes>` +
                        `<SafeTitleArea>` +
                            `<left>0.1</left><top>0.1</top><right>0.9</right><bottom>0.9</bottom>` +
                        `</SafeTitleArea>` +
                        `<SafeActionArea>` +
                            `<left>0.05</left><top>0.05</top><right>0.95</right><bottom>0.95</bottom>` +
                        `</SafeActionArea>` +
                    `</LayoutAttributes>` +
                    `<Background Version="4">` +
                        `<ShaderReference>4098</ShaderReference>` +
                        `<On>false</On>` +
                        `<paintingRange>normalLayout</paintingRange>` +
                    `</Background>` +
                    `<DefaultStyle><Reference>${this.nextStyleID}</Reference></DefaultStyle>` +
                    `<DefaultTextDescription><Reference>${this.nextTextDescID}</Reference></DefaultTextDescription>` +
                    `<GraphicObjectDefaults>` +
                        `<endCapType>square</endCapType>` +
                        `<joinTypeClosed>round</joinTypeClosed>` +
                        `<joinTypeOpen>round</joinTypeOpen>` +
                        `<lineWidth>5</lineWidth>` +
                        `<miterLimit>5</miterLimit>` +
                        `<windBeziers>false</windBeziers>` +
                        `<roundCornerFillets>37.5 37.5 37.5 37.5 37.5 37.5 37.5 37.5 </roundCornerFillets>` +
                        `<clippedCornerFillets>37.5 37.5 37.5 37.5 37.5 37.5 37.5 37.5 </clippedCornerFillets>` +
                    `</GraphicObjectDefaults>` +
                    this._buildTextChainDefaults();
            }

            /**
             * TextChainDefaults
             */
            _buildTextChainDefaults() {
                const defaults = `<leading>0</leading>` +
                    `<boxCanGrow>false</boxCanGrow>` +
                    `<wordWrap>true</wordWrap>` +
                    `<lockedLinesX>false</lockedLinesX>` +
                    `<lockedLinesY>false</lockedLinesY>` +
                    `<Alignment>left</Alignment>` +
                    `<tabModeStyle>Word</tabModeStyle>` +
                    `<implicitTabSpacing>100</implicitTabSpacing>` +
                    `<implicitTabType>left</implicitTabType>` +
                    `<rtl>false</rtl>` +
                    `<tabs></tabs>`;

                return `<TextChainDefaults>` +
                    `<normal>${defaults}</normal>` +
                    `<boxNormal>${defaults.replace('<wordWrap>true</wordWrap>', '<wordWrap>true</wordWrap>').replace('<lockedLinesX>false</lockedLinesX>', '<lockedLinesX>true</lockedLinesX>').replace('<lockedLinesY>false</lockedLinesY>', '<lockedLinesY>true</lockedLinesY>')}</boxNormal>` +
                    `<blockNormal>${defaults.replace('<wordWrap>true</wordWrap>', '<wordWrap>false</wordWrap>').replace('<lockedLinesX>false</lockedLinesX>', '<lockedLinesX>true</lockedLinesX>').replace('<lockedLinesY>false</lockedLinesY>', '<lockedLinesY>true</lockedLinesY>')}</blockNormal>` +
                    `<spline>${defaults}</spline>` +
                `</TextChainDefaults>`;
            }

            /**
             * TextDescriptions生成
             */
            _buildTextDescriptions(config) {
                const ref = this.nextTextDescID;
                const fontFamily = config.fontFamily || 'Yu Gothic UI';
                const fontSize = config.fontSize || 72;
                const scaleX = config.scaleX || 100;

                return `<TextDescriptions Version="4">` +
                    `<TextDescription Reference="${ref}">` +
                        `<TypeSpec>` +
                            `<size>${fontSize * 8}</size>` +
                            `<txHeight>${fontSize}</txHeight>` +
                            `<txKern>0</txKern>` +
                            `<baselineShift>0</baselineShift>` +
                            `<leading>0</leading>` +
                            `<txSCaps>${fontSize}</txSCaps>` +
                            `<txSCapsOn>false</txSCapsOn>` +
                            `<txSlant>0</txSlant>` +
                            `<txUnderline>false</txUnderline>` +
                            `<txWidth>${scaleX}</txWidth>` +
                            `<linked>false</linked>` +
                            `<fiBold>0</fiBold>` +
                            `<fiItalic>0</fiItalic>` +
                            `<fifullName>${this._escapeXML(fontFamily)}</fifullName>` +
                            `<fifontFamilyName>${this._escapeXML(fontFamily)}</fifontFamilyName>` +
                            `<fifontStyle>Regular</fifontStyle>` +
                            `<fifontType>5</fifontType>` +
                            `<ficategory>1</ficategory>` +
                        `</TypeSpec>` +
                    `</TextDescription>` +
                `</TextDescriptions>`;
            }

            /**
             * Styles生成
             */
            _buildStyles(config) {
                const styleID = this.nextStyleID;
                const textDescRef = this.nextTextDescID;

                // FragmentListを構築（レガシータイトル仕様）
                let fragments = '';
                let shaderRefs = {};
                let nextPainter = 10; // Painter 10から開始
                let nextShaderRef = this.nextShaderID;

                // インナーストローク4（最外層）
                if (config.stroke4_enabled) {
                    fragments += `<Fragment>` +
                        `<size>${config.stroke4_size}</size>` +
                        `<offset>0</offset>` +
                        `<angle>0</angle>` +
                        `<ghost>false</ghost>` +
                        `<isExtendedShadowFragment>false</isExtendedShadowFragment>` +
                        `<eFragmentType>2</eFragmentType>` +
                        `<fragmentOff>false</fragmentOff>` +
                        `<placeHolder>false</placeHolder>` +
                        `<annotation>4</annotation>` +
                        `<placeHolderShaderIndex>4294967295</placeHolderShaderIndex>` +
                        `<painterMix>${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} </painterMix>` +
                    `</Fragment>`;
                    shaderRefs[nextPainter++] = nextShaderRef++;
                }

                // インナーストローク3
                if (config.stroke3_enabled) {
                    fragments += `<Fragment>` +
                        `<size>${config.stroke3_size}</size>` +
                        `<offset>0</offset>` +
                        `<angle>0</angle>` +
                        `<ghost>false</ghost>` +
                        `<isExtendedShadowFragment>false</isExtendedShadowFragment>` +
                        `<eFragmentType>2</eFragmentType>` +
                        `<fragmentOff>false</fragmentOff>` +
                        `<placeHolder>false</placeHolder>` +
                        `<annotation>3</annotation>` +
                        `<placeHolderShaderIndex>4294967295</placeHolderShaderIndex>` +
                        `<painterMix>${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} </painterMix>` +
                    `</Fragment>`;
                    shaderRefs[nextPainter++] = nextShaderRef++;
                }

                // インナーストローク2
                if (config.stroke2_enabled) {
                    fragments += `<Fragment>` +
                        `<size>${config.stroke2_size}</size>` +
                        `<offset>0</offset>` +
                        `<angle>0</angle>` +
                        `<ghost>false</ghost>` +
                        `<isExtendedShadowFragment>false</isExtendedShadowFragment>` +
                        `<eFragmentType>2</eFragmentType>` +
                        `<fragmentOff>false</fragmentOff>` +
                        `<placeHolder>false</placeHolder>` +
                        `<annotation>2</annotation>` +
                        `<placeHolderShaderIndex>4294967295</placeHolderShaderIndex>` +
                        `<painterMix>${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} </painterMix>` +
                    `</Fragment>`;
                    shaderRefs[nextPainter++] = nextShaderRef++;
                }

                // インナーストローク1
                if (config.stroke1_enabled) {
                    fragments += `<Fragment>` +
                        `<size>${config.stroke1_size}</size>` +
                        `<offset>0</offset>` +
                        `<angle>0</angle>` +
                        `<ghost>false</ghost>` +
                        `<isExtendedShadowFragment>false</isExtendedShadowFragment>` +
                        `<eFragmentType>2</eFragmentType>` +
                        `<fragmentOff>false</fragmentOff>` +
                        `<placeHolder>false</placeHolder>` +
                        `<annotation>1</annotation>` +
                        `<placeHolderShaderIndex>4294967295</placeHolderShaderIndex>` +
                        `<painterMix>${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} ${nextPainter} </painterMix>` +
                    `</Fragment>`;
                    shaderRefs[nextPainter++] = nextShaderRef++;
                }

                // フェース（塗り本体）- Painter 15
                fragments += `<Fragment>` +
                    `<size>0</size>` +
                    `<offset>0</offset>` +
                    `<angle>0</angle>` +
                    `<ghost>false</ghost>` +
                    `<isExtendedShadowFragment>false</isExtendedShadowFragment>` +
                    `<eFragmentType>0</eFragmentType>` +
                    `<fragmentOff>false</fragmentOff>` +
                    `<placeHolder>false</placeHolder>` +
                    `<annotation>65538</annotation>` +
                    `<placeHolderShaderIndex>4294967295</placeHolderShaderIndex>` +
                    `<painterMix>15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 </painterMix>` +
                `</Fragment>`;
                shaderRefs[15] = nextShaderRef++; // フェース用シェーダー

                // シャドウ
                const shadowOff = config.shadow_enabled ? 'false' : 'true';
                fragments += `<Fragment>` +
                    `<size>0</size>` +
                    `<offset>${config.shadow_offset || 10}</offset>` +
                    `<angle>${config.shadow_angle || -45}</angle>` +
                    `<ghost>false</ghost>` +
                    `<isExtendedShadowFragment>true</isExtendedShadowFragment>` +
                    `<eFragmentType>0</eFragmentType>` +
                    `<fragmentOff>${shadowOff}</fragmentOff>` +
                    `<placeHolder>false</placeHolder>` +
                    `<annotation>65537</annotation>` +
                    `<placeHolderShaderIndex>4294967295</placeHolderShaderIndex>` +
                    `<painterMix>0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 </painterMix>` +
                `</Fragment>`;
                if (config.shadow_enabled) {
                    shaderRefs[0] = nextShaderRef++; // シャドウ用シェーダー
                }

                // ShaderListを構築
                let shaderList = '';
                for (let i = 0; i <= 15; i++) {
                    const ref = shaderRefs[i] || 0;
                    shaderList += `<ShaderRef PainterNumber="${i}"><shaderRef>${ref}</shaderRef></ShaderRef>`;
                }
                shaderList += `<ShaderRef PainterNumber="-1"><shaderRef>0</shaderRef></ShaderRef>`;

                // configにshaderRefsを保存（_buildShadersで使用）
                config._shaderRefs = shaderRefs;
                config._nextShaderRef = nextShaderRef;

                return `<Styles>` +
                    `<Style ID="${styleID}">` +
                        `<StyleBase Version="4">` +
                            `<type>50000</type>` +
                            `<positionDominance>0</positionDominance>` +
                            `<lineGradient>false</lineGradient>` +
                            `<styleRef>${styleID}</styleRef>` +
                            `<faceDistortX>0</faceDistortX>` +
                            `<faceDistortY>0</faceDistortY>` +
                            `<shadow_softness>30</shadow_softness>` +
                            `<personality>0</personality>` +
                            `<linked>false</linked>` +
                            `<EmbellishmentSizeRule>false</EmbellishmentSizeRule>` +
                            `<PainterRampType>Basic</PainterRampType>` +
                        `</StyleBase>` +
                        `<FragmentList Version="5">` +
                            fragments +
                        `</FragmentList>` +
                        `<ShaderList Version="1">` +
                            shaderList +
                        `</ShaderList>` +
                    `</Style>` +
                `</Styles>`;
            }

            /**
             * Shaders生成（複数フラグメント対応）
             */
            _buildShaders(config) {
                let shaders = '<Shaders>';
                const shaderRefs = config._shaderRefs || {};

                // 各PainterのShaderを生成
                for (const [painter, shaderRef] of Object.entries(shaderRefs)) {
                    const painterNum = parseInt(painter);

                    if (painterNum === 15) {
                        // フェース（塗り本体）
                        shaders += this._buildFaceShader(shaderRef, config);
                    } else if (painterNum === 0) {
                        // シャドウ
                        shaders += this._buildShadowShader(shaderRef, config);
                    } else if (painterNum >= 10 && painterNum <= 13) {
                        // ストローク層
                        const strokeNum = 14 - painterNum; // 10->4, 11->3, 12->2, 13->1
                        const strokeColor = config[`stroke${strokeNum}_color`] || '#000000';
                        shaders += this._buildStrokeShader(shaderRef, strokeColor);
                    }
                }

                shaders += '</Shaders>';
                return shaders;
            }

            /**
             * ストローク用Shader生成
             */
            _buildStrokeShader(shaderRef, color) {
                const rgb = this._parseColor(color);

                let colorSpecs = '';
                for (let i = 0; i <= 4; i++) {
                    colorSpecs += `<ColorSpec index="${i}">` +
                        `<red>${rgb.r}</red>` +
                        `<green>${rgb.g}</green>` +
                        `<blue>${rgb.b}</blue>` +
                        `<xpar>0</xpar>` +
                    `</ColorSpec>`;
                }

                return `<Shader Version="4">` +
                    `<cReference>${shaderRef}</cReference>` +
                    `<textureRef>0</textureRef>` +
                    `<colorOption>4</colorOption>` +
                    `<shaderOn>true</shaderOn>` +
                    `<glintSize>10</glintSize>` +
                    `<glintOffset>0</glintOffset>` +
                    `<rampPosTop>75</rampPosTop>` +
                    `<rampPosBottom>25</rampPosBottom>` +
                    `<rampAngle>0</rampAngle>` +
                    `<bevelBalance>0</bevelBalance>` +
                    `<rampCycle>0</rampCycle>` +
                    `<classicStyle>0</classicStyle>` +
                    `<rampType>0</rampType>` +
                    colorSpecs +
                    `<glintAngle>0</glintAngle>` +
                    `<bevelSize>0</bevelSize>` +
                    `<bevelDirection>0</bevelDirection>` +
                    `<bevelPipe>false</bevelPipe>` +
                    `<bevelAngle>0</bevelAngle>` +
                    `<bevelShape>1</bevelShape>` +
                    `<bevelShining>0</bevelShining>` +
                    `<bevelLight>false</bevelLight>` +
                    `<bevelMerge>true</bevelMerge>` +
                    `<sheenOn>false</sheenOn>` +
                `</Shader>`;
            }

            /**
             * フェース（塗り本体）用Shader生成
             */
            _buildFaceShader(shaderRef, config) {
                const fillType = config.fillType || 'solid';

                if (fillType === 'solid') {
                    const rgb = this._parseColor(config.fillColor || '#ffffff');
                    let colorSpecs = '';
                    for (let i = 0; i <= 4; i++) {
                        colorSpecs += `<ColorSpec index="${i}">` +
                            `<red>${rgb.r}</red>` +
                            `<green>${rgb.g}</green>` +
                            `<blue>${rgb.b}</blue>` +
                            `<xpar>0</xpar>` +
                        `</ColorSpec>`;
                    }

                    return `<Shader Version="4">` +
                        `<cReference>${shaderRef}</cReference>` +
                        `<textureRef>0</textureRef>` +
                        `<colorOption>4</colorOption>` +
                        `<shaderOn>true</shaderOn>` +
                        `<glintSize>10</glintSize>` +
                        `<glintOffset>0</glintOffset>` +
                        `<rampPosTop>75</rampPosTop>` +
                        `<rampPosBottom>25</rampPosBottom>` +
                        `<rampAngle>0</rampAngle>` +
                        `<bevelBalance>0</bevelBalance>` +
                        `<rampCycle>0</rampCycle>` +
                        `<classicStyle>0</classicStyle>` +
                        `<rampType>0</rampType>` +
                        colorSpecs +
                        `<glintAngle>0</glintAngle>` +
                        `<bevelSize>0</bevelSize>` +
                        `<bevelDirection>0</bevelDirection>` +
                        `<bevelPipe>false</bevelPipe>` +
                        `<bevelAngle>0</bevelAngle>` +
                        `<bevelShape>1</bevelShape>` +
                        `<bevelShining>0</bevelShining>` +
                        `<bevelLight>false</bevelLight>` +
                        `<bevelMerge>true</bevelMerge>` +
                        `<sheenOn>false</sheenOn>` +
                    `</Shader>`;
                } else if (fillType.startsWith('gradient')) {
                    const startColor = this._parseColor(config.gradientStart || '#ff0000');
                    const middleColor = this._parseColor(config.gradientMiddle || '#ffff00');
                    const endColor = this._parseColor(config.gradientEnd || '#0000ff');

                    let colorSpecs = `<ColorSpec index="0"><red>${startColor.r}</red><green>${startColor.g}</green><blue>${startColor.b}</blue><xpar>0</xpar></ColorSpec>`;
                    colorSpecs += `<ColorSpec index="1"><red>0</red><green>0</green><blue>0</blue><xpar>0</xpar></ColorSpec>`;
                    colorSpecs += `<ColorSpec index="2"><red>${middleColor.r}</red><green>${middleColor.g}</green><blue>${middleColor.b}</blue><xpar>0</xpar></ColorSpec>`;
                    colorSpecs += `<ColorSpec index="3"><red>0</red><green>0</green><blue>0</blue><xpar>0</xpar></ColorSpec>`;
                    colorSpecs += `<ColorSpec index="4"><red>${endColor.r}</red><green>${endColor.g}</green><blue>${endColor.b}</blue><xpar>0</xpar></ColorSpec>`;

                    return `<Shader Version="4">` +
                        `<cReference>${shaderRef}</cReference>` +
                        `<textureRef>0</textureRef>` +
                        `<colorOption>4</colorOption>` +
                        `<shaderOn>true</shaderOn>` +
                        `<glintSize>10</glintSize>` +
                        `<glintOffset>0</glintOffset>` +
                        `<rampPosTop>75</rampPosTop>` +
                        `<rampPosBottom>25</rampPosBottom>` +
                        `<rampAngle>0</rampAngle>` +
                        `<bevelBalance>0</bevelBalance>` +
                        `<rampCycle>0</rampCycle>` +
                        `<classicStyle>0</classicStyle>` +
                        `<rampType>0</rampType>` +
                        colorSpecs +
                        `<glintAngle>0</glintAngle>` +
                        `<bevelSize>0</bevelSize>` +
                        `<bevelDirection>0</bevelDirection>` +
                        `<bevelPipe>false</bevelPipe>` +
                        `<bevelAngle>0</bevelAngle>` +
                        `<bevelShape>1</bevelShape>` +
                        `<bevelShining>0</bevelShining>` +
                        `<bevelLight>false</bevelLight>` +
                        `<bevelMerge>true</bevelMerge>` +
                        `<sheenOn>false</sheenOn>` +
                    `</Shader>`;
                }

                // デフォルトは白
                return this._buildStrokeShader(shaderRef, '#ffffff');
            }

            /**
             * シャドウ用Shader生成
             */
            _buildShadowShader(shaderRef, config) {
                const rgb = this._parseColor(config.shadow_color || '#000000');
                const opacity = config.shadow_opacity || 50;
                const xpar = Math.round((100 - opacity) * 255 / 100); // 不透明度をxparに変換

                let colorSpecs = '';
                for (let i = 0; i <= 4; i++) {
                    colorSpecs += `<ColorSpec index="${i}">` +
                        `<red>${rgb.r}</red>` +
                        `<green>${rgb.g}</green>` +
                        `<blue>${rgb.b}</blue>` +
                        `<xpar>${i === 0 ? xpar : 0}</xpar>` +
                    `</ColorSpec>`;
                }

                return `<Shader Version="4">` +
                    `<cReference>${shaderRef}</cReference>` +
                    `<textureRef>0</textureRef>` +
                    `<colorOption>0</colorOption>` +
                    `<shaderOn>true</shaderOn>` +
                    `<glintSize>0</glintSize>` +
                    `<glintOffset>0</glintOffset>` +
                    `<rampPosTop>75</rampPosTop>` +
                    `<rampPosBottom>25</rampPosBottom>` +
                    `<rampAngle>0</rampAngle>` +
                    `<bevelBalance>0</bevelBalance>` +
                    `<rampCycle>0</rampCycle>` +
                    `<classicStyle>0</classicStyle>` +
                    `<rampType>0</rampType>` +
                    colorSpecs +
                    `<glintAngle>0</glintAngle>` +
                    `<bevelSize>0</bevelSize>` +
                    `<bevelDirection>0</bevelDirection>` +
                    `<bevelPipe>false</bevelPipe>` +
                    `<bevelAngle>0</bevelAngle>` +
                    `<bevelShape>1</bevelShape>` +
                    `<bevelShining>0</bevelShining>` +
                    `<bevelLight>false</bevelLight>` +
                    `<bevelMerge>true</bevelMerge>` +
                    `<sheenOn>false</sheenOn>` +
                `</Shader>`;
            }

            /**
             * 単色Shader（仕様書 5.2）
             */
            _buildSolidShader(shaderID, config) {
                const color = this._parseColor(config.fillColor || '#ffffff');

                // ColorSpec 0-4 すべて同じ色（仕様書通り）
                let colorSpecs = '';
                for (let i = 0; i <= 4; i++) {
                    colorSpecs += `<ColorSpec index="${i}">` +
                        `<red>${color.r}</red>` +
                        `<green>${color.g}</green>` +
                        `<blue>${color.b}</blue>` +
                        `<xpar>0</xpar>` +
                    `</ColorSpec>`;
                }

                return `<Shaders>` +
                    `<Shader Version="4">` +
                        `<cReference>${shaderID}</cReference>` +
                        `<textureRef>0</textureRef>` +
                        `<colorOption>4</colorOption>` +
                        `<shaderOn>true</shaderOn>` +
                        `<glintSize>10</glintSize>` +
                        `<glintOffset>0</glintOffset>` +
                        `<rampPosTop>75</rampPosTop>` +
                        `<rampPosBottom>25</rampPosBottom>` +
                        `<rampAngle>0</rampAngle>` +
                        `<bevelBalance>0</bevelBalance>` +
                        `<rampCycle>0</rampCycle>` +
                        `<classicStyle>0</classicStyle>` +
                        `<rampType>0</rampType>` +
                        colorSpecs +
                        `<glintAngle>0</glintAngle>` +
                        `<bevelSize>0</bevelSize>` +
                        `<bevelDirection>0</bevelDirection>` +
                        `<bevelPipe>false</bevelPipe>` +
                        `<bevelAngle>0</bevelAngle>` +
                        `<bevelShape>1</bevelShape>` +
                        `<bevelShining>0</bevelShining>` +
                        `<bevelLight>false</bevelLight>` +
                        `<bevelMerge>true</bevelMerge>` +
                        `<sheenOn>false</sheenOn>` +
                    `</Shader>` +
                `</Shaders>`;
            }

            /**
             * グラデーションShader（仕様書 5.3）
             */
            _buildGradientShader(shaderID, config) {
                const startColor = this._parseColor(config.gradientStart || '#ff0000');
                const middleColor = this._parseColor(config.gradientMiddle || '#ffff00');
                const endColor = this._parseColor(config.gradientEnd || '#0000ff');
                const angle = config.gradientAngle || 0;
                const isRadial = config.fillType === 'gradient-radial';

                // 線形 vs 円形の違い（仕様書通り）
                const rampPosTop = isRadial ? 85.8696 : 75;
                const rampPosBottom = isRadial ? 44.5652 : 25;

                // ColorSpec: index0=開始, index2=中間, index4=終端, index1,3=黒
                const colorSpecs =
                    `<ColorSpec index="0"><red>${startColor.r}</red><green>${startColor.g}</green><blue>${startColor.b}</blue><xpar>0</xpar></ColorSpec>` +
                    `<ColorSpec index="1"><red>0</red><green>0</green><blue>0</blue><xpar>0</xpar></ColorSpec>` +
                    `<ColorSpec index="2"><red>${middleColor.r}</red><green>${middleColor.g}</green><blue>${middleColor.b}</blue><xpar>0</xpar></ColorSpec>` +
                    `<ColorSpec index="3"><red>0</red><green>0</green><blue>0</blue><xpar>0</xpar></ColorSpec>` +
                    `<ColorSpec index="4"><red>${endColor.r}</red><green>${endColor.g}</green><blue>${endColor.b}</blue><xpar>0</xpar></ColorSpec>`;

                return `<Shaders>` +
                    `<Shader Version="4">` +
                        `<cReference>${shaderID}</cReference>` +
                        `<textureRef>0</textureRef>` +
                        `<colorOption>0</colorOption>` +
                        `<shaderOn>true</shaderOn>` +
                        `<glintSize>10</glintSize>` +
                        `<glintOffset>0</glintOffset>` +
                        `<rampPosTop>${rampPosTop}</rampPosTop>` +
                        `<rampPosBottom>${rampPosBottom}</rampPosBottom>` +
                        `<rampAngle>${angle}</rampAngle>` +
                        `<bevelBalance>0</bevelBalance>` +
                        `<rampCycle>0</rampCycle>` +
                        `<classicStyle>0</classicStyle>` +
                        `<rampType>-1</rampType>` +
                        colorSpecs +
                        `<glintAngle>0</glintAngle>` +
                        `<bevelSize>0</bevelSize>` +
                        `<bevelDirection>0</bevelDirection>` +
                        `<bevelPipe>false</bevelPipe>` +
                        `<bevelAngle>0</bevelAngle>` +
                        `<bevelShape>1</bevelShape>` +
                        `<bevelShining>0</bevelShining>` +
                        `<bevelLight>false</bevelLight>` +
                        `<bevelMerge>true</bevelMerge>` +
                        `<sheenOn>false</sheenOn>` +
                    `</Shader>` +
                `</Shaders>`;
            }

            /**
             * 光沢Shader（仕様書 5.4）
             */
            _buildSheenShader(shaderID, config) {
                const baseColor = this._parseColor(config.sheenBase || '#000000');
                const highlightColor = this._parseColor(config.sheenHighlight || '#ffffff');
                const glintSize = config.glintSize || 10;
                const glintAngle = config.glintAngle || 0;

                // ColorSpec: index0-3=ベース色, index4=ハイライト色
                const colorSpecs =
                    `<ColorSpec index="0"><red>${baseColor.r}</red><green>${baseColor.g}</green><blue>${baseColor.b}</blue><xpar>0</xpar></ColorSpec>` +
                    `<ColorSpec index="1"><red>${baseColor.r}</red><green>${baseColor.g}</green><blue>${baseColor.b}</blue><xpar>0</xpar></ColorSpec>` +
                    `<ColorSpec index="2"><red>${baseColor.r}</red><green>${baseColor.g}</green><blue>${baseColor.b}</blue><xpar>0</xpar></ColorSpec>` +
                    `<ColorSpec index="3"><red>${baseColor.r}</red><green>${baseColor.g}</green><blue>${baseColor.b}</blue><xpar>0</xpar></ColorSpec>` +
                    `<ColorSpec index="4"><red>${highlightColor.r}</red><green>${highlightColor.g}</green><blue>${highlightColor.b}</blue><xpar>0</xpar></ColorSpec>`;

                return `<Shaders>` +
                    `<Shader Version="4">` +
                        `<cReference>${shaderID}</cReference>` +
                        `<textureRef>0</textureRef>` +
                        `<colorOption>4</colorOption>` +
                        `<shaderOn>true</shaderOn>` +
                        `<glintSize>${glintSize}</glintSize>` +
                        `<glintOffset>0</glintOffset>` +
                        `<rampPosTop>75</rampPosTop>` +
                        `<rampPosBottom>25</rampPosBottom>` +
                        `<rampAngle>0</rampAngle>` +
                        `<bevelBalance>0</bevelBalance>` +
                        `<rampCycle>0</rampCycle>` +
                        `<classicStyle>0</classicStyle>` +
                        `<rampType>0</rampType>` +
                        colorSpecs +
                        `<glintAngle>${glintAngle}</glintAngle>` +
                        `<bevelSize>0</bevelSize>` +
                        `<bevelDirection>0</bevelDirection>` +
                        `<bevelPipe>false</bevelPipe>` +
                        `<bevelAngle>0</bevelAngle>` +
                        `<bevelShape>1</bevelShape>` +
                        `<bevelShining>0</bevelShining>` +
                        `<bevelLight>false</bevelLight>` +
                        `<bevelMerge>true</bevelMerge>` +
                        `<sheenOn>true</sheenOn>` +
                    `</Shader>` +
                `</Shaders>`;
            }

            /**
             * Layers生成（TextPage + TextChain + TextLine）
             */
            _buildLayers(config) {
                const text = config.text || 'サンプル';
                const posX = config.posX || 960;
                const posY = config.posY || 540;
                const textAlign = config.textAlign || 'center';
                const styleRef = this.nextStyleID;
                const textRef = this.nextTextDescID;

                // txBaseの計算（フォントサイズに基づく）
                const fontSize = config.fontSize || 72;
                const txBase = fontSize * 1.2; // ベースライン位置

                // Alignment設定
                const alignment = textAlign;

                return `<Layers>` +
                    `<Layer>` +
                        `<DrawPage></DrawPage>` +
                        `<TextPage>` +
                            `<TextChain>` +
                                `<ChainProperty>` +
                                    `<Position><x>${posX}</x><y>${posY}</y></Position>` +
                                    `<Size><x>1000</x><y>200</y></Size>` +
                                    `<wordWrap>false</wordWrap>` +
                                    `<Alignment>${alignment}</Alignment>` +
                                `</ChainProperty>` +
                                `<ChainTabs></ChainTabs>` +
                                `<TextLine Version="2" objectID="1" persistentID="1">` +
                                    `<BaseProperties Version="5">` +
                                        `<txBase>${txBase}</txBase>` +
                                        `<XPos>${posX}</XPos>` +
                                        `<angle>0</angle>` +
                                        `<verticalText>false</verticalText>` +
                                        `<objectLeading>0</objectLeading>` +
                                    `</BaseProperties>` +
                                    `<EnclosingObjectType>block</EnclosingObjectType>` +
                                    `<Alignment>${alignment}</Alignment>` +
                                    `<RTL>false</RTL>` +
                                    `<TRString>${this._escapeXML(text)}</TRString>` +
                                    `<RunLengthEncodedCharacterAttributes>` +
                                        `<CharacterAttributes ` +
                                            `RunCount="${text.length}" ` +
                                            `StyleRef="${styleRef}" ` +
                                            `TextRef="${textRef}" ` +
                                            `TXKerning="0" ` +
                                            `TXPostKerning="0" ` +
                                            `BaselineShifting="0" />` +
                                    `</RunLengthEncodedCharacterAttributes>` +
                                    `<tagName></tagName>` +
                                `</TextLine>` +
                            `</TextChain>` +
                        `</TextPage>` +
                        `<MergeGroups></MergeGroups>` +
                    `</Layer>` +
                `</Layers>`;
            }

            /**
             * Textures（空）
             */
            _buildTextures() {
                return `<Textures></Textures>`;
            }

            /**
             * Logos（空）
             */
            _buildLogos() {
                return `<Logos></Logos>`;
            }

            /**
             * VLS（空）
             */
            _buildVLS() {
                return `<VLS>` +
                    `<FileReference Version="1">` +
                        `<fileString></fileString>` +
                        `<seClass>2</seClass>` +
                        `<seCode>1000</seCode>` +
                    `</FileReference>` +
                `</VLS>`;
            }

            /**
             * ユーティリティ: カラーパース
             */
            _parseColor(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : { r: 255, g: 255, b: 255 };
            }

            /**
             * ユーティリティ: XMLエスケープ
             */
            _escapeXML(str) {
                if (!str) return '';
                return String(str)
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&apos;');
            }
        }

        /**
         * プレビュー更新
         */
        function updatePreview() {
            const width = parseInt(document.getElementById('canvasWidth').value);
            const height = parseInt(document.getElementById('canvasHeight').value);
            const text = document.getElementById('textContent').value;
            const fontFamily = document.getElementById('fontFamily').value;
            const fontSize = parseInt(document.getElementById('fontSize').value);
            const scaleX = parseInt(document.getElementById('scaleX').value);
            const posX = parseInt(document.getElementById('posX').value);
            const posY = parseInt(document.getElementById('posY').value);
            const textAlign = document.getElementById('textAlign').value;
            const fillType = document.getElementById('fillType').value;

            // キャンバスクリア
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // テキスト描画準備
            ctx.font = `${fontSize}px "${fontFamily}"`;
            ctx.textBaseline = 'middle';

            // アライメント設定
            ctx.textAlign = textAlign;

            // 横幅スケール適用
            ctx.save();
            ctx.scale(scaleX / 100, 1);
            const adjustedX = posX * (100 / scaleX);

            // シャドウの描画（最背面）
            if (document.getElementById('shadow_enabled').checked) {
                const shadowOffset = parseInt(document.getElementById('shadow_offset').value);
                const shadowAngle = parseInt(document.getElementById('shadow_angle').value) * Math.PI / 180;
                const shadowColor = document.getElementById('shadow_color').value;
                const shadowOpacity = parseInt(document.getElementById('shadow_opacity').value) / 100;

                const shadowX = adjustedX + Math.cos(shadowAngle) * shadowOffset;
                const shadowY = posY + Math.sin(shadowAngle) * shadowOffset;

                // 色をRGBAに変換して不透明度を適用
                const rgb = hexToRgb(shadowColor);
                ctx.fillStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${shadowOpacity})`;
                ctx.fillText(text, shadowX, shadowY);
            }

            // ストローク層を外側から内側へ描画
            const strokes = [
                { id: 4, enabled: 'stroke4_enabled', size: 'stroke4_size', color: 'stroke4_color' },
                { id: 3, enabled: 'stroke3_enabled', size: 'stroke3_size', color: 'stroke3_color' },
                { id: 2, enabled: 'stroke2_enabled', size: 'stroke2_size', color: 'stroke2_color' },
                { id: 1, enabled: 'stroke1_enabled', size: 'stroke1_size', color: 'stroke1_color' }
            ];

            for (const stroke of strokes) {
                if (document.getElementById(stroke.enabled).checked) {
                    const strokeSize = parseInt(document.getElementById(stroke.size).value);
                    const strokeColor = document.getElementById(stroke.color).value;

                    ctx.strokeStyle = strokeColor;
                    ctx.lineWidth = strokeSize;
                    ctx.lineJoin = 'round';
                    ctx.miterLimit = 2;
                    ctx.strokeText(text, adjustedX, posY);
                }
            }

            // フェース（本体）の描画（最前面）
            if (fillType === 'solid') {
                ctx.fillStyle = document.getElementById('fillColor').value;
            } else if (fillType === 'gradient-linear') {
                const angle = parseInt(document.getElementById('gradientAngle').value);
                const rad = (angle - 90) * Math.PI / 180;
                const distance = Math.max(width, height);
                const x1 = adjustedX - Math.cos(rad) * distance / 2;
                const y1 = posY - Math.sin(rad) * distance / 2;
                const x2 = adjustedX + Math.cos(rad) * distance / 2;
                const y2 = posY + Math.sin(rad) * distance / 2;

                const gradient = ctx.createLinearGradient(x1, y1, x2, y2);
                gradient.addColorStop(0, document.getElementById('gradientStart').value);
                gradient.addColorStop(0.5, document.getElementById('gradientMiddle').value);
                gradient.addColorStop(1, document.getElementById('gradientEnd').value);
                ctx.fillStyle = gradient;
            } else if (fillType === 'gradient-radial') {
                const gradient = ctx.createRadialGradient(adjustedX, posY, 0, adjustedX, posY, fontSize * 2);
                gradient.addColorStop(0, document.getElementById('gradientStart').value);
                gradient.addColorStop(0.5, document.getElementById('gradientMiddle').value);
                gradient.addColorStop(1, document.getElementById('gradientEnd').value);
                ctx.fillStyle = gradient;
            } else if (fillType === 'sheen') {
                // 簡易的な光沢表現（実際のPremiereとは異なる）
                ctx.fillStyle = document.getElementById('sheenBase').value;
            }

            ctx.fillText(text, adjustedX, posY);
            ctx.restore();
        }

        // 色変換ヘルパー関数
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 0, g: 0, b: 0 };
        }

        /**
         * PRTL書き出し
         */
        function exportPRTL() {
            const config = {
                width: parseInt(document.getElementById('canvasWidth').value),
                height: parseInt(document.getElementById('canvasHeight').value),
                text: document.getElementById('textContent').value,
                fontFamily: document.getElementById('fontFamily').value,
                fontSize: parseInt(document.getElementById('fontSize').value),
                scaleX: parseInt(document.getElementById('scaleX').value),
                posX: parseInt(document.getElementById('posX').value),
                posY: parseInt(document.getElementById('posY').value),
                textAlign: document.getElementById('textAlign').value,
                fillType: document.getElementById('fillType').value,
                fillColor: document.getElementById('fillColor').value,
                gradientStart: document.getElementById('gradientStart').value,
                gradientMiddle: document.getElementById('gradientMiddle').value,
                gradientEnd: document.getElementById('gradientEnd').value,
                gradientAngle: parseInt(document.getElementById('gradientAngle').value),
                sheenBase: document.getElementById('sheenBase').value,
                sheenHighlight: document.getElementById('sheenHighlight').value,
                glintSize: parseInt(document.getElementById('glintSize').value),
                glintAngle: parseInt(document.getElementById('glintAngle').value),
                // ストローク情報
                stroke4_enabled: document.getElementById('stroke4_enabled').checked,
                stroke4_size: parseInt(document.getElementById('stroke4_size').value),
                stroke4_color: document.getElementById('stroke4_color').value,
                stroke3_enabled: document.getElementById('stroke3_enabled').checked,
                stroke3_size: parseInt(document.getElementById('stroke3_size').value),
                stroke3_color: document.getElementById('stroke3_color').value,
                stroke2_enabled: document.getElementById('stroke2_enabled').checked,
                stroke2_size: parseInt(document.getElementById('stroke2_size').value),
                stroke2_color: document.getElementById('stroke2_color').value,
                stroke1_enabled: document.getElementById('stroke1_enabled').checked,
                stroke1_size: parseInt(document.getElementById('stroke1_size').value),
                stroke1_color: document.getElementById('stroke1_color').value,
                shadow_enabled: document.getElementById('shadow_enabled').checked,
                shadow_offset: parseInt(document.getElementById('shadow_offset').value),
                shadow_angle: parseInt(document.getElementById('shadow_angle').value),
                shadow_color: document.getElementById('shadow_color').value,
                shadow_opacity: parseInt(document.getElementById('shadow_opacity').value)
            };

            const generator = new PRTLGeneratorV2();
            const prtlXML = generator.generatePRTL(config);

            // UTF-8エンコード（BOMなし）
            const encoder = new TextEncoder();
            const utf8Array = encoder.encode(prtlXML);

            const blob = new Blob([utf8Array], { type: 'application/octet-stream' });
            const link = document.createElement('a');
            link.download = `NLT_${Date.now()}.prtl`;
            link.href = URL.createObjectURL(blob);
            link.click();

            console.log('✅ PRTL書き出し完了');
        }

        /**
         * PRTL構造テスト（コンソールに出力）
         */
        function testPRTL() {
            const config = {
                width: 1920,
                height: 1080,
                text: 'テスト',
                fontFamily: 'Yu Gothic UI',
                fontSize: 72,
                scaleX: 100,
                posX: 960,
                posY: 540,
                textAlign: 'center',
                fillType: 'solid',
                fillColor: '#ffffff'
            };

            const generator = new PRTLGeneratorV2();
            const prtlXML = generator.generatePRTL(config);

            console.log('=== PRTL構造テスト ===');
            console.log(prtlXML);
            console.log('======================');

            alert('PRTL構造をコンソールに出力しました（F12で確認）');
        }

        // 初期プレビュー
        updatePreview();
    </script>
</body>
</html>

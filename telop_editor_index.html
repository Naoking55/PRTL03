<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Telop Editor v3.0 - Premiere Pro テロップエディタ</title>
    <style>
        * { box-sizing: border-box; }
        body {
            margin: 0;
            padding: 15px;
            font-family: 'Yu Gothic UI', 'Meiryo', sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            height: 100vh;
            overflow: hidden;
        }
        .container {
            display: grid;
            grid-template-columns: var(--left-panel-width, 260px) 6px 1fr 6px var(--right-panel-width, 340px);
            gap: 0;
            height: calc(100vh - 30px);
        }
        .panel {
            background: #2a2a2a;
            border-radius: 8px;
            padding: 12px;
            overflow-y: auto;
        }
        /* リサイズハンドル */
        .resize-handle {
            background: #1a1a1a;
            cursor: col-resize;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }
        .resize-handle:hover { background: #0066cc; }
        .resize-handle::after {
            content: '';
            width: 2px;
            height: 30px;
            background: #444;
            border-radius: 1px;
        }
        .resize-handle:hover::after { background: #fff; }
        .panel h3 {
            margin: 0 0 10px 0;
            padding-bottom: 8px;
            border-bottom: 1px solid #444;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .panel h4 { color: #8a8a8a; margin: 8px 0 4px; font-size: 10px; font-weight: 500; }
        .panel label { display: block; margin: 4px 0 2px; font-size: 10px; color: #aaa; }
        input, select {
            width: 100%; padding: 5px 8px;
            background: #3a3a3a; border: 1px solid #555; color: #fff;
            border-radius: 4px; font-size: 11px;
        }
        input:focus, select:focus { outline: none; border-color: #0066cc; background: #404040; }
        input[type="color"] { height: 26px; padding: 2px; cursor: pointer; }
        input[type="range"] { padding: 0; accent-color: #0066cc; }
        input[type="checkbox"] { width: auto; margin-right: 5px; accent-color: #0066cc; }
        .btn {
            width: 100%; padding: 6px 10px; margin: 2px 0;
            cursor: pointer; border: 1px solid #555; border-radius: 4px;
            font-size: 11px; font-weight: 500;
            background: #3a3a3a; color: #e0e0e0;
        }
        .btn:hover { background: #4a4a4a; }
        .btn-primary { background: #0066cc; color: #fff; border-color: #0077ee; }
        .btn-primary:hover { background: #0077ee; }
        .btn-secondary { background: #3a3a3a; }
        .btn-danger { background: #c42b1c; color: #fff; border-color: #d43; }
        .btn-small { width: auto; padding: 4px 6px; margin: 1px; font-size: 10px; }
        .layer-list { background: #1a1a1a; border-radius: 4px; max-height: 100px; overflow-y: auto; border: 1px solid #444; }
        .layer-item { padding: 5px 8px; cursor: pointer; border-bottom: 1px solid #333; font-size: 10px; }
        .layer-item:hover { background: #3a3a3a; }
        .layer-item.selected { background: #0066cc; color: #fff; }
        .align-buttons { display: flex; gap: 2px; margin: 4px 0; }
        .align-btn {
            flex: 1; padding: 5px;
            background: #3a3a3a; border: 1px solid #555; color: #aaa;
            cursor: pointer; font-size: 10px; border-radius: 4px;
        }
        .align-btn:hover { background: #4a4a4a; color: #fff; }
        .align-btn.active { background: #0066cc; color: #fff; border-color: #0066cc; }
        .center-panel { display: flex; flex-direction: column; background: #2a2a2a; border-radius: 8px; overflow: hidden; }
        .toolbar {
            display: flex; gap: 8px; padding: 8px 10px;
            align-items: center; border-bottom: 1px solid #444;
        }
        .toolbar select { width: auto; }
        .canvas-container {
            flex: 1; display: flex; align-items: center; justify-content: center;
            background: #141414; overflow: hidden; min-height: 0;
        }
        #canvas {
            background: repeating-conic-gradient(#2a2a2a 0% 25%, #1e1e1e 0% 50%) 50% / 16px 16px;
            max-width: 100%; max-height: 100%;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }
        .bottom-toolbar { display: flex; padding: 5px 8px; border-top: 1px solid #444; gap: 2px; flex-wrap: wrap; }
        .tool-group { display: flex; gap: 1px; padding: 0 6px; border-right: 1px solid #444; }
        .tool-group:last-child { border-right: none; }
        .tool-icon {
            width: 30px; height: 30px;
            display: flex; align-items: center; justify-content: center;
            background: transparent; border: 1px solid transparent; border-radius: 3px;
            cursor: pointer; font-size: 12px; color: #aaa;
            transition: all 0.15s ease;
        }
        .tool-icon:hover { background: #3a3a3a; color: #fff; }
        .tool-icon.active { background: #0066cc; color: #fff; border-color: #0066cc; }
        .tool-icon svg { width: 16px; height: 16px; fill: currentColor; transition: all 0.15s ease; }
        .tool-icon span { font-size: 11px; font-weight: bold; }
        /* ツールバーサイズ: Small */
        .toolbar-size-s .tool-icon { width: 24px; height: 24px; font-size: 10px; }
        .toolbar-size-s .tool-icon svg { width: 12px; height: 12px; }
        .toolbar-size-s .tool-icon span { font-size: 9px; }
        /* ツールバーサイズ: Medium (デフォルト) */
        .toolbar-size-m .tool-icon { width: 30px; height: 30px; font-size: 12px; }
        .toolbar-size-m .tool-icon svg { width: 16px; height: 16px; }
        .toolbar-size-m .tool-icon span { font-size: 11px; }
        /* ツールバーサイズ: Large */
        .toolbar-size-l .tool-icon { width: 38px; height: 38px; font-size: 14px; }
        .toolbar-size-l .tool-icon svg { width: 20px; height: 20px; }
        .toolbar-size-l .tool-icon span { font-size: 13px; }
        .status { padding: 5px 10px; font-size: 10px; color: #888; display: flex; justify-content: space-between; border-top: 1px solid #444; }
        .prop-section { background: #1a1a1a; padding: 6px; border-radius: 4px; margin: 4px 0; border: 1px solid #2a2a2a; }
        .row2 { display: flex; gap: 4px; }
        .row2 > div { flex: 1; }
        .row2 label { font-size: 9px; }
        .collapsible { cursor: pointer; user-select: none; }
        .collapsible::before { content: '▼ '; font-size: 8px; color: #666; }
        .collapsible.collapsed::before { content: '▶ '; }
        .collapse-content { display: block; }
        .collapse-content.hidden { display: none; }
        #imeInput { position: fixed; top: 0; left: 0; width: 1px; height: 1px; opacity: 0.01; }
        .stroke-item { background: #333; padding: 6px; margin: 3px 0; border-radius: 4px; border: 1px solid #444; }
        .stroke-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px; }
        .gradient-stop { position: relative; padding-right: 20px; }
        .gradient-stop .remove-stop {
            position: absolute; right: 0; top: 50%; transform: translateY(-50%);
            background: #c42b1c; color: #fff; border: none; border-radius: 3px;
            width: 16px; height: 16px; font-size: 10px; cursor: pointer; display: none;
        }
        .gradient-stop:nth-child(n+3) .remove-stop { display: block; }
        .canvas-list { flex: 1; overflow-y: auto; }
        .canvas-bar {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 10px;
            border-top: 1px solid #444;
            background: #252525;
        }
        .canvas-bar-buttons {
            display: flex;
            flex-direction: column;
            gap: 4px;
            flex-shrink: 0;
        }
        .canvas-list-horizontal {
            display: flex;
            gap: 6px;
            overflow-x: auto;
            overflow-y: hidden;
            flex: 1;
            padding: 2px 0 12px 0;
            scroll-behavior: smooth;
        }
        .canvas-list-horizontal .canvas-thumb {
            flex-shrink: 0;
            width: 250px;
            margin-bottom: 0;
        }
        .canvas-list-horizontal .canvas-thumb img {
            height: 140px;
            object-fit: cover;
        }
        .canvas-thumb { position: relative; margin-bottom: 6px; border: 2px solid transparent; border-radius: 4px; cursor: pointer; }
        .canvas-thumb:hover { border-color: #4a4a4a; }
        .canvas-thumb.active { border-color: #0066cc; }
        .canvas-thumb img { width: 100%; display: block; border-radius: 2px; background: #1a1a1a; }
        .canvas-thumb-name { font-size: 9px; color: #aaa; padding: 3px; text-align: center; }
        .canvas-thumb-actions { position: absolute; top: 2px; right: 2px; display: none; gap: 2px; }
        .canvas-thumb:hover .canvas-thumb-actions { display: flex; }
        .canvas-thumb-btn { width: 16px; height: 16px; background: rgba(0,0,0,0.7); border: none; border-radius: 3px; color: #fff; font-size: 9px; cursor: pointer; }
        .canvas-actions { display: flex; gap: 3px; margin-bottom: 6px; }
        .canvas-actions .btn { flex: 1; padding: 5px 3px; font-size: 10px; }
        ::-webkit-scrollbar { width: 12px; height: 12px; }
        ::-webkit-scrollbar-track { background: #1a1a1a; }
        ::-webkit-scrollbar-thumb {
            background: #4a4a4a;
            border-radius: 6px;
            border: 2px solid #1a1a1a;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #5a5a5a;
        }
        ::-webkit-scrollbar-thumb:active {
            background: #6a6a6a;
        }
        .char-info { font-size: 9px; color: #666; margin-top: 4px; }
        .prop-row { display: flex; gap: 4px; align-items: center; margin: 2px 0; }
        .prop-label { font-size: 10px; width: 50px; color: #888; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
</head>
<body>
    <div class="container">
        <!-- 左パネル: オブジェクト管理 -->
        <div class="panel">
            <h3>レイヤー</h3>
            <div class="layer-list" id="layerList"></div>
            <div style="display:flex;gap:2px;margin-top:5px;flex-wrap:wrap;">
                <button class="btn btn-small btn-secondary" onclick="moveLayerUp()">↑</button>
                <button class="btn btn-small btn-secondary" onclick="moveLayerDown()">↓</button>
                <button class="btn btn-small btn-secondary" onclick="alignToCenter('v')">縦中央</button>
                <button class="btn btn-small btn-secondary" onclick="alignToCenter('h')">横中央</button>
                <button class="btn btn-small btn-danger" onclick="deleteSelected()">削除</button>
            </div>

            <div class="prop-section" id="layerProps" style="display:none;">
                <div class="row2">
                    <div><label>名前</label><input type="text" id="layerName" onchange="updateLayerName()"></div>
                </div>
                <div class="row2">
                    <div><label>X</label><input type="number" id="layerX" step="0.1" onchange="updateLayerPosition()"></div>
                    <div><label>Y</label><input type="number" id="layerY" step="0.1" onchange="updateLayerPosition()"></div>
                </div>
                <div class="row2">
                    <div><label>幅</label><input type="number" id="layerWidth" step="0.1" onchange="updateLayerSize()"></div>
                    <div><label>高さ</label><input type="number" id="layerHeight" step="0.1" onchange="updateLayerSize()"></div>
                </div>
                <div class="row2">
                    <div><label>回転°</label><input type="number" id="layerRotation" step="0.1" value="0" onchange="updateLayerRotation()"></div>
                    <div><label>行間</label><input type="number" id="layerLineHeight" step="0.1" value="1.2" onchange="updateLayerLineHeight()"></div>
                </div>
                <div class="prop-row">
                    <span class="prop-label">不透明度</span>
                    <input type="range" id="layerOpacity" min="0" max="100" value="100" oninput="updateLayerOpacity()"><span id="opacityVal">100</span>%
                </div>
            </div>

            <h3 class="collapsible collapsed" onclick="toggleCollapse(this)" style="margin-top: 12px;">PRSLスタイル</h3>
            <div class="collapse-content hidden">
                <button class="btn btn-secondary" onclick="importPRSL()">PRSL読込</button>
                <input type="file" id="prslInput" accept=".prsl" style="display:none" onchange="handlePRSLLoad(event)">
                <div id="prslStatus" style="font-size:10px;color:#888;margin-top:3px;"></div>
                <div id="prslStyleList" style="max-height:120px;overflow-y:auto;margin-top:5px;"></div>
            </div>

            <h3 class="collapsible" onclick="toggleCollapse(this)">カスタムスタイル</h3>
            <div class="collapse-content" id="customStylesContainer">
                <div style="display:flex;gap:4px;margin-bottom:6px;flex-wrap:wrap;">
                    <button class="btn btn-primary" onclick="saveNewCustomStyle()">新規保存</button>
                    <button class="btn btn-secondary btn-small" onclick="exportAllCustomStyles()">エクスポート</button>
                    <button class="btn btn-secondary btn-small" onclick="importCustomStyles()">インポート</button>
                    <input type="file" id="customStyleImportInput" accept=".json" style="display:none" onchange="handleCustomStyleImport(event)">
                </div>
                <div id="customStyleStatus" style="font-size:10px;color:#888;margin-top:3px;"></div>
                <div id="customStyleList"></div>
            </div>

            <h3>出力</h3>
            <div style="margin-bottom:6px;">
                <label><input type="checkbox" id="exportTransparent"> 背景透過</label>
            </div>
            <div class="row2" style="margin-bottom:6px;">
                <div><label>FPS</label><input type="number" id="exportFps" value="30" min="1" max="60"></div>
                <div><label>時間(秒)</label><input type="number" id="exportDuration" value="3" min="0.1" step="0.1"></div>
            </div>
            <button class="btn btn-primary" onclick="exportPNG()">PNG書き出し</button>
            <button class="btn btn-secondary" onclick="exportSequencePNG()">連番PNG</button>
            <button class="btn btn-secondary" onclick="exportGIF()">GIF書き出し</button>
            <button class="btn btn-secondary" onclick="exportWebM()">WebM書き出し</button>
            <button class="btn btn-primary" onclick="exportPRTL()">PRTL書き出し</button>
            <button class="btn btn-secondary" onclick="batchExportPRTLOnly()" title="全キャンバスをPRTL形式でZIP一括書き出し">キャンバスリスト書出し（PRTL）</button>
            <button class="btn btn-secondary" onclick="batchExportPNGOnly()" title="全キャンバスをPNG形式でZIP一括書き出し">キャンバスリスト書出し（PNG）</button>
            <button class="btn btn-success" onclick="importPRTL()" title="PRTLファイルを読み込んでキャンバスに表示">PRTL読み込み</button>
            <button class="btn btn-primary" onclick="exportMOGRT()">MOGRT書き出し</button>
            <button class="btn btn-secondary" onclick="saveProject()">プロジェクト保存</button>
            <button class="btn btn-secondary" onclick="loadProject()">プロジェクト読込</button>
        </div>

        <!-- 左リサイズハンドル -->
        <div class="resize-handle" id="leftResizeHandle" title="ドラッグでパネル幅を調整"></div>

        <!-- 中央パネル: キャンバス -->
        <div class="center-panel">
            <div class="toolbar">
                <select id="resolution" onchange="changeResolution()">
                    <option value="1920x1080">1920×1080</option>
                    <option value="3840x2160">3840×2160</option>
                </select>
                <span id="toolHint" style="font-size:10px;color:#666;">選択ツール (V)</span>
            </div>
            <div class="canvas-container">
                <canvas id="canvas" width="1920" height="1080"></canvas>
            </div>
            <div class="bottom-toolbar">
                <div class="tool-group">
                    <button class="tool-icon" id="undoBtn" onclick="undo()" title="元に戻す (Ctrl+Z)" disabled>
                        <svg viewBox="0 0 24 24"><path d="M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8z"/></svg>
                    </button>
                    <button class="tool-icon" id="redoBtn" onclick="redo()" title="やり直し (Ctrl+Y)" disabled>
                        <svg viewBox="0 0 24 24"><path d="M18.4 10.6C16.55 8.99 14.15 8 11.5 8c-4.65 0-8.58 3.03-9.96 7.22L3.9 16c1.05-3.19 4.05-5.5 7.6-5.5 1.95 0 3.73.72 5.12 1.88L13 16h9V7l-3.6 3.6z"/></svg>
                    </button>
                </div>
                <div class="tool-group">
                    <button class="tool-icon active" id="toolSelect" onclick="setTool('select')" title="選択 (V)">
                        <svg viewBox="0 0 24 24"><path d="M7 2l10 10-4 1 3 5-2 1-3-5-4 4z"/></svg>
                    </button>
                    <button class="tool-icon" id="toolRotate" onclick="setTool('rotate')" title="回転 (R)">
                        <svg viewBox="0 0 24 24"><path d="M12 6v3l4-4-4-4v3a8 8 0 00-8 8h2a6 6 0 016-6zm8 2a8 8 0 01-8 8v-3l-4 4 4 4v-3a8 8 0 008-8h-2z"/></svg>
                    </button>
                </div>
                <div class="tool-group">
                    <button class="tool-icon" id="toolText" onclick="setTool('text')" title="横書きテキスト (T)">
                        <span>T</span>
                    </button>
                    <button class="tool-icon" id="toolTextV" onclick="setTool('textV')" title="縦書きテキスト">
                        <span style="font-size:9px;">↓T</span>
                    </button>
                </div>
                <div class="tool-group">
                    <button class="tool-icon" id="toolRect" onclick="setTool('rect')" title="長方形">
                        <svg viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2"/></svg>
                    </button>
                    <button class="tool-icon" id="toolRoundRect" onclick="setTool('roundRect')" title="角丸長方形">
                        <svg viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="4" fill="none" stroke="currentColor" stroke-width="2"/></svg>
                    </button>
                    <button class="tool-icon" id="toolEllipse" onclick="setTool('ellipse')" title="楕円">
                        <svg viewBox="0 0 24 24"><ellipse cx="12" cy="12" rx="9" ry="9" fill="none" stroke="currentColor" stroke-width="2"/></svg>
                    </button>
                    <button class="tool-icon" id="toolTriangle" onclick="setTool('triangle')" title="三角形">
                        <svg viewBox="0 0 24 24"><path d="M12 4L3 20h18z" fill="none" stroke="currentColor" stroke-width="2"/></svg>
                    </button>
                    <button class="tool-icon" id="toolLine" onclick="setTool('line')" title="ライン">
                        <svg viewBox="0 0 24 24"><line x1="4" y1="20" x2="20" y2="4" stroke="currentColor" stroke-width="2"/></svg>
                    </button>
                    <button class="tool-icon" id="toolChamferRect" onclick="setTool('chamferRect')" title="斜角長方形">
                        <svg viewBox="0 0 24 24"><path d="M7 3h10l4 4v10l-4 4H7l-4-4V7z" fill="none" stroke="currentColor" stroke-width="2"/></svg>
                    </button>
                    <button class="tool-icon" id="toolArc" onclick="setTool('arc')" title="円弧">
                        <svg viewBox="0 0 24 24"><path d="M4 12a8 8 0 0 1 16 0" fill="none" stroke="currentColor" stroke-width="2"/></svg>
                    </button>
                </div>
                <div class="tool-group">
                    <button class="tool-icon" id="toolPen" onclick="setTool('pen')" title="ペンツール (P)">
                        <svg viewBox="0 0 24 24"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04a.996.996 0 000-1.41l-2.34-2.34a.996.996 0 00-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/></svg>
                    </button>
                    <button class="tool-icon" id="toolPathText" onclick="setTool('pathText')" title="パス上文字">
                        <svg viewBox="0 0 24 24"><path d="M3 17c3-2 6-6 9-6s6 4 9 6" fill="none" stroke="currentColor" stroke-width="2"/><text x="12" y="10" font-size="8" fill="currentColor" text-anchor="middle">T</text></svg>
                    </button>
                </div>
                <div class="tool-group">
                    <button class="tool-icon" onclick="insertImage()" title="画像挿入">
                        <svg viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="2" fill="none" stroke="currentColor" stroke-width="2"/><circle cx="8.5" cy="8.5" r="1.5" fill="currentColor"/><path d="M21 15l-5-5L5 21" fill="none" stroke="currentColor" stroke-width="2"/></svg>
                    </button>
                </div>
                <div class="tool-group">
                    <button class="tool-icon" onclick="alignToCenter('v')" title="たて中央">
                        <svg viewBox="0 0 24 24"><path d="M8 19h3v4h2v-4h3l-4-4-4 4zm8-14h-3V1h-2v4H8l4 4 4-4zM4 11v2h16v-2H4z"/></svg>
                    </button>
                    <button class="tool-icon" onclick="alignToCenter('h')" title="よこ中央">
                        <svg viewBox="0 0 24 24"><path d="M19 16v-3h4v-2h-4V8l-4 4 4 4zM5 8v3H1v2h4v3l4-4-4-4zm6-4h2v16h-2V4z"/></svg>
                    </button>
                </div>
                <div class="tool-group">
                    <button class="tool-icon" id="playBtn" onclick="toggleAnimation()" title="再生/停止 (Space)">
                        <svg viewBox="0 0 24 24" id="playIcon"><path d="M8 5v14l11-7z" fill="currentColor"/></svg>
                    </button>
                    <button class="tool-icon" onclick="resetAnimation()" title="リセット">
                        <svg viewBox="0 0 24 24"><path d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z" fill="currentColor"/></svg>
                    </button>
                </div>
                <div class="tool-group" style="flex:1;max-width:150px;">
                    <input type="range" id="timeline" min="0" max="100" value="0" style="width:100%;" oninput="seekAnimation(this.value)">
                </div>
                <div class="tool-group" style="margin-left:auto;">
                    <button class="tool-icon" onclick="setToolbarSize('s')" title="小">
                        <span style="font-size:8px;">S</span>
                    </button>
                    <button class="tool-icon active" onclick="setToolbarSize('m')" title="中" id="toolbarSizeM">
                        <span style="font-size:10px;">M</span>
                    </button>
                    <button class="tool-icon" onclick="setToolbarSize('l')" title="大">
                        <span style="font-size:12px;">L</span>
                    </button>
                </div>
            </div>
            <div class="status">
                <span id="statusText">準備完了</span>
                <span id="resolution-display">1920×1080</span>
            </div>
            <div class="canvas-bar">
                <div class="canvas-bar-buttons">
                    <button class="btn btn-small btn-primary" onclick="newCanvas()">新規</button>
                    <button class="btn btn-small btn-secondary" onclick="duplicateCanvas()">複製</button>
                    <button class="btn btn-small btn-secondary" onclick="importCanvasFromProject()">インポート</button>
                    <button class="btn btn-small btn-secondary" onclick="openTranscriptionEditor()">文字起こしファイルを読込</button>
                </div>
                <div class="canvas-list-horizontal" id="canvasList"></div>
            </div>
        </div>

        <!-- 右リサイズハンドル -->
        <div class="resize-handle" id="rightResizeHandle" title="ドラッグでパネル幅を調整"></div>

        <!-- 右パネル: プロパティ -->
        <div class="panel">
            <h3 class="collapsible" onclick="toggleCollapse(this)">キャンバス設定</h3>
            <div class="collapse-content">
                <label>背景色</label>
                <div class="row2">
                    <div><input type="color" id="canvasBgColor" value="#000000" onchange="updateCanvasBackground()"></div>
                    <div><label>不透明度%</label><input type="number" id="canvasBgOpacity" min="0" max="100" value="0" onchange="updateCanvasBackground()"></div>
                </div>
                <label>背景画像</label>
                <input type="file" id="bgImageInput" accept="image/*" onchange="loadBackgroundImage(event)" style="width:100%;font-size:10px;">
                <div class="row2" style="margin-top:4px;">
                    <div><button class="btn btn-small btn-secondary" onclick="clearBackgroundImage()">画像クリア</button></div>
                    <div><label>フィット</label><select id="bgImageFit" onchange="render()" style="font-size:10px;">
                        <option value="contain">contain</option>
                        <option value="cover">cover</option>
                        <option value="stretch">stretch</option>
                    </select></div>
                </div>
                <h4>セーフマージン</h4>
                <label><input type="checkbox" id="safeMarginEnabled" checked onchange="render()"> 表示</label>
                <div class="row2">
                    <div><label>アクション%</label><input type="number" id="actionSafeMargin" min="0" max="20" value="5" onchange="render()"></div>
                    <div><label>タイトル%</label><input type="number" id="titleSafeMargin" min="0" max="20" value="10" onchange="render()"></div>
                </div>
                <div class="row2">
                    <div><label>色</label><input type="color" id="safeMarginColor" value="#ffffff" onchange="render()"></div>
                    <div><label>不透明度%</label><input type="number" id="safeMarginOpacity" min="0" max="100" value="50" onchange="render()"></div>
                </div>
            </div>

            <h3 class="collapsible" onclick="toggleCollapse(this)">文字スタイル</h3>
            <div class="collapse-content">
                <div class="char-info" id="charInfo">文字を選択してください</div>
                <label>フォント</label>
                <select id="fontFamily" onchange="handleFontChange()" style="width: 100%;">
                    <optgroup label="日本語フォント">
                        <option value="Yu Gothic UI">Yu Gothic UI</option>
                        <option value="Meiryo">メイリオ</option>
                        <option value="MS Gothic">MS ゴシック</option>
                        <option value="Hiragino Sans">ヒラギノ角ゴ</option>
                        <option value="Noto Sans JP">Noto Sans JP</option>
                    </optgroup>
                    <optgroup label="欧文フォント">
                        <option value="Arial">Arial</option>
                        <option value="Impact">Impact</option>
                        <option value="Helvetica">Helvetica</option>
                        <option value="Times New Roman">Times New Roman</option>
                        <option value="Georgia">Georgia</option>
                    </optgroup>
                    <optgroup label="デザインフォント">
                        <option value="Comic Sans MS">Comic Sans MS</option>
                        <option value="Courier New">Courier New</option>
                    </optgroup>
                    <optgroup id="systemFontsGroup" label="システムフォント" style="display:none;"></optgroup>
                    <optgroup label="カスタム">
                        <option value="__custom__">カスタムフォント...</option>
                    </optgroup>
                </select>
                <input type="text" id="customFontInput" placeholder="フォント名を入力" style="display:none; margin-top:4px;" onchange="applyCustomFont()">
                <div class="row2">
                    <div><label>サイズ</label><input type="number" id="fontSize" min="1" value="72" onchange="applyStyle()"></div>
                    <div><label>縦横比%</label><input type="number" id="charScaleX" min="10" max="400" value="100" onchange="applyStyle()"></div>
                </div>
                <div class="row2">
                    <div><label>カーニング</label><input type="number" id="charKerning" step="1" value="0" onchange="applyStyle()"></div>
                    <div><label>トラッキング</label><input type="number" id="charTracking" step="1" value="0" onchange="applyStyle()"></div>
                </div>
                <div class="row2">
                    <div><label>ベースライン</label><input type="number" id="charBaseline" step="1" value="0" onchange="applyStyle()"></div>
                    <div><label>傾き°</label><input type="number" id="charSlant" step="0.1" value="0" onchange="applyStyle()"></div>
                </div>
                <div class="row2">
                    <div><label>不透明度%</label><input type="number" id="charOpacity" min="0" max="100" value="100" onchange="applyStyle()"></div>
                </div>
                <label><input type="checkbox" id="charSmallCaps" onchange="applyStyle()"> スモールキャップス</label>
                <div class="row2">
                    <div><label>サイズ%</label><input type="number" id="charSmallCapsSize" min="10" max="100" value="70" onchange="applyStyle()"></div>
                </div>

                <h4>塗り</h4>
                <label>種類</label>
                <select id="fillType" onchange="applyStyle()">
                    <option value="solid">ベタ塗り</option>
                    <option value="linear">線形グラデーション</option>
                    <option value="radial">円形グラデーション</option>
                    <option value="none">透明（塗りなし）</option>
                </select>
                <div id="gradientStops">
                    <div class="gradient-stop" data-pos="0">
                        <div class="row2">
                            <div><label>色1</label><input type="color" class="grad-color" value="#ffffff" onchange="applyStyle()"></div>
                            <div><label>比率</label><input type="number" class="grad-ratio" value="50" min="1" max="100" onchange="applyStyle()"></div>
                        </div>
                    </div>
                    <div class="gradient-stop" data-pos="100">
                        <div class="row2">
                            <div><label>色2</label><input type="color" class="grad-color" value="#888888" onchange="applyStyle()"></div>
                            <div><label>比率</label><input type="number" class="grad-ratio" value="50" min="1" max="100" onchange="applyStyle()"></div>
                        </div>
                    </div>
                </div>
                <button class="btn btn-small btn-secondary" onclick="addGradientStop()">+ 色追加</button>
                <div class="row2" id="gradientAngleRow">
                    <div><label>角度°</label><input type="number" id="gradientAngle" value="0" step="1" onchange="applyStyle()"></div>
                    <div><label>ぼかし</label><input type="number" id="gradientBlur" min="0" max="100" value="0" step="1" onchange="applyStyle()"></div>
                </div>

                <h4>光沢</h4>
                <label><input type="checkbox" id="glossEnabled" onchange="applyStyle()"> 有効</label>
                <div class="row2">
                    <div><label>太さ</label><input type="number" id="glossWidth" min="1" max="50" value="10" onchange="applyStyle()"></div>
                    <div><label>ぼかし</label><input type="number" id="glossBlur" min="0" max="30" value="5" onchange="applyStyle()"></div>
                </div>
                <div class="row2">
                    <div><label>色</label><input type="color" id="glossColor" value="#ffffff" onchange="applyStyle()"></div>
                    <div><label>不透明度%</label><input type="number" id="glossOpacity" min="0" max="100" value="50" onchange="applyStyle()"></div>
                </div>

                <label>横揃え</label>
                <div class="align-buttons">
                    <button class="align-btn active" data-align="left" onclick="setTextAlign('left')">左</button>
                    <button class="align-btn" data-align="center" onclick="setTextAlign('center')">中央</button>
                    <button class="align-btn" data-align="right" onclick="setTextAlign('right')">右</button>
                </div>
                <label>縦揃え</label>
                <div class="align-buttons">
                    <button class="align-btn" data-valign="top" onclick="setVerticalAlign('top')">上</button>
                    <button class="align-btn active" data-valign="middle" onclick="setVerticalAlign('middle')">中央</button>
                    <button class="align-btn" data-valign="bottom" onclick="setVerticalAlign('bottom')">下</button>
                </div>
            </div>

            <h3 class="collapsible" onclick="toggleCollapse(this)">縁取り</h3>
            <div class="collapse-content">
                <div id="strokeList"></div>
                <button class="btn btn-small btn-secondary" onclick="addStroke()">+ ストローク追加</button>
            </div>

            <h3 class="collapsible" onclick="toggleCollapse(this)">影</h3>
            <div class="collapse-content">
                <label><input type="checkbox" id="shadowEnabled" onchange="applyStyle()"> 有効</label>
                <div class="row2">
                    <div><label>色</label><input type="color" id="shadowColor" value="#000000" onchange="applyStyle()"></div>
                    <div><label>不透明度%</label><input type="number" id="shadowOpacity" min="0" max="100" value="50" onchange="applyStyle()"></div>
                </div>
                <div class="row2">
                    <div><label>角度°</label><input type="number" id="shadowAngle" value="45" step="1" onchange="applyStyle()"></div>
                    <div><label>距離</label><input type="number" id="shadowDistance" value="5" step="1" onchange="applyStyle()"></div>
                </div>
                <div class="row2">
                    <div><label>サイズ</label><input type="number" id="shadowSize" value="0" step="1" onchange="applyStyle()"></div>
                    <div><label>ぼかし</label><input type="number" id="shadowBlur" value="5" step="1" onchange="applyStyle()"></div>
                </div>
            </div>

            <h3 class="collapsible collapsed" onclick="toggleCollapse(this)">名前タグ</h3>
            <div class="collapse-content hidden">
                <label><input type="checkbox" id="nameTagEnabled" onchange="updateNameTag()"> 有効</label>
                <label>名前</label>
                <input type="text" id="nameTagText" placeholder="話者名" onchange="updateNameTag()">
                <label>フォント</label>
                <select id="nameTagFont" onchange="handleNameTagFontChange()" style="width: 100%;">
                    <optgroup label="日本語フォント">
                        <option value="Yu Gothic UI">Yu Gothic UI</option>
                        <option value="Meiryo">メイリオ</option>
                        <option value="MS Gothic">MS ゴシック</option>
                        <option value="Hiragino Sans">ヒラギノ角ゴ</option>
                        <option value="Noto Sans JP">Noto Sans JP</option>
                    </optgroup>
                    <optgroup label="欧文フォント">
                        <option value="Arial">Arial</option>
                        <option value="Impact">Impact</option>
                        <option value="Helvetica">Helvetica</option>
                    </optgroup>
                    <optgroup id="nameTagSystemFontsGroup" label="システムフォント" style="display:none;"></optgroup>
                    <optgroup label="カスタム">
                        <option value="__custom__">カスタムフォント...</option>
                    </optgroup>
                </select>
                <input type="text" id="nameTagCustomFontInput" placeholder="フォント名を入力" style="display:none; margin-top:4px;" onchange="applyNameTagCustomFont()">
                <div class="row2">
                    <div><label>位置</label><select id="nameTagPosition" onchange="updateNameTag()">
                        <option value="top-left">左上</option>
                        <option value="top-center">中央上</option>
                        <option value="top-right">右上</option>
                        <option value="bottom-left">左下</option>
                        <option value="bottom-center">中央下</option>
                        <option value="bottom-right">右下</option>
                    </select></div>
                    <div><label>間隔</label><input type="number" id="nameTagGap" value="10" step="1" onchange="updateNameTag()"></div>
                </div>
                <div class="row2">
                    <div><label>文字色</label><input type="color" id="nameTagColor" value="#ffffff" onchange="updateNameTag()"></div>
                    <div><label>サイズ</label><input type="number" id="nameTagSize" value="36" min="1" onchange="updateNameTag()"></div>
                </div>
                <h4>背景</h4>
                <label><input type="checkbox" id="nameTagBgEnabled" checked onchange="updateNameTag()"> 背景表示</label>
                <div class="row2">
                    <div><label>形状</label><select id="nameTagBgShape" onchange="updateNameTag()">
                        <option value="rect">四角形</option>
                        <option value="rounded">角丸</option>
                        <option value="pill">ピル型</option>
                    </select></div>
                    <div><label>角丸</label><input type="number" id="nameTagBgRadius" value="5" min="0" onchange="updateNameTag()"></div>
                </div>
                <div class="row2">
                    <div><label>背景色</label><input type="color" id="nameTagBgColor" value="#0066cc" onchange="updateNameTag()"></div>
                    <div><label>不透明度%</label><input type="number" id="nameTagBgOpacity" min="0" max="100" value="100" onchange="updateNameTag()"></div>
                </div>
                <div class="row2">
                    <div><label>余白X</label><input type="number" id="nameTagPadX" value="10" min="0" onchange="updateNameTag()"></div>
                    <div><label>余白Y</label><input type="number" id="nameTagPadY" value="5" min="0" onchange="updateNameTag()"></div>
                </div>
                <h4>縁取り</h4>
                <label><input type="checkbox" id="nameTagStrokeEnabled" onchange="updateNameTag()"> 縁取り表示</label>
                <div class="row2">
                    <div><label>色</label><input type="color" id="nameTagStrokeColor" value="#ffffff" onchange="updateNameTag()"></div>
                    <div><label>太さ</label><input type="number" id="nameTagStrokeWidth" value="2" min="0" onchange="updateNameTag()"></div>
                </div>
            </div>

            <h3 class="collapsible collapsed" onclick="toggleCollapse(this)">吹き出し</h3>
            <div class="collapse-content hidden">
                <label><input type="checkbox" id="balloonEnabled" onchange="updateBalloon()"> 有効</label>
                <div class="row2">
                    <div><label>形状</label><select id="balloonShape" onchange="updateBalloon()">
                        <option value="rounded">角丸四角</option>
                        <option value="ellipse">楕円</option>
                        <option value="cloud">雲形</option>
                    </select></div>
                    <div><label>角丸</label><input type="number" id="balloonRadius" value="20" min="0" onchange="updateBalloon()"></div>
                </div>
                <div class="row2">
                    <div><label>余白X</label><input type="number" id="balloonPadX" value="30" min="0" onchange="updateBalloon()"></div>
                    <div><label>余白Y</label><input type="number" id="balloonPadY" value="20" min="0" onchange="updateBalloon()"></div>
                </div>
                <h4>塗り</h4>
                <div class="row2">
                    <div><label>色</label><input type="color" id="balloonFill" value="#ffffff" onchange="updateBalloon()"></div>
                    <div><label>不透明度%</label><input type="number" id="balloonFillOpacity" min="0" max="100" value="100" onchange="updateBalloon()"></div>
                </div>
                <h4>縁取り</h4>
                <label><input type="checkbox" id="balloonStrokeEnabled" checked onchange="updateBalloon()"> 縁取り表示</label>
                <div class="row2">
                    <div><label>色</label><input type="color" id="balloonStrokeColor" value="#000000" onchange="updateBalloon()"></div>
                    <div><label>太さ</label><input type="number" id="balloonStrokeWidth" value="3" min="0" onchange="updateBalloon()"></div>
                </div>
                <h4>しっぽ</h4>
                <label><input type="checkbox" id="balloonTailEnabled" checked onchange="updateBalloon()"> しっぽ表示</label>
                <div class="row2">
                    <div><label>方向</label><select id="balloonTailDir" onchange="updateBalloon()">
                        <option value="bottom">下</option>
                        <option value="top">上</option>
                        <option value="left">左</option>
                        <option value="right">右</option>
                        <option value="bottom-left">左下</option>
                        <option value="bottom-right">右下</option>
                    </select></div>
                    <div><label>位置%</label><input type="number" id="balloonTailPos" value="50" min="0" max="100" onchange="updateBalloon()"></div>
                </div>
                <div class="row2">
                    <div><label>幅</label><input type="number" id="balloonTailWidth" value="20" min="1" onchange="updateBalloon()"></div>
                    <div><label>長さ</label><input type="number" id="balloonTailLength" value="30" min="1" onchange="updateBalloon()"></div>
                </div>
            </div>

            <h3 class="collapsible collapsed" onclick="toggleCollapse(this)">図形設定</h3>
            <div class="collapse-content hidden" id="shapeSettings">
                <h4>塗り</h4>
                <label>種類</label>
                <select id="shapeFillType" onchange="updateShapeStyle()">
                    <option value="solid">ベタ塗り</option>
                    <option value="linear">線形グラデーション</option>
                    <option value="radial">円形グラデーション</option>
                    <option value="none">透明（塗りなし）</option>
                </select>
                <div class="row2">
                    <div><label>色</label><input type="color" id="shapeFill" value="#ffffff" onchange="updateShapeStyle()"></div>
                    <div><label>不透明度%</label><input type="number" id="shapeFillOpacity" min="0" max="100" value="100" onchange="updateShapeStyle()"></div>
                </div>
                <div id="shapeGradientSettings">
                    <div class="row2">
                        <div><label>色2</label><input type="color" id="shapeFill2" value="#888888" onchange="updateShapeStyle()"></div>
                        <div><label>角度°</label><input type="number" id="shapeGradientAngle" value="0" step="1" onchange="updateShapeStyle()"></div>
                    </div>
                </div>
                <h4>縁取り</h4>
                <div class="row2">
                    <div><label>色</label><input type="color" id="shapeStroke" value="#000000" onchange="updateShapeStyle()"></div>
                    <div><label>太さ</label><input type="number" id="shapeStrokeWidth" value="2" min="0" onchange="updateShapeStyle()"></div>
                </div>
                <div class="row2">
                    <div><label>不透明度%</label><input type="number" id="shapeStrokeOpacity" min="0" max="100" value="100" onchange="updateShapeStyle()"></div>
                </div>
            </div>

            <h3 class="collapsible collapsed" onclick="toggleCollapse(this)">パス上文字設定</h3>
            <div class="collapse-content hidden" id="pathTextSettings">
                <label><input type="checkbox" id="pathTextVertical" onchange="updatePathTextStyle()"> 縦書き</label>
                <label>パスオフセット</label>
                <input type="number" id="pathTextOffset" value="0" step="10" onchange="updatePathTextStyle()">
            </div>

            <h3 class="collapsible collapsed" onclick="toggleCollapse(this)">ペンパス設定</h3>
            <div class="collapse-content hidden" id="penPathSettings">
                <h4>塗り</h4>
                <label>種類</label>
                <select id="penPathFillType" onchange="updatePenPathStyle()">
                    <option value="none">透明（塗りなし）</option>
                    <option value="solid">ベタ塗り</option>
                </select>
                <div class="row2">
                    <div><label>色</label><input type="color" id="penPathFill" value="#ffffff" onchange="updatePenPathStyle()"></div>
                    <div><label>不透明度%</label><input type="number" id="penPathFillOpacity" min="0" max="100" value="100" onchange="updatePenPathStyle()"></div>
                </div>
                <h4>ストローク</h4>
                <div class="row2">
                    <div><label>色</label><input type="color" id="penPathStroke" value="#ffffff" onchange="updatePenPathStyle()"></div>
                    <div><label>太さ</label><input type="number" id="penPathStrokeWidth" value="3" min="1" onchange="updatePenPathStyle()"></div>
                </div>
                <div class="row2">
                    <div><label>不透明度%</label><input type="number" id="penPathStrokeOpacity" min="0" max="100" value="100" onchange="updatePenPathStyle()"></div>
                </div>
                <div style="margin-top:6px;">
                    <label><input type="checkbox" id="penPathClosed" onchange="updatePenPathStyle()"> パスを閉じる</label>
                </div>
            </div>

            <h3 class="collapsible collapsed" onclick="toggleCollapse(this)">画像設定</h3>
            <div class="collapse-content hidden" id="imageSettings">
                <div class="row2">
                    <div><label>幅</label><input type="number" id="imageWidth" min="1" onchange="updateImageSize()"></div>
                    <div><label>高さ</label><input type="number" id="imageHeight" min="1" onchange="updateImageSize()"></div>
                </div>
                <div style="margin-top:6px;">
                    <label><input type="checkbox" id="imageLockAspect" checked> 縦横比を維持</label>
                </div>
                <h4>反転</h4>
                <div style="display:flex;gap:4px;">
                    <button class="btn btn-small btn-secondary" onclick="flipImage('h')">左右反転</button>
                    <button class="btn btn-small btn-secondary" onclick="flipImage('v')">上下反転</button>
                </div>
                <h4>トリミング</h4>
                <div class="row2">
                    <div><label>左</label><input type="number" id="imageCropLeft" min="0" value="0" onchange="updateImageCrop()"></div>
                    <div><label>上</label><input type="number" id="imageCropTop" min="0" value="0" onchange="updateImageCrop()"></div>
                </div>
                <div class="row2">
                    <div><label>右</label><input type="number" id="imageCropRight" min="0" value="0" onchange="updateImageCrop()"></div>
                    <div><label>下</label><input type="number" id="imageCropBottom" min="0" value="0" onchange="updateImageCrop()"></div>
                </div>
                <h4>色透過</h4>
                <div class="row2">
                    <div><label>色</label><input type="color" id="imageTransparentColor" value="#00ff00" onchange="updateImageTransparency()"></div>
                    <div><label>許容値</label><input type="number" id="imageTransparentTolerance" min="0" max="255" value="30" onchange="updateImageTransparency()"></div>
                </div>
                <div style="margin-top:4px;">
                    <label><input type="checkbox" id="imageTransparentEnabled" onchange="updateImageTransparency()"> 透過有効</label>
                    <button class="btn btn-small btn-secondary" onclick="pickTransparentColor()" style="margin-left:4px;">スポイト</button>
                </div>
                <h4>ストローク</h4>
                <div class="row2">
                    <div><label>色</label><input type="color" id="imageStrokeColor" value="#000000" onchange="updateImageStroke()"></div>
                    <div><label>太さ</label><input type="number" id="imageStrokeWidth" value="0" min="0" onchange="updateImageStroke()"></div>
                </div>
            </div>

            <h3 class="collapsible collapsed" onclick="toggleCollapse(this)">アニメーション</h3>
            <div class="collapse-content hidden" id="animationSettings">
                <div><label>種類</label>
                    <select id="animType" onchange="updateAnimation()">
                        <option value="none">なし</option>
                        <option value="preset">プリセート</option>
                        <option value="fadeIn">フェードイン</option>
                        <option value="fadeOut">フェードアウト</option>
                        <option value="slideLeft">左からスライド</option>
                        <option value="slideRight">右からスライド</option>
                        <option value="slideUp">上からスライド</option>
                        <option value="slideDown">下からスライド</option>
                        <option value="typewriter">タイプライター</option>
                        <option value="rotateIn">回転出現</option>
                        <option value="cursorReveal">カーソル追従</option>
                        <option value="zoomIn">ズームイン</option>
                        <option value="splitMerge">分割合体</option>
                        <option value="slot">スロット</option>
                        <option value="rollUp">縦エンドロール</option>
                        <option value="rollLeft">横エンドロール</option>
                    </select>
                </div>
                <div class="row2">
                    <div><label>時間(秒)</label><input type="number" id="animDuration" value="2" min="0.1" step="0.1" onchange="updateAnimation()"></div>
                    <div><label>遅延(秒)</label><input type="number" id="animDelay" value="0" min="0" step="0.1" onchange="updateAnimation()"></div>
                </div>
                <div class="row2">
                    <div><label>速度</label><input type="number" id="animSpeed" value="100" min="10" step="10" onchange="updateAnimation()"></div>
                </div>
                <div style="margin-top:6px;">
                    <label>イージング</label>
                    <select id="animEasing" onchange="updateAnimation()">
                        <option value="linear">リニア</option>
                        <option value="easeIn">イーズイン</option>
                        <option value="easeOut">イーズアウト</option>
                        <option value="easeInOut">イーズインアウト</option>
                    </select>
                </div>
                <div style="margin-top:6px;">
                    <label><input type="checkbox" id="animLoop" onchange="updateAnimation()"> ループ再生</label>
                </div>
                <h4 style="margin-top:10px;">キーフレーム</h4>
                <div id="keyframeList" style="max-height:150px;overflow-y:auto;border:1px solid #555;padding:4px;margin-bottom:6px;"></div>
                <div style="display:flex;gap:4px;">
                    <button class="btn btn-small btn-secondary" onclick="addKeyframe()">追加</button>
                    <button class="btn btn-small btn-secondary" onclick="addKeyframeFromCurrent()">現在値で追加</button>
                </div>
            </div>

            <h3 class="collapsible collapsed" onclick="toggleCollapse(this)">アニメーションプリセット</h3>
            <div class="collapse-content hidden" id="animationPresetSettings">
                <div style="display:flex;gap:4px;margin-bottom:8px;">
                    <button id="animPresetInBtn" class="btn btn-small" style="flex:1;background:#4a9eff;" onclick="switchAnimPresetType('in')">IN</button>
                    <button id="animPresetOutBtn" class="btn btn-small btn-secondary" style="flex:1;" onclick="switchAnimPresetType('out')">OUT</button>
                </div>
                <div id="animPresetCategories" style="display:flex;flex-wrap:wrap;gap:4px;margin-bottom:8px;">
                    <button class="btn btn-small" style="font-size:11px;" onclick="filterAnimPresets('all')">全て</button>
                    <button class="btn btn-small btn-secondary" style="font-size:11px;" onclick="filterAnimPresets('simple')">シンプル</button>
                    <button class="btn btn-small btn-secondary" style="font-size:11px;" onclick="filterAnimPresets('modern')">モダン</button>
                    <button class="btn btn-small btn-secondary" style="font-size:11px;" onclick="filterAnimPresets('dynamic')">ダイナミック</button>
                    <button class="btn btn-small btn-secondary" style="font-size:11px;" onclick="filterAnimPresets('elastic')">弾性</button>
                    <button class="btn btn-small btn-secondary" style="font-size:11px;" onclick="filterAnimPresets('creative')">クリエイティブ</button>
                </div>
                <div id="animPresetList" style="max-height:200px;overflow-y:auto;border:1px solid #555;padding:4px;margin-bottom:6px;">
                    <div style="color:#888;text-align:center;padding:20px;">プリセットを読み込み中...</div>
                </div>
                <div style="display:flex;gap:4px;margin-bottom:6px;">
                    <button class="btn btn-small" onclick="applyAnimPreset()">適用</button>
                    <button class="btn btn-small btn-secondary" onclick="previewAnimPreset()">プレビュー</button>
                </div>
                <div id="animPresetStatus" style="font-size:10px;color:#4a9eff;min-height:14px;"></div>
            </div>

            <h3 class="collapsible collapsed" onclick="toggleCollapse(this)">スタイルプリセット</h3>
            <div class="collapse-content hidden" id="stylePresetSettings">
                <div id="stylePresetCategories" style="display:flex;flex-wrap:wrap;gap:4px;margin-bottom:8px;">
                    <button class="btn btn-small" style="font-size:11px;" onclick="filterStylePresets('all')">全て</button>
                    <button class="btn btn-small btn-secondary" style="font-size:11px;" onclick="filterStylePresets('cartoon')">カートゥーン</button>
                    <button class="btn btn-small btn-secondary" style="font-size:11px;" onclick="filterStylePresets('cinematic')">シネマティック</button>
                    <button class="btn btn-small btn-secondary" style="font-size:11px;" onclick="filterStylePresets('modern')">モダン</button>
                    <button class="btn btn-small btn-secondary" style="font-size:11px;" onclick="filterStylePresets('simple')">シンプル</button>
                    <button class="btn btn-small btn-secondary" style="font-size:11px;" onclick="filterStylePresets('news')">ニュース</button>
                    <button class="btn btn-small btn-secondary" style="font-size:11px;" onclick="filterStylePresets('variety')">バラエティ</button>
                </div>
                <div id="stylePresetList" style="max-height:200px;overflow-y:auto;border:1px solid #555;padding:4px;margin-bottom:6px;">
                    <div style="color:#888;text-align:center;padding:20px;">プリセットを読み込み中...</div>
                </div>
                <div style="display:flex;gap:4px;flex-wrap:wrap;margin-bottom:6px;">
                    <button class="btn btn-small" onclick="applyStylePreset('selected')">選択文字に適用</button>
                    <button class="btn btn-small btn-secondary" onclick="applyStylePreset('all')">全文字に適用</button>
                </div>
                <div style="margin-bottom:6px;">
                    <button class="btn btn-small btn-secondary" style="width:100%;" onclick="saveCurrentStyle()">現在のスタイルを保存</button>
                </div>
                <div id="stylePresetStatus" style="font-size:10px;color:#4a9eff;min-height:14px;"></div>
            </div>
        </div>
    </div>

    <input type="file" id="fileInput" accept=".json,.telop" style="display:none" onchange="handleFileLoad(event)">
    <input type="file" id="importFileInput" accept=".json" style="display:none" onchange="handleImportProject(event)">
    <input type="file" id="imageInput" accept="image/*" style="display:none" onchange="handleImageLoad(event)">
    <input type="text" id="imeInput" autocomplete="off">

    <script>
        // ==================== PRTL Generator Class ====================
        /**
         * PRTL Generator - Premiere Pro Legacy Title File Generator
         * キャンバスデータからPRTLファイル(Adobe Premiere Pro レガシータイトル)を生成
         */
        class PRTLGenerator {
            constructor() {
                this.idCounter = 4096;
                this.shaderCounter = 4096;
                this.styleCounter = 4096;
            }

            generatePRTL(canvasData) {
                const [width, height] = (canvasData.resolution || '1920x1080').split('x').map(Number);
                const objects = canvasData.objects || [];
                return this._buildPRTLXML(width, height, objects);
            }

            _buildPRTLXML(width, height, objects) {
                const fonts = this._collectUniqueFonts(objects);
                const styles = this._buildStyles(objects);
                const shaders = this._buildShaders(objects);
                const textDescriptions = this._buildTextDescriptions(fonts, objects);
                const textures = this._buildTextures();
                const logos = this._buildLogos();
                const layers = this._buildLayers(objects);

                return `<?xml version="1.0" encoding="UTF-16" ?><Adobe_Root><Adobe_Title><Version>20080702</Version><Motion_Settings><Play_Forward>true</Play_Forward><Start_on_Screen>false</Start_on_Screen><Pre_Roll>0</Pre_Roll><Ease_In>0</Ease_In><End_off_Screen>false</End_off_Screen><Post_Roll>0</Post_Roll><Ease_Out>0</Ease_Out></Motion_Settings></Adobe_Title><InscriberLayouts Version="1.0"><Layout><LayoutEffectInfo Version="2"><EffectType>0</EffectType><Indic>false</Indic><Ligatures>false</Ligatures><HindiDigits>false</HindiDigits></LayoutEffectInfo><LayoutDimension Version="2"><pXPIXELS>${width}</pXPIXELS><pYLINES>${height}</pYLINES><pSCREENAR>1</pSCREENAR><growthDirection>growRightDown</growthDirection></LayoutDimension><LayoutAttributes><SafeTitleArea><left>0.1</left><top>0.1</top><right>0.9</right><bottom>0.9</bottom></SafeTitleArea><SafeActionArea><left>0.05</left><top>0.05</top><right>0.95</right><bottom>0.95</bottom></SafeActionArea></LayoutAttributes><Background Version="4"><ShaderReference>4098</ShaderReference><On>false</On><paintingRange>normalLayout</paintingRange></Background><DefaultStyle><Reference>${this.styleCounter}</Reference></DefaultStyle><DefaultTextDescription><Reference>${this.idCounter}</Reference></DefaultTextDescription><GraphicObjectDefaults><endCapType>square</endCapType><joinTypeClosed>round</joinTypeClosed><joinTypeOpen>round</joinTypeOpen><lineWidth>5</lineWidth><miterLimit>5</miterLimit><windBeziers>false</windBeziers><roundCornerFillets>37.5 37.5 37.5 37.5 37.5 37.5 37.5 37.5 </roundCornerFillets><clippedCornerFillets>37.5 37.5 37.5 37.5 37.5 37.5 37.5 37.5 </clippedCornerFillets></GraphicObjectDefaults><TextChainDefaults><normal><leading>0</leading><boxCanGrow>false</boxCanGrow><wordWrap>true</wordWrap><lockedLinesX>false</lockedLinesX><lockedLinesY>false</lockedLinesY><Alignment>left</Alignment><tabModeStyle>Word</tabModeStyle><implicitTabSpacing>100</implicitTabSpacing><implicitTabType>left</implicitTabType><rtl>false</rtl><tabs></tabs></normal><boxNormal><leading>0</leading><boxCanGrow>false</boxCanGrow><wordWrap>true</wordWrap><lockedLinesX>true</lockedLinesX><lockedLinesY>true</lockedLinesY><Alignment>left</Alignment><tabModeStyle>Word</tabModeStyle><implicitTabSpacing>100</implicitTabSpacing><implicitTabType>left</implicitTabType><rtl>false</rtl><tabs></tabs></boxNormal><blockNormal><leading>0</leading><boxCanGrow>false</boxCanGrow><wordWrap>false</wordWrap><lockedLinesX>true</lockedLinesX><lockedLinesY>true</lockedLinesY><Alignment>left</Alignment><tabModeStyle>Word</tabModeStyle><implicitTabSpacing>100</implicitTabSpacing><implicitTabType>left</implicitTabType><rtl>false</rtl><tabs></tabs></blockNormal><spline><leading>0</leading><boxCanGrow>false</boxCanGrow><wordWrap>false</wordWrap><lockedLinesX>false</lockedLinesX><lockedLinesY>false</lockedLinesY><Alignment>left</Alignment><tabModeStyle>Word</tabModeStyle><implicitTabSpacing>100</implicitTabSpacing><implicitTabType>left</implicitTabType><rtl>false</rtl><tabs></tabs></spline></TextChainDefaults>${textDescriptions}${styles}${shaders}${textures}${logos}${layers}<VLS><FileReference Version="1"><fileString></fileString><seClass>2</seClass><seCode>1000</seCode></FileReference></VLS></Layout></InscriberLayouts></Adobe_Root>`;
            }

            _collectUniqueFonts(objects) {
                const fontSet = new Set();
                objects.forEach(obj => {
                    if (obj.type === 'text' && obj.chars) {
                        obj.chars.forEach(char => {
                            if (char.fontFamily) fontSet.add(char.fontFamily);
                        });
                    }
                });
                return Array.from(fontSet);
            }

            _buildTextDescriptions(fonts, objects) {
                if (fonts.length === 0) fonts = ['Yu Gothic UI'];

                // 代表的なフォントサイズを取得（最初のテキストオブジェクトから）
                let representativeFontSize = 72;
                for (const obj of objects) {
                    if (obj.type === 'text' && obj.chars && obj.chars[0] && obj.chars[0].fontSize) {
                        representativeFontSize = obj.chars[0].fontSize;
                        break;
                    }
                }

                // フォント情報の整合性確保
                // txHeight = fontSize (実際のフォントサイズ、_buildSingleStyleと一致)
                // sizeValue = fontSize * 8.21 (PRTLフォーマットの内部サイズ値、75→616の比率)
                // txSCaps = fontSize (スモールキャップのサイズ)
                // これらの値は _buildSingleStyle、_buildTextChain と整合性を保つ

                let xml = '<TextDescriptions Version="4">';
                fonts.forEach((fontFamily, index) => {
                    const ref = this.idCounter + index;
                    const txHeight = representativeFontSize;
                    const sizeValue = Math.round(representativeFontSize * 8.21);
                    const txSCaps = representativeFontSize;
                    xml += `<TextDescription Reference="${ref}"><TypeSpec><size>${sizeValue}</size><txHeight>${txHeight}</txHeight><txKern>0</txKern><baselineShift>0</baselineShift><leading>0</leading><txSCaps>${txSCaps}</txSCaps><txSCapsOn>false</txSCapsOn><txSlant>0</txSlant><txUnderline>false</txUnderline><txWidth>67.5</txWidth><linked>false</linked><fiBold>0</fiBold><fiItalic>0</fiItalic><fifullName>${this._escapeXML(fontFamily)}</fifullName><fifontFamilyName>${this._escapeXML(fontFamily)}</fifontFamilyName><fifontStyle>Regular</fifontStyle><fifontType>5</fifontType><ficategory>1</ficategory></TypeSpec></TextDescription>`;
                });
                xml += '</TextDescriptions>';
                return xml;
            }

            _buildStyles(objects) {
                let xml = '<Styles>';
                objects.forEach((obj, index) => {
                    if (obj.type === 'text' && obj.chars && obj.chars.length > 0) {
                        xml += this._buildSingleStyle(obj, index);
                    }
                });
                if (objects.length === 0) xml += this._buildDefaultStyle();
                xml += '</Styles>';
                return xml;
            }

            _buildSingleStyle(obj, index) {
                const styleId = this.styleCounter + index;
                const firstChar = obj.chars[0];
                const strokes = firstChar.strokes || [];
                const fontSize = firstChar.fontSize || 72;
                let fragments = '';

                // 整合性確保：txBase、txHeight、fillSizeの関係を統一
                // txBase = fontSize * 1.2 (BasePropertiesで使用)
                // txHeight = fontSize (実際のフォントサイズ)
                // fillSize = txHeight * 1.04 (塗りのFragmentサイズ、PRTLサンプルの比率)
                const txBase = fontSize * 1.2;
                const txHeight = fontSize;
                const fillSize = Math.round(txHeight * 1.04);

                // 1. 塗り (annotation 4, painterMix 10) を最初に追加
                fragments += `<Fragment><size>${fillSize}</size><offset>0</offset><angle>0</angle><ghost>false</ghost><isExtendedShadowFragment>false</isExtendedShadowFragment><eFragmentType>2</eFragmentType><fragmentOff>false</fragmentOff><placeHolder>false</placeHolder><annotation>4</annotation><placeHolderShaderIndex>4294967295</placeHolderShaderIndex><painterMix>10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 </painterMix></Fragment>`;

                // 2. アウトライン (annotation 3, 2, ...) - 有効なストロークがある場合
                const enabledStrokes = strokes.filter(s => s.enabled);
                if (enabledStrokes.length > 0) {
                    // アウトラインを外側から内側へ（annotation 3, 2, 1...の順）
                    enabledStrokes.forEach((stroke, i) => {
                        const annotation = 3 - i; // 3, 2, 1...
                        const painterNum = 11 + i; // 11, 12, 13...
                        if (annotation >= 1) {
                            // ストローク幅の整合性確保：UIの幅値を適切にスケーリング
                            // stroke.widthはUI上のピクセル値、Fragment sizeはフォントサイズに対する相対値
                            // txHeightに対する比率で計算し、適切にスケーリング
                            const strokeSize = Math.round(stroke.width * txHeight / 36);
                            fragments += `<Fragment><size>${strokeSize}</size><offset>0</offset><angle>0</angle><ghost>false</ghost><isExtendedShadowFragment>false</isExtendedShadowFragment><eFragmentType>2</eFragmentType><fragmentOff>false</fragmentOff><placeHolder>false</placeHolder><annotation>${annotation}</annotation><placeHolderShaderIndex>4294967295</placeHolderShaderIndex><painterMix>${painterNum} ${painterNum} ${painterNum} ${painterNum} ${painterNum} ${painterNum} ${painterNum} ${painterNum} ${painterNum} ${painterNum} ${painterNum} ${painterNum} ${painterNum} ${painterNum} ${painterNum} ${painterNum} </painterMix></Fragment>`;
                        }
                    });
                }

                // 3. 3D押し出し (annotation 65538, painterMix 15)
                fragments += `<Fragment><size>0</size><offset>0</offset><angle>0</angle><ghost>false</ghost><isExtendedShadowFragment>false</isExtendedShadowFragment><eFragmentType>0</eFragmentType><fragmentOff>false</fragmentOff><placeHolder>false</placeHolder><annotation>65538</annotation><placeHolderShaderIndex>4294967295</placeHolderShaderIndex><painterMix>15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 </painterMix></Fragment>`;

                // 4. 3Dシャドウ (annotation 65537, painterMix 0)
                const shadowEnabled = firstChar.shadow?.enabled || false;
                const shadowDistance = firstChar.shadow?.offsetX || 10;
                const shadowAngle = Math.atan2(firstChar.shadow?.offsetY || 5, firstChar.shadow?.offsetX || 5) * 180 / Math.PI;
                fragments += `<Fragment><size>0</size><offset>${shadowDistance}</offset><angle>${shadowAngle}</angle><ghost>false</ghost><isExtendedShadowFragment>true</isExtendedShadowFragment><eFragmentType>0</eFragmentType><fragmentOff>${!shadowEnabled}</fragmentOff><placeHolder>false</placeHolder><annotation>65537</annotation><placeHolderShaderIndex>4294967295</placeHolderShaderIndex><painterMix>0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 </painterMix></Fragment>`;

                // ShaderListの生成
                let shaderList = '';
                // PainterNumber 2-15
                for (let i = 2; i <= 15; i++) {
                    const shaderRef = i >= 10 && i <= 13 ? (this.shaderCounter + index * 20 + (i - 10)) : 0;
                    shaderList += `<ShaderRef PainterNumber="${i}"><shaderRef>${shaderRef}</shaderRef></ShaderRef>`;
                }
                // PainterNumber -1 は塗りのシェーダーを参照（painter 10と同じ）
                shaderList += `<ShaderRef PainterNumber="-1"><shaderRef>${this.shaderCounter + index * 20 + 0}</shaderRef></ShaderRef>`;
                // PainterNumber 1000-1015
                for (let i = 1000; i <= 1015; i++) {
                    shaderList += `<ShaderRef PainterNumber="${i}"><shaderRef>0</shaderRef></ShaderRef>`;
                }

                return `<Style ID="${styleId}"><StyleBase Version="4"><type>50000</type><positionDominance>0</positionDominance><lineGradient>false</lineGradient><styleRef>${styleId}</styleRef><faceDistortX>0</faceDistortX><faceDistortY>0</faceDistortY><shadow_softness>30</shadow_softness><personality>0</personality><linked>false</linked><EmbellishmentSizeRule>false</EmbellishmentSizeRule><PainterRampType>Basic</PainterRampType></StyleBase><FragmentList Version="5">${fragments}</FragmentList><ShaderList Version="1">${shaderList}</ShaderList></Style>`;
            }

            _buildDefaultStyle() {
                const styleId = this.styleCounter;
                // 正しい順序でFragmentを配置：塗り（4）→アウトライン（3,2）→3D押し出し（65538）→3Dシャドウ（65537）
                const fragments = `<Fragment><size>0</size><offset>0</offset><angle>0</angle><ghost>false</ghost><isExtendedShadowFragment>false</isExtendedShadowFragment><eFragmentType>2</eFragmentType><fragmentOff>false</fragmentOff><placeHolder>false</placeHolder><annotation>4</annotation><placeHolderShaderIndex>4294967295</placeHolderShaderIndex><painterMix>10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 </painterMix></Fragment><Fragment><size>60</size><offset>0</offset><angle>0</angle><ghost>false</ghost><isExtendedShadowFragment>false</isExtendedShadowFragment><eFragmentType>2</eFragmentType><fragmentOff>false</fragmentOff><placeHolder>false</placeHolder><annotation>3</annotation><placeHolderShaderIndex>4294967295</placeHolderShaderIndex><painterMix>11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 </painterMix></Fragment><Fragment><size>30</size><offset>0</offset><angle>0</angle><ghost>false</ghost><isExtendedShadowFragment>false</isExtendedShadowFragment><eFragmentType>2</eFragmentType><fragmentOff>false</fragmentOff><placeHolder>false</placeHolder><annotation>2</annotation><placeHolderShaderIndex>4294967295</placeHolderShaderIndex><painterMix>12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 12 </painterMix></Fragment><Fragment><size>0</size><offset>0</offset><angle>0</angle><ghost>false</ghost><isExtendedShadowFragment>false</isExtendedShadowFragment><eFragmentType>0</eFragmentType><fragmentOff>false</fragmentOff><placeHolder>false</placeHolder><annotation>65538</annotation><placeHolderShaderIndex>4294967295</placeHolderShaderIndex><painterMix>15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 </painterMix></Fragment><Fragment><size>0</size><offset>10</offset><angle>-45</angle><ghost>false</ghost><isExtendedShadowFragment>true</isExtendedShadowFragment><eFragmentType>0</eFragmentType><fragmentOff>true</fragmentOff><placeHolder>false</placeHolder><annotation>65537</annotation><placeHolderShaderIndex>4294967295</placeHolderShaderIndex><painterMix>0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 </painterMix></Fragment>`;
                return `<Style ID="${styleId}"><StyleBase Version="4"><type>50000</type><positionDominance>0</positionDominance><lineGradient>false</lineGradient><styleRef>${styleId}</styleRef><faceDistortX>0</faceDistortX><faceDistortY>0</faceDistortY><shadow_softness>30</shadow_softness><personality>0</personality><linked>false</linked><EmbellishmentSizeRule>false</EmbellishmentSizeRule><PainterRampType>Basic</PainterRampType></StyleBase><FragmentList Version="5">${fragments}</FragmentList><ShaderList Version="1"><ShaderRef PainterNumber="10"><shaderRef>4098</shaderRef></ShaderRef><ShaderRef PainterNumber="11"><shaderRef>4099</shaderRef></ShaderRef><ShaderRef PainterNumber="12"><shaderRef>4100</shaderRef></ShaderRef><ShaderRef PainterNumber="-1"><shaderRef>4098</shaderRef></ShaderRef></ShaderList></Style>`;
            }

            _buildShaders(objects) {
                let xml = '<Shaders>';
                objects.forEach((obj, index) => {
                    if (obj.type === 'text' && obj.chars && obj.chars.length > 0) {
                        const char = obj.chars[0];
                        const strokes = char.strokes || [];

                        // 1. 塗り用シェーダー（index * 20 + 0, painter 10用）
                        const fillRef = this.shaderCounter + index * 20 + 0;
                        const fillRGB = this._hexToRGB(char.color || '#ffffff');
                        xml += `<Shader Version="4"><cReference>${fillRef}</cReference><textureRef>0</textureRef><colorOption>4</colorOption><shaderOn>true</shaderOn><glintSize>10</glintSize><glintOffset>0</glintOffset><rampPosTop>75</rampPosTop><rampPosBottom>25</rampPosBottom><rampAngle>0</rampAngle><bevelBalance>0</bevelBalance><rampCycle>0</rampCycle><classicStyle>0</classicStyle><rampType>0</rampType><ColorSpec index="0"><red>${fillRGB.r}</red><green>${fillRGB.g}</green><blue>${fillRGB.b}</blue><xpar>0</xpar></ColorSpec><ColorSpec index="1"><red>0</red><green>0</green><blue>0</blue><xpar>0</xpar></ColorSpec><ColorSpec index="2"><red>0</red><green>0</green><blue>0</blue><xpar>0</xpar></ColorSpec><ColorSpec index="3"><red>0</red><green>0</green><blue>0</blue><xpar>0</xpar></ColorSpec><ColorSpec index="4"><red>250</red><green>250</green><blue>250</blue><xpar>0</xpar></ColorSpec><glintAngle>0</glintAngle><bevelSize>0</bevelSize><bevelDirection>0</bevelDirection><bevelPipe>false</bevelPipe><bevelAngle>0</bevelAngle><bevelShape>1</bevelShape><bevelShining>0</bevelShining><bevelLight>false</bevelLight><bevelMerge>true</bevelMerge><sheenOn>false</sheenOn></Shader>`;

                        // 2. アウトライン用シェーダー（index * 20 + 1, 2, 3..., painter 11, 12, 13用）
                        const enabledStrokes = strokes.filter(s => s.enabled);
                        enabledStrokes.forEach((stroke, i) => {
                            const ref = this.shaderCounter + index * 20 + 1 + i;
                            const rgb = this._hexToRGB(stroke.color);
                            xml += `<Shader Version="4"><cReference>${ref}</cReference><textureRef>0</textureRef><colorOption>4</colorOption><shaderOn>true</shaderOn><glintSize>10</glintSize><glintOffset>0</glintOffset><rampPosTop>75</rampPosTop><rampPosBottom>25</rampPosBottom><rampAngle>0</rampAngle><bevelBalance>0</bevelBalance><rampCycle>0</rampCycle><classicStyle>0</classicStyle><rampType>0</rampType><ColorSpec index="0"><red>0</red><green>0</green><blue>0</blue><xpar>0</xpar></ColorSpec><ColorSpec index="1"><red>0</red><green>0</green><blue>0</blue><xpar>0</xpar></ColorSpec><ColorSpec index="2"><red>0</red><green>0</green><blue>0</blue><xpar>0</xpar></ColorSpec><ColorSpec index="3"><red>0</red><green>0</green><blue>0</blue><xpar>0</xpar></ColorSpec><ColorSpec index="4"><red>${rgb.r}</red><green>${rgb.g}</green><blue>${rgb.b}</blue><xpar>0</xpar></ColorSpec><glintAngle>0</glintAngle><bevelSize>0</bevelSize><bevelDirection>0</bevelDirection><bevelPipe>false</bevelPipe><bevelAngle>0</bevelAngle><bevelShape>1</bevelShape><bevelShining>0</bevelShining><bevelLight>false</bevelLight><bevelMerge>true</bevelMerge><sheenOn>false</sheenOn></Shader>`;
                        });
                    }
                });
                xml += '</Shaders>';
                return xml;
            }

            _buildTextures() {
                return '<Textures></Textures>';
            }

            _buildLogos() {
                return '<Logos></Logos>';
            }

            _buildLayers(objects) {
                let xml = '<Layers><Layer><DrawPage></DrawPage><TextPage>';

                // TextChainを生成
                objects.forEach((obj, index) => {
                    if (obj.type === 'text' && obj.chars) {
                        xml += this._buildTextChain(obj, index);
                    }
                });

                xml += '</TextPage><MergeGroups>';

                // MergeGroupsを生成
                objects.forEach((obj, index) => {
                    if (obj.type === 'text' && obj.chars) {
                        const groupID = index + 1;
                        const objectID = index + 1;
                        const opacity = (obj.opacity || 100) / 100;
                        xml += `<Group groupID="${groupID}"><punchThru>false</punchThru><opacity>${opacity}</opacity><ObjectID value="${objectID}" /></Group>`;
                    }
                });

                xml += '</MergeGroups></Layer></Layers>';
                return xml;
            }

            _buildTextChain(obj, index) {
                const styleRef = this.styleCounter + index;
                const textDescRef = this.idCounter;
                const text = obj.chars.map(c => c.char).join('');
                const textLength = text.length;

                const x = obj.x || 0;
                const y = obj.y || 0;
                const fontSize = obj.chars[0]?.fontSize || 48;
                const estimatedWidth = textLength * fontSize * 0.8;
                const width = obj.width || estimatedWidth;
                const height = obj.height || fontSize * 1.5;

                // フォント情報の整合性確保：_buildSingleStyleと同じ計算式を使用
                // txBase = fontSize * 1.2 (ベースライン位置の基準)
                const txBase = fontSize * 1.2;

                let xml = '<TextChain>';
                xml += `<ChainProperty Version="9">`;
                xml += `<wordWrap>false</wordWrap>`;
                xml += `<Position><x>${x}</x><y>${y}</y></Position>`;
                xml += `<Size><x>${width}</x><y>${height}</y></Size>`;
                xml += `<leading>0</leading>`;
                xml += `<lockedLinesX>true</lockedLinesX>`;
                xml += `<lockedLinesY>true</lockedLinesY>`;
                xml += `<boxCanGrow>false</boxCanGrow>`;
                xml += `<tabModeStyle>Word</tabModeStyle>`;
                xml += `<implicitTabSpacing>100</implicitTabSpacing>`;
                xml += `<implicitTabType>left</implicitTabType>`;
                xml += `</ChainProperty>`;
                xml += `<ChainTabs><TabList></TabList></ChainTabs>`;

                const objectID = index + 1;
                const persistentID = index + 3;
                xml += `<TextLine Version="2" objectID="${objectID}" persistentID="${persistentID}">`;

                xml += `<BaseProperties Version="5">`;
                xml += `<txBase>${txBase}</txBase>`;
                xml += `<XPos>${x}</XPos>`;
                xml += `<angle>${obj.rotation || 0}</angle>`;
                xml += `<verticalText>false</verticalText>`;
                xml += `<objectLeading>0</objectLeading>`;
                xml += `</BaseProperties>`;

                xml += `<EnclosingObjectType>block</EnclosingObjectType>`;
                xml += `<Alignment>left</Alignment>`;
                xml += `<RTL>false</RTL>`;
                xml += `<TRString>${this._escapeXML(text)}</TRString>`;

                xml += `<RunLengthEncodedCharacterAttributes>`;
                xml += `<CharacterAttributes RunCount="${textLength}" StyleRef="${styleRef}" TextRef="${textDescRef}" TXKerning="0" TXPostKerning="0" BaselineShifting="0" />`;
                xml += `</RunLengthEncodedCharacterAttributes>`;

                xml += `<tagName></tagName>`;
                xml += `</TextLine>`;
                xml += '</TextChain>';

                return xml;
            }

            _hexToRGB(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : { r: 255, g: 255, b: 255 };
            }

            _escapeXML(str) {
                if (!str) return '';
                return str.toString()
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&apos;');
            }
        }
        // ==================== End of PRTL Generator ====================

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const imeInput = document.getElementById('imeInput');

        // 複数キャンバス管理
        // 外部スクリプトからアクセスできるようにwindowオブジェクトで定義
        window.canvases = [];
        window.activeCanvasId = null;
        window.textObjects = [];

        // ローカルエイリアス（既存コードとの互換性のため）
        let canvases = window.canvases;
        let activeCanvasId = window.activeCanvasId;
        let textObjects = window.textObjects;
        let selectedObjId = null;
        let selectedCharStart = -1;
        let selectedCharEnd = -1;
        let isDragging = false;
        let isSelecting = false;
        let isResizing = false;
        let isRotating = false;
        let isDrawingShape = false;
        let resizeHandle = null;
        let dragOffset = { x: 0, y: 0 };
        let resizeStart = {};
        let rotateStart = {};
        let shapeStart = {};
        let tempShape = null;
        let scale = 1;
        let editingObjId = null;
        let cursorPos = 0;
        let cursorVisible = true;
        let cursorInterval = null;
        let currentTool = 'select';
        let isComposing = false;
        let pathPoints = [];  // パス描画中のポイント
        let isDrawingPath = false;
        let penDragging = false;  // ペンツールでドラッグ中
        let penDragStart = null;  // ドラッグ開始位置
        let editingPenPath = null;  // 制御点編集中のパスオブジェクトID
        let editingControlPoint = null;  // 編集中の制御点 {pointIndex, type: 'cp1'|'cp2'|'anchor'}
        let textEditSaveTimer = null;  // テキスト編集Undoのデバウンスタイマー
        let lastSavedState = null;  // 最後に保存した状態（重複保存を防ぐ）
        let thumbnailUpdateTimer = null;  // サムネイル更新のデバウンスタイマー
        let isUpdatingThumbnail = false;  // サムネイル更新中フラグ
        let clipboard = null;  // コピーしたオブジェクト
        let exportingTransparent = false;  // 透過エクスポート中
        let selectedObjIds = [];  // 複数選択中のオブジェクトID
        let isBoxSelecting = false;  // 矩形選択中
        let boxSelectStart = { x: 0, y: 0 };  // 矩形選択開始位置
        let boxSelectEnd = { x: 0, y: 0 };  // 矩形選択終了位置
        let bgImage = null;   // 背景画像
        let canvasBgColor = '#000000';
        let canvasBgOpacity = 0;

        // アニメーション関連
        let isPlaying = false;
        let animationTime = 0;
        let animationFrame = null;
        let animationStartTime = 0;
        let totalDuration = 5;  // 総再生時間（秒）

        // ========== Undo/Redo 履歴管理 ==========
        let undoStack = [];
        let redoStack = [];
        const MAX_HISTORY = 50;

        function saveState() {
            const state = JSON.stringify(textObjects);
            // 同じ状態を連続して保存しない
            if (state === lastSavedState) return;
            undoStack.push(state);
            lastSavedState = state;
            if (undoStack.length > MAX_HISTORY) undoStack.shift();
            redoStack = [];  // 新しい操作でredoスタックをクリア
            updateUndoRedoButtons();
        }

        // テキスト編集中のデバウンスsaveState（500ms後に保存）
        function debouncedSaveState() {
            if (textEditSaveTimer) clearTimeout(textEditSaveTimer);
            textEditSaveTimer = setTimeout(() => {
                saveState();
                textEditSaveTimer = null;
            }, 500);
        }

        // 即座にデバウンスをフラッシュ
        function flushDebouncedSave() {
            if (textEditSaveTimer) {
                clearTimeout(textEditSaveTimer);
                saveState();
                textEditSaveTimer = null;
            }
        }

        function undo() {
            if (undoStack.length === 0) return;
            const currentState = JSON.stringify(textObjects);
            redoStack.push(currentState);
            const prevState = undoStack.pop();
            textObjects = JSON.parse(prevState);
            window.textObjects = textObjects;
            selectedObjId = null;
            selectedObjIds = [];
            exitEditMode();
            updateLayerList();
            updateLayerProps();
            render();
            updateUndoRedoButtons();
        }

        function redo() {
            if (redoStack.length === 0) return;
            const currentState = JSON.stringify(textObjects);
            undoStack.push(currentState);
            const nextState = redoStack.pop();
            textObjects = JSON.parse(nextState);
            window.textObjects = textObjects;
            selectedObjId = null;
            selectedObjIds = [];
            exitEditMode();
            updateLayerList();
            updateLayerProps();
            render();
            updateUndoRedoButtons();
        }

        function updateUndoRedoButtons() {
            const undoBtn = document.getElementById('undoBtn');
            const redoBtn = document.getElementById('redoBtn');
            if (undoBtn) undoBtn.disabled = undoStack.length === 0;
            if (redoBtn) redoBtn.disabled = redoStack.length === 0;
        }

        function toggleCollapse(el) {
            el.classList.toggle('collapsed');
            el.nextElementSibling.classList.toggle('hidden');
        }

        // ========== フォント管理 ==========
        let loadedSystemFonts = [];
        let currentCustomFont = '';
        let nameTagCustomFont = '';

        // CEP環境検出
        function isInCEP() {
            try {
                return typeof CSInterface !== 'undefined';
            } catch(e) {
                return false;
            }
        }

        // システムフォント読み込み（両環境対応）
        async function loadSystemFonts() {
            // ログヘルパー（debugLogが存在する場合は使用、なければconsole.log）
            const log = (msg, level) => {
                console[level || 'log'](msg);
                if (typeof debugLog === 'function') {
                    debugLog(msg, level === 'warn' ? 'warn' : level === 'error' ? 'error' : 'info');
                }
            };

            log('loadSystemFonts() started');
            let fonts = [];

            // CEP環境の場合: ファイルシステムから直接読み込み（優先）
            if (isInCEP()) {
                log('CEP environment detected');

                // Node.js fsモジュールでフォントファイルを直接読み込み
                if (typeof loadSystemFontsFromFilesystem === 'function') {
                    log('Trying loadSystemFontsFromFilesystem()');
                    try {
                        fonts = loadSystemFontsFromFilesystem();
                        if (fonts && fonts.length > 0) {
                            log('Loaded ' + fonts.length + ' fonts from filesystem');
                        } else {
                            log('No fonts loaded from filesystem', 'warn');
                        }
                    } catch(e) {
                        log('Failed to load fonts from filesystem: ' + e.message, 'error');
                    }
                }

                // フォールバック: ExtendScriptから取得
                if (fonts.length === 0 && typeof csInterface !== 'undefined') {
                    log('Fallback to ExtendScript: calling TelopEditor.getSystemFonts()');
                    try {
                        const result = await new Promise((resolve) => {
                            csInterface.evalScript('TelopEditor.getSystemFonts()', resolve);
                        });
                        log('ExtendScript result received: ' + result);
                        const parsed = JSON.parse(result);
                        log('Parsed result: ' + JSON.stringify(parsed));
                        if (parsed.success && parsed.fonts) {
                            fonts = parsed.fonts;
                            log('Loaded ' + fonts.length + ' fonts from ExtendScript');
                        } else {
                            log('ExtendScript returned no fonts or failed: ' + (parsed.error || 'unknown'), 'warn');
                        }
                    } catch(e) {
                        log('Failed to load fonts from ExtendScript: ' + e.message, 'error');
                    }
                }
            } else {
                log('Not in CEP environment (standalone mode)');
            }

            // スタンドアローン環境の場合: QueryLocalFontAccessAPIを試行
            if (fonts.length === 0) {
                log('No fonts loaded yet, trying QueryLocalFonts API...');
                if ('queryLocalFonts' in window) {
                    log('QueryLocalFonts API available');
                    try {
                        const permission = await navigator.permissions.query({ name: 'local-fonts' });
                        log('Font permission state: ' + permission.state);
                        if (permission.state === 'granted' || permission.state === 'prompt') {
                            const availableFonts = await window.queryLocalFonts();
                            fonts = [...new Set(availableFonts.map(f => f.family))].sort();
                            log('Loaded ' + fonts.length + ' fonts via QueryLocalFonts API');
                        } else {
                            log('Font permission denied', 'warn');
                        }
                    } catch(e) {
                        log('QueryLocalFonts API error: ' + e.message, 'warn');
                    }
                } else {
                    log('QueryLocalFonts API not available in this browser', 'warn');
                }
            }

            // フォールバック: 一般的なフォントリスト
            if (fonts.length === 0) {
                log('Using fallback font list');
                fonts = [
                    "Arial", "Arial Black", "Comic Sans MS", "Courier New", "Georgia",
                    "Impact", "Times New Roman", "Trebuchet MS", "Verdana",
                    "Helvetica", "Helvetica Neue", "Lucida Grande", "Tahoma",
                    "MS Gothic", "MS Mincho", "MS PGothic", "MS PMincho",
                    "Meiryo", "Meiryo UI", "Yu Gothic", "Yu Gothic UI", "Yu Mincho",
                    "Hiragino Sans", "Hiragino Kaku Gothic Pro", "Hiragino Mincho Pro",
                    "Hiragino Maru Gothic Pro", "Osaka", "Noto Sans JP", "Noto Serif JP",
                    "Source Han Sans", "Source Han Serif"
                ].sort();
                log('Fallback font list loaded: ' + fonts.length + ' fonts');
            }

            loadedSystemFonts = fonts;

            // システムフォントグループを表示・更新
            log('Updating font dropdowns...');
            const groups = ['systemFontsGroup', 'nameTagSystemFontsGroup'];
            groups.forEach(groupId => {
                const group = document.getElementById(groupId);
                if (group) {
                    log('Updating dropdown: ' + groupId);
                    group.style.display = '';
                    group.innerHTML = '';
                    loadedSystemFonts.forEach(font => {
                        const option = document.createElement('option');
                        option.value = font;
                        option.textContent = font;
                        group.appendChild(option);
                    });
                    log('Dropdown ' + groupId + ' updated with ' + loadedSystemFonts.length + ' fonts');
                } else {
                    log('Dropdown not found: ' + groupId, 'warn');
                }
            });

            log('Total loaded fonts: ' + loadedSystemFonts.length);
            return fonts; // 戻り値を追加（CEP initで使用）
        }

        // フォント選択ハンドラ（メインテキスト用）
        function handleFontChange() {
            const select = document.getElementById('fontFamily');
            const customInput = document.getElementById('customFontInput');

            if (select.value === '__custom__') {
                customInput.style.display = 'block';
                customInput.focus();
                if (currentCustomFont) {
                    customInput.value = currentCustomFont;
                }
            } else {
                customInput.style.display = 'none';
                applyStyle();
            }
        }

        // カスタムフォント適用（メインテキスト用）
        function applyCustomFont() {
            const customInput = document.getElementById('customFontInput');
            const fontName = customInput.value.trim();
            if (fontName) {
                currentCustomFont = fontName;
                applyStyle();
            }
        }

        // フォント選択ハンドラ（名前タグ用）
        function handleNameTagFontChange() {
            const select = document.getElementById('nameTagFont');
            const customInput = document.getElementById('nameTagCustomFontInput');

            if (select.value === '__custom__') {
                customInput.style.display = 'block';
                customInput.focus();
                if (nameTagCustomFont) {
                    customInput.value = nameTagCustomFont;
                }
            } else {
                customInput.style.display = 'none';
                updateNameTag();
            }
        }

        // カスタムフォント適用（名前タグ用）
        function applyNameTagCustomFont() {
            const customInput = document.getElementById('nameTagCustomFontInput');
            const fontName = customInput.value.trim();
            if (fontName) {
                nameTagCustomFont = fontName;
                updateNameTag();
            }
        }

        // 現在選択されているフォント名を取得
        function getSelectedFont(selectId, customFontVar) {
            const select = document.getElementById(selectId);
            if (select.value === '__custom__') {
                return customFontVar || 'Yu Gothic UI';
            }
            return select.value;
        }

        // フォント初期化
        function initFonts() {
            // CEP環境ならシステムフォントを読み込む
            if (isInCEP()) {
                loadSystemFonts();
            }
        }

        // ========== キャンバス管理 ==========

        function createCanvasData(name) {
            return {
                id: Date.now() + Math.random(),
                name: name || `キャンバス ${canvases.length + 1}`,
                resolution: document.getElementById('resolution').value,
                bgColor: '#000000',
                bgOpacity: 0,
                bgImageData: null,
                objects: []
            };
        }

        function newCanvas() {
            // 現在のキャンバスを保存
            saveCurrentCanvas();

            // 新規キャンバス作成
            const newCanvasData = createCanvasData();
            canvases.push(newCanvasData);
            switchCanvas(newCanvasData.id);
            updateCanvasList();
        }

        function duplicateCanvas() {
            if (!activeCanvasId) return;

            // 現在のキャンバスを保存
            saveCurrentCanvas();

            // 現在のキャンバスを複製
            const current = canvases.find(c => c.id === activeCanvasId);
            if (!current) return;

            const duplicate = JSON.parse(JSON.stringify(current));
            duplicate.id = Date.now() + Math.random();
            duplicate.name = current.name + ' (コピー)';
            canvases.push(duplicate);
            switchCanvas(duplicate.id);
            updateCanvasList();
        }

        function deleteCanvas(id) {
            if (canvases.length <= 1) {
                alert('最後のキャンバスは削除できません');
                return;
            }

            const index = canvases.findIndex(c => c.id === id);
            if (index === -1) return;

            if (!confirm(`"${canvases[index].name}" を削除しますか？`)) return;

            canvases.splice(index, 1);

            // 削除したのがアクティブなら別のキャンバスに切替
            if (id === activeCanvasId) {
                const newIndex = Math.min(index, canvases.length - 1);
                switchCanvas(canvases[newIndex].id);
            }
            updateCanvasList();
        }

        function switchCanvas(id) {
            if (id === activeCanvasId) return;

            // 現在のキャンバスを保存（サムネイル生成はスキップして高速化）
            saveCurrentCanvas(true);  // skipThumbnail = true

            // 新しいキャンバスに切替
            activeCanvasId = id;
            window.activeCanvasId = id;
            loadCurrentCanvas();

            // アクティブ状態のみ高速更新（DOM再構築をスキップ）
            updateCanvasList(false);

            // サムネイルを非同期で更新（切り替え直後のストレスを軽減）
            setTimeout(() => {
                updatePreviousCanvasThumbnail(id);
            }, 100);
        }

        function saveCurrentCanvas(skipThumbnail = false) {
            if (!activeCanvasId) return;

            const current = canvases.find(c => c.id === activeCanvasId);
            if (!current) return;

            // 構造化クローンを使用した高速ディープコピー
            try {
                current.objects = structuredClone(textObjects);
            } catch {
                // フォールバック（古いブラウザ対応）
                current.objects = JSON.parse(JSON.stringify(textObjects));
            }
            current.resolution = document.getElementById('resolution').value;
            current.bgColor = canvasBgColor;
            current.bgOpacity = canvasBgOpacity;

            // 背景画像をBase64で保存
            if (bgImage) {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = bgImage.width;
                tempCanvas.height = bgImage.height;
                tempCanvas.getContext('2d').drawImage(bgImage, 0, 0);
                current.bgImageData = tempCanvas.toDataURL();
            } else {
                current.bgImageData = null;
            }

            // サムネイル生成をスキップする場合はここで終了（高速化）
            if (skipThumbnail) return;

            // サムネイルを保存（セーフマージン非表示で）
            const wasEnabled = document.getElementById('safeMarginEnabled').checked;
            document.getElementById('safeMarginEnabled').checked = false;
            const prevSelected = selectedObjId;
            const prevSelectedIds = [...selectedObjIds];
            selectedObjId = null;  // 選択枠を非表示
            selectedObjIds = [];
            render();
            current.thumbnail = canvas.toDataURL('image/png');
            selectedObjId = prevSelected;
            selectedObjIds = prevSelectedIds;
            document.getElementById('safeMarginEnabled').checked = wasEnabled;
            render();
        }

        // サムネイル更新をスケジュール（debounce付き）
        function scheduleThumbnailUpdate() {
            // 既存のタイマーをキャンセル
            if (thumbnailUpdateTimer) {
                clearTimeout(thumbnailUpdateTimer);
            }

            // 1秒後にサムネイルを更新
            thumbnailUpdateTimer = setTimeout(() => {
                updateCurrentCanvasThumbnail();
                thumbnailUpdateTimer = null;
            }, 1000);
        }

        // 現在のキャンバスのサムネイルを更新
        function updateCurrentCanvasThumbnail() {
            if (!activeCanvasId) return;

            const current = canvases.find(c => c.id === activeCanvasId);
            if (!current) return;

            // サムネイル更新中フラグを立てる
            isUpdatingThumbnail = true;

            // セーフマージン非表示で描画
            const wasEnabled = document.getElementById('safeMarginEnabled').checked;
            document.getElementById('safeMarginEnabled').checked = false;
            const prevSelected = selectedObjId;
            const prevSelectedIds = [...selectedObjIds];
            selectedObjId = null;  // 選択枠を非表示
            selectedObjIds = [];

            // 一時的にrender（サムネイル用）
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBackground(ctx);
            textObjects.forEach(obj => {
                ctx.save();
                const animProps = getAnimatedProperties(obj);
                const animX = animProps.x;
                const animY = animProps.y;
                const animOpacity = animProps.opacity;
                const visibleChars = animProps.visibleChars;
                const charAnimations = animProps.charAnimations;
                const origX = obj.x, origY = obj.y;
                obj.x = animX;
                obj.y = animY;
                ctx.globalAlpha = animOpacity / 100;
                if (obj.rotation) { ctx.translate(obj.x, obj.y); ctx.rotate(obj.rotation * Math.PI / 180); ctx.translate(-obj.x, -obj.y); }
                obj._visibleChars = visibleChars;
                obj._charAnimations = charAnimations;
                const kfProps = interpolateKeyframes(obj);
                if (kfProps) {
                    obj._keyframeProps = kfProps;
                } else {
                    obj._keyframeProps = null;
                }
                if (obj.type === 'group' && obj.children) {
                    ctx.save();
                    obj.children.forEach(child => {
                        const absChild = { ...child, x: child.x + obj.x, y: child.y + obj.y };
                        ctx.save();
                        ctx.globalAlpha = (obj.opacity || 100) / 100 * (child.opacity || 100) / 100;
                        if (child.rotation) {
                            ctx.translate(absChild.x, absChild.y);
                            ctx.rotate(child.rotation * Math.PI / 180);
                            ctx.translate(-absChild.x, -absChild.y);
                        }
                        if (['rect', 'roundRect', 'ellipse', 'triangle', 'line', 'chamferRect', 'arc'].includes(child.type)) {
                            drawShape(ctx, absChild);
                        } else if (child.type === 'penPath' && child.path) {
                            const absPath = child.path.map(p => ({
                                x: p.x + absChild.x,
                                y: p.y + absChild.y,
                                cp1: p.cp1 ? { x: p.cp1.x + absChild.x, y: p.cp1.y + absChild.y } : null,
                                cp2: p.cp2 ? { x: p.cp2.x + absChild.x, y: p.cp2.y + absChild.y } : null
                            }));
                            ctx.beginPath();
                            ctx.moveTo(absPath[0].x, absPath[0].y);
                            for (let i = 1; i < absPath.length; i++) {
                                const prev = absPath[i - 1];
                                const curr = absPath[i];
                                if (prev.cp2 || curr.cp1) {
                                    const cp1 = prev.cp2 || { x: prev.x, y: prev.y };
                                    const cp2 = curr.cp1 || { x: curr.x, y: curr.y };
                                    ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, curr.x, curr.y);
                                } else {
                                    ctx.lineTo(curr.x, curr.y);
                                }
                            }
                            if (child.closed) ctx.closePath();
                            if (child.fillType !== 'none') {
                                ctx.fillStyle = child.fill || '#ffffff';
                                ctx.fill();
                            }
                            ctx.strokeStyle = child.stroke || '#ffffff';
                            ctx.lineWidth = child.strokeWidth || 3;
                            ctx.stroke();
                        } else if (child.chars) {
                            drawTextObject(ctx, absChild);
                        }
                        ctx.restore();
                    });
                    ctx.restore();
                } else if (obj.type === 'image') {
                    drawImageObject(ctx, obj);
                } else if (['rect', 'roundRect', 'ellipse', 'triangle', 'line', 'chamferRect', 'arc'].includes(obj.type)) {
                    drawShape(ctx, obj);
                } else if (obj.type === 'pathText' && obj.path && obj.chars) {
                    const absPath = obj.path.map(p => ({ x: p.x + obj.x, y: p.y + obj.y }));
                    const pathLen = getPathLength(absPath);
                    let totalTextLen = 0;
                    if (obj.vertical) {
                        obj.chars.forEach(c => { totalTextLen += c.fontSize * 1.1; });
                    } else {
                        obj.chars.forEach(c => { totalTextLen += getCharWidth(c); });
                    }
                    let dist = (pathLen - totalTextLen) / 2 + (obj.pathOffset || 0);
                    obj.chars.forEach(c => {
                        let charLen;
                        if (obj.vertical) {
                            charLen = c.fontSize * 1.1;
                        } else {
                            charLen = getCharWidth(c);
                        }
                        const pos = getPointAtDistance(absPath, dist + charLen / 2);
                        const dc = c.smallCaps && /[a-z]/.test(c.char) ? c.char.toUpperCase() : c.char;
                        const fs = c.smallCaps && /[a-z]/.test(c.char) ? c.fontSize * (c.smallCapsSize || 70) / 100 : c.fontSize;
                        ctx.save();
                        const fontWeight = c.bold !== false ? 'bold' : 'normal';
                        const fontStyle = c.italic ? 'italic' : 'normal';
                        ctx.font = `${fontStyle} ${fontWeight} ${fs}px "${c.fontFamily}"`;
                        ctx.textBaseline = 'middle';
                        ctx.textAlign = 'center';
                        ctx.globalAlpha = (obj.opacity || 100) / 100 * (c.opacity || 100) / 100;
                        ctx.translate(pos.x, pos.y);
                        if (obj.vertical) {
                            ctx.rotate(pos.angle + Math.PI / 2);
                        } else {
                            ctx.rotate(pos.angle);
                        }
                        drawCharWithEffects(ctx, c, dc, fs, 0, 0);
                        ctx.restore();
                        dist += charLen;
                    });
                } else if (obj.type === 'penPath' && obj.path) {
                    const absPath = obj.path.map(p => ({ x: p.x + obj.x, y: p.y + obj.y, cp1: p.cp1 ? { x: p.cp1.x + obj.x, y: p.cp1.y + obj.y } : null, cp2: p.cp2 ? { x: p.cp2.x + obj.x, y: p.cp2.y + obj.y } : null }));
                    ctx.beginPath();
                    ctx.moveTo(absPath[0].x, absPath[0].y);
                    for (let i = 1; i < absPath.length; i++) {
                        const prev = absPath[i - 1];
                        const curr = absPath[i];
                        if (prev.cp2 || curr.cp1) {
                            const cp1 = prev.cp2 || { x: prev.x, y: prev.y };
                            const cp2 = curr.cp1 || { x: curr.x, y: curr.y };
                            ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, curr.x, curr.y);
                        } else {
                            ctx.lineTo(curr.x, curr.y);
                        }
                    }
                    if (obj.closed) ctx.closePath();
                    if (obj.fillType !== 'none') {
                        ctx.fillStyle = obj.fill || '#ffffff';
                        ctx.fill();
                    }
                    ctx.strokeStyle = obj.stroke || '#ffffff';
                    ctx.lineWidth = obj.strokeWidth || 3;
                    ctx.stroke();
                } else if (obj.chars) {
                    drawTextObject(ctx, obj);
                }
                obj.x = origX;
                obj.y = origY;
                ctx.restore();
            });

            // サムネイルを保存
            current.thumbnail = canvas.toDataURL('image/png');

            // 元の状態に戻す
            selectedObjId = prevSelected;
            selectedObjIds = prevSelectedIds;
            document.getElementById('safeMarginEnabled').checked = wasEnabled;

            // サムネイル更新中フラグを下ろす
            isUpdatingThumbnail = false;

            // 元の表示に戻す
            render();

            // キャンバスリストを更新
            updateCanvasList();
        }

        // 現在のキャンバスのサムネイルを静かに更新（UI更新を最小限に）
        function updateCurrentCanvasThumbnailQuiet() {
            if (!activeCanvasId) return;

            const current = canvases.find(c => c.id === activeCanvasId);
            if (!current) return;

            // サムネイル生成（状態を変更せずに）
            const wasEnabled = document.getElementById('safeMarginEnabled').checked;
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');

            // 現在のキャンバスの内容をコピー
            tempCtx.drawImage(canvas, 0, 0);

            // セーフマージンを一時的に非表示にして描画
            if (wasEnabled) {
                document.getElementById('safeMarginEnabled').checked = false;
                const prevSelected = selectedObjId;
                const prevSelectedIds = [...selectedObjIds];
                selectedObjId = null;
                selectedObjIds = [];

                // 一時キャンバスに描画
                tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
                tempCtx.drawImage(canvas, 0, 0);

                // 元に戻す
                selectedObjId = prevSelected;
                selectedObjIds = prevSelectedIds;
                document.getElementById('safeMarginEnabled').checked = wasEnabled;
            }

            // サムネイルを保存
            current.thumbnail = canvas.toDataURL('image/png');

            // リストのみ更新（renderは呼ばない）
            updateCanvasList();
        }

        // 前のキャンバスのサムネイルを非同期で更新
        function updatePreviousCanvasThumbnail(currentId) {
            // 前回のアクティブキャンバスを見つける（現在のIDではないもの）
            const previousCanvases = canvases.filter(c => c.id !== currentId);

            previousCanvases.forEach(canvasData => {
                // サムネイルが存在しないか、古い場合のみ更新
                if (!canvasData.thumbnail || canvasData.needsUpdate) {
                    // 簡易サムネイルを生成（パフォーマンスを考慮）
                    const callback = () => generateThumbnailForCanvas(canvasData);
                    if (typeof requestIdleCallback !== 'undefined') {
                        requestIdleCallback(callback);
                    } else {
                        setTimeout(callback, 100);
                    }
                }
            });
        }

        // 特定のキャンバスのサムネイルを生成
        function generateThumbnailForCanvas(canvasData) {
            if (!canvasData.objects) return;

            const [w, h] = (canvasData.resolution || '1920x1080').split('x').map(Number);
            const thumbCanvas = document.createElement('canvas');
            thumbCanvas.width = w;
            thumbCanvas.height = h;
            const thumbCtx = thumbCanvas.getContext('2d');

            // 背景を描画
            if (canvasData.bgImageData) {
                const img = new Image();
                img.onload = () => {
                    thumbCtx.drawImage(img, 0, 0, w, h);
                    finalizeThumbnail();
                };
                img.src = canvasData.bgImageData;
            } else if (canvasData.bgColor && canvasData.bgOpacity > 0) {
                thumbCtx.fillStyle = canvasData.bgColor;
                thumbCtx.globalAlpha = canvasData.bgOpacity / 100;
                thumbCtx.fillRect(0, 0, w, h);
                thumbCtx.globalAlpha = 1;
                finalizeThumbnail();
            } else {
                finalizeThumbnail();
            }

            function finalizeThumbnail() {
                canvasData.thumbnail = thumbCanvas.toDataURL('image/png');
                canvasData.needsUpdate = false;
                updateCanvasList();
            }
        }

        function loadCurrentCanvas() {
            const current = canvases.find(c => c.id === activeCanvasId);
            if (!current) return;

            // 構造化クローンを使用した高速ディープコピー
            try {
                textObjects = structuredClone(current.objects);
                window.textObjects = textObjects;
            } catch {
                // フォールバック（古いブラウザ対応）
                textObjects = JSON.parse(JSON.stringify(current.objects));
                window.textObjects = textObjects;
            }
            selectedObjId = null;
            selectedObjIds = [];
            editingObjId = null;

            // 解像度を設定
            if (current.resolution) {
                document.getElementById('resolution').value = current.resolution;
                changeResolution();
            }

            // 背景色を設定
            canvasBgColor = current.bgColor || '#000000';
            canvasBgOpacity = current.bgOpacity || 0;
            document.getElementById('canvasBgColor').value = canvasBgColor;
            document.getElementById('canvasBgOpacity').value = canvasBgOpacity;

            // 背景画像を読み込み
            if (current.bgImageData) {
                const img = new Image();
                img.onload = function() {
                    bgImage = img;
                    render();
                    // 読み込み完了後にサムネイルを更新
                    setTimeout(() => {
                        updateCurrentCanvasThumbnailQuiet();
                    }, 100);
                };
                img.src = current.bgImageData;
            } else {
                bgImage = null;
                // 背景画像がない場合もサムネイルを更新
                setTimeout(() => {
                    updateCurrentCanvasThumbnailQuiet();
                }, 100);
            }

            updateLayerList();
            render();
        }

        function renameCanvas(id) {
            const canvasData = canvases.find(c => c.id === id);
            if (!canvasData) return;

            const newName = prompt('キャンバス名を入力:', canvasData.name);
            if (newName && newName.trim()) {
                canvasData.name = newName.trim();
                updateCanvasList();
            }
        }

        function updateCanvasList(fullRebuild = true) {
            const list = document.getElementById('canvasList');

            // 高速モード：activeクラスのみ更新
            if (!fullRebuild) {
                const thumbs = list.querySelectorAll('.canvas-thumb');
                thumbs.forEach((thumb, index) => {
                    if (index < canvases.length) {
                        const isActive = canvases[index].id === activeCanvasId;
                        if (isActive) {
                            thumb.classList.add('active');
                        } else {
                            thumb.classList.remove('active');
                        }
                    }
                });
                return;
            }

            // フルリビルド
            list.innerHTML = '';

            canvases.forEach(canvasData => {
                const div = document.createElement('div');
                div.className = 'canvas-thumb' + (canvasData.id === activeCanvasId ? ' active' : '');
                div.onclick = () => switchCanvas(canvasData.id);

                // サムネイル生成
                const thumbUrl = generateCanvasThumbnail(canvasData);

                div.innerHTML = `
                    <img src="${thumbUrl}" alt="${canvasData.name}">
                    <div class="canvas-thumb-name">${canvasData.name}</div>
                    <div class="canvas-thumb-actions">
                        <button class="canvas-thumb-btn" onclick="event.stopPropagation(); renameCanvas(${canvasData.id})" title="名前変更">✎</button>
                        <button class="canvas-thumb-btn" onclick="event.stopPropagation(); deleteCanvas(${canvasData.id})" title="削除">×</button>
                    </div>
                `;
                list.appendChild(div);
            });
        }

        function generateCanvasThumbnail(canvasData) {
            // 保存されたサムネイルがあればそれを使用（現在のキャンバスでも優先）
            if (canvasData.thumbnail) {
                return canvasData.thumbnail;
            }

            // 現在のキャンバスの場合は実際のキャンバスからサムネイル生成
            if (canvasData.id === activeCanvasId) {
                // セーフマージン非表示で描画
                const wasEnabled = document.getElementById('safeMarginEnabled').checked;
                document.getElementById('safeMarginEnabled').checked = false;
                const prevSelected = selectedObjId;
                const prevSelectedIds = [...selectedObjIds];
                selectedObjId = null;  // 選択枠を非表示
                selectedObjIds = [];
                render();
                const url = canvas.toDataURL('image/png');
                selectedObjId = prevSelected;
                selectedObjIds = prevSelectedIds;
                document.getElementById('safeMarginEnabled').checked = wasEnabled;
                render();
                return url;
            }

            // 保存されたサムネイルがない場合は簡易プレビュー
            const [w, h] = (canvasData.resolution || '1920x1080').split('x').map(Number);
            const thumbCanvas = document.createElement('canvas');
            thumbCanvas.width = w;
            thumbCanvas.height = h;
            const thumbCtx = thumbCanvas.getContext('2d');

            // 背景
            thumbCtx.fillStyle = '#1a1a1a';
            thumbCtx.fillRect(0, 0, w, h);

            // 簡易テキストプレビュー
            if (canvasData.objects && canvasData.objects.length > 0) {
                thumbCtx.fillStyle = '#666';
                thumbCtx.font = '48px sans-serif';
                thumbCtx.textAlign = 'center';
                thumbCtx.fillText(`${canvasData.objects.length} objects`, w/2, h/2);
            }

            return thumbCanvas.toDataURL('image/png');
        }

        function importCanvasFromProject() {
            document.getElementById('importFileInput').click();
        }

        function handleImportProject(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const project = JSON.parse(e.target.result);

                    // v3.0形式（複数キャンバス）
                    if (project.canvases && project.canvases.length > 0) {
                        const names = project.canvases.map(c => c.name).join('\n');
                        if (confirm(`以下のキャンバスをインポートしますか？\n\n${names}`)) {
                            project.canvases.forEach(imported => {
                                imported.id = Date.now() + Math.random();
                                imported.name = imported.name + ' (インポート)';
                                canvases.push(imported);
                            });
                            updateCanvasList();
                        }
                    }
                    // v2.x形式（単一キャンバス）
                    else if (project.objects) {
                        const name = prompt('インポートするキャンバスの名前:', 'インポート');
                        if (name) {
                            const imported = createCanvasData(name);
                            imported.objects = project.objects;
                            imported.resolution = project.resolution || '1920x1080';
                            canvases.push(imported);
                            updateCanvasList();
                        }
                    }
                } catch (err) {
                    alert('ファイルの読み込みに失敗しました: ' + err.message);
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        // 初期キャンバス作成
        function initCanvases() {
            if (canvases.length === 0) {
                const initial = createCanvasData('キャンバス 1');
                canvases.push(initial);
                activeCanvasId = initial.id;
                window.activeCanvasId = initial.id;
            }
            updateCanvasList();
        }

        // ========== 背景・セーフマージン管理 ==========

        function updateCanvasBackground() {
            canvasBgColor = document.getElementById('canvasBgColor').value;
            canvasBgOpacity = parseInt(document.getElementById('canvasBgOpacity').value) || 0;
            render();
        }

        function loadBackgroundImage(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    bgImage = img;
                    render();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function clearBackgroundImage() {
            bgImage = null;
            document.getElementById('bgImageInput').value = '';
            render();
        }

        function drawBackground(ctx) {
            // 透過エクスポート中は背景をスキップ
            if (exportingTransparent) return;

            // 背景色（不透明度が0より大きい場合のみ描画）
            if (canvasBgOpacity > 0) {
                ctx.save();
                ctx.globalAlpha = canvasBgOpacity / 100;
                ctx.fillStyle = canvasBgColor;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.restore();
            }

            // 背景画像
            if (bgImage) {
                const fit = document.getElementById('bgImageFit').value;
                ctx.save();

                let dx = 0, dy = 0, dw = canvas.width, dh = canvas.height;

                if (fit === 'contain') {
                    const scale = Math.min(canvas.width / bgImage.width, canvas.height / bgImage.height);
                    dw = bgImage.width * scale;
                    dh = bgImage.height * scale;
                    dx = (canvas.width - dw) / 2;
                    dy = (canvas.height - dh) / 2;
                } else if (fit === 'cover') {
                    const scale = Math.max(canvas.width / bgImage.width, canvas.height / bgImage.height);
                    dw = bgImage.width * scale;
                    dh = bgImage.height * scale;
                    dx = (canvas.width - dw) / 2;
                    dy = (canvas.height - dh) / 2;
                }
                // stretch uses default values

                ctx.drawImage(bgImage, dx, dy, dw, dh);
                ctx.restore();
            }
        }

        function drawSafeMargins(ctx) {
            if (!document.getElementById('safeMarginEnabled').checked) return;

            const actionMargin = parseInt(document.getElementById('actionSafeMargin').value) || 5;
            const titleMargin = parseInt(document.getElementById('titleSafeMargin').value) || 10;
            const color = document.getElementById('safeMarginColor').value;
            const opacity = (parseInt(document.getElementById('safeMarginOpacity').value) || 50) / 100;

            // Parse color to RGB
            const r = parseInt(color.slice(1, 3), 16);
            const g = parseInt(color.slice(3, 5), 16);
            const b = parseInt(color.slice(5, 7), 16);

            ctx.save();
            ctx.strokeStyle = `rgba(${r},${g},${b},${opacity})`;
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);

            const w = canvas.width;
            const h = canvas.height;

            // アクションセーフ（外側のマージン）
            const ax = w * actionMargin / 100;
            const ay = h * actionMargin / 100;
            ctx.strokeRect(ax, ay, w - ax * 2, h - ay * 2);

            // タイトルセーフ（内側のマージン）
            const tx = w * titleMargin / 100;
            const ty = h * titleMargin / 100;
            ctx.strokeRect(tx, ty, w - tx * 2, h - ty * 2);

            // 中心線
            ctx.setLineDash([2, 4]);
            ctx.beginPath();
            ctx.moveTo(w / 2, 0);
            ctx.lineTo(w / 2, h);
            ctx.moveTo(0, h / 2);
            ctx.lineTo(w, h / 2);
            ctx.stroke();

            ctx.setLineDash([]);
            ctx.restore();
        }

        // ========== グラデーション管理 ==========

        function getGradientStopsFromUI() {
            const rawStops = [];
            document.querySelectorAll('.gradient-stop').forEach(el => {
                rawStops.push({
                    color: el.querySelector('.grad-color').value,
                    ratio: parseInt(el.querySelector('.grad-ratio').value) || 1
                });
            });

            // Calculate positions from ratios
            const total = rawStops.reduce((sum, s) => sum + s.ratio, 0);
            const stops = [];
            let cumulative = 0;

            rawStops.forEach((s, i) => {
                // Start position of this color's range
                const startPos = cumulative / total * 100;
                cumulative += s.ratio;
                // End position of this color's range
                const endPos = cumulative / total * 100;

                stops.push({
                    color: s.color,
                    ratio: s.ratio,
                    pos: startPos,
                    endPos: endPos
                });
            });

            return stops;
        }

        function addGradientStop() {
            const container = document.getElementById('gradientStops');
            const stops = container.children.length;
            const div = document.createElement('div');
            div.className = 'gradient-stop';
            div.innerHTML = `
                <div class="row2">
                    <div><label>色${stops + 1}</label><input type="color" class="grad-color" value="#cccccc" onchange="applyStyle()"></div>
                    <div><label>比率</label><input type="number" class="grad-ratio" value="30" min="1" max="100" onchange="applyStyle()"></div>
                </div>
                <button class="remove-stop" onclick="this.parentElement.remove();applyStyle()">×</button>
            `;
            container.appendChild(div);
            applyStyle();
        }

        function getDefaultStyle() {
            const gradStops = getGradientStopsFromUI();
            return {
                fontSize: parseInt(document.getElementById('fontSize').value),
                fontFamily: getSelectedFont('fontFamily', currentCustomFont),
                fillType: document.getElementById('fillType').value,
                color: gradStops[0]?.color || '#ffffff',
                color2: gradStops[gradStops.length - 1]?.color || '#888888',
                gradientStops: gradStops,
                gradientAngle: parseInt(document.getElementById('gradientAngle').value),
                gradientBlur: parseInt(document.getElementById('gradientBlur').value),
                opacity: parseInt(document.getElementById('charOpacity').value),
                strokes: getStrokesFromUI(),
                shadowEnabled: document.getElementById('shadowEnabled').checked,
                shadowColor: document.getElementById('shadowColor').value,
                shadowOpacity: parseInt(document.getElementById('shadowOpacity').value),
                shadowAngle: parseInt(document.getElementById('shadowAngle').value),
                shadowDistance: parseInt(document.getElementById('shadowDistance').value),
                shadowSize: parseInt(document.getElementById('shadowSize').value),
                shadowBlur: parseInt(document.getElementById('shadowBlur').value),
                glossEnabled: document.getElementById('glossEnabled').checked,
                glossWidth: parseInt(document.getElementById('glossWidth').value),
                glossBlur: parseInt(document.getElementById('glossBlur').value),
                glossColor: document.getElementById('glossColor').value,
                glossOpacity: parseInt(document.getElementById('glossOpacity').value),
                scaleX: parseInt(document.getElementById('charScaleX').value),
                kerning: parseInt(document.getElementById('charKerning').value),
                tracking: parseInt(document.getElementById('charTracking').value),
                baselineShift: parseInt(document.getElementById('charBaseline').value),
                slant: parseFloat(document.getElementById('charSlant').value),
                smallCaps: document.getElementById('charSmallCaps').checked,
                smallCapsSize: parseInt(document.getElementById('charSmallCapsSize').value)
            };
        }

        function getStrokesFromUI() {
            const strokes = [];
            document.querySelectorAll('.stroke-item').forEach((item, i) => {
                strokes.push({
                    enabled: item.querySelector('.stroke-enabled').checked,
                    type: item.querySelector('.stroke-type').value,
                    color: item.querySelector('.stroke-color').value,
                    width: parseInt(item.querySelector('.stroke-width').value),
                    opacity: parseInt(item.querySelector('.stroke-opacity').value),
                    angle: parseInt(item.querySelector('.stroke-angle').value) || 45,
                    join: item.querySelector('.stroke-join').value || 'round',
                    blur: item.querySelector('.stroke-blur')?.checked || false,
                    blurAmount: parseInt(item.querySelector('.stroke-blur-amount')?.value) || 0
                });
            });
            return strokes.length ? strokes : [{ enabled: true, type: 'edge', color: '#000000', width: 4, opacity: 100, angle: 45, join: 'round', blur: false, blurAmount: 0 }];
        }

        function addStroke() {
            const list = document.getElementById('strokeList');
            const idx = list.children.length;
            const div = document.createElement('div');
            div.className = 'stroke-item';
            div.innerHTML = `
                <div class="stroke-header">
                    <label><input type="checkbox" class="stroke-enabled" checked onchange="applyStyle()"> ストローク${idx + 1}</label>
                    <button class="btn btn-small btn-danger" onclick="this.parentElement.parentElement.remove();applyStyle()">×</button>
                </div>
                <div class="row2">
                    <div><label>種類</label><select class="stroke-type" onchange="applyStyle()">
                        <option value="edge">エッジ</option>
                        <option value="depth">奥行き</option>
                        <option value="drop">ドロップ</option>
                    </select></div>
                    <div><label>色</label><input type="color" class="stroke-color" value="#000000" onchange="applyStyle()"></div>
                </div>
                <div class="row2">
                    <div><label>太さ</label><input type="number" class="stroke-width" value="4" min="0" max="50" onchange="applyStyle()"></div>
                    <div><label>不透明度%</label><input type="number" class="stroke-opacity" value="100" min="0" max="100" onchange="applyStyle()"></div>
                </div>
                <div class="row2">
                    <div><label>角度°</label><input type="number" class="stroke-angle" value="45" step="1" onchange="applyStyle()"></div>
                    <div><label>角</label><select class="stroke-join" onchange="applyStyle()">
                        <option value="round">丸み</option>
                        <option value="miter">角</option>
                        <option value="bevel">面取り</option>
                    </select></div>
                </div>
                <div class="row2">
                    <div><label><input type="checkbox" class="stroke-blur" onchange="applyStyle()"> ぼかし</label></div>
                    <div><label>量</label><input type="number" class="stroke-blur-amount" value="0" min="0" max="20" onchange="applyStyle()"></div>
                </div>
            `;
            list.appendChild(div);
        }

        // 初期ストローク
        addStroke();

        // フォント初期化（CEP環境でシステムフォント読み込み）
        initFonts();

        function setTool(tool) {
            currentTool = tool;
            // Update all tool icon states
            document.querySelectorAll('.tool-icon').forEach(el => el.classList.remove('active'));
            const toolEl = document.getElementById('tool' + tool.charAt(0).toUpperCase() + tool.slice(1));
            if (toolEl) toolEl.classList.add('active');

            // Set cursor and hint
            const toolNames = {
                select: '選択ツール (V)',
                rotate: '回転ツール (R)',
                text: '横書きテキスト (T)',
                textV: '縦書きテキスト',
                rect: '長方形ツール',
                roundRect: '角丸長方形ツール',
                ellipse: '楕円ツール',
                triangle: '三角形ツール',
                line: 'ラインツール',
                chamferRect: '斜角長方形ツール',
                arc: '円弧ツール',
                pen: 'ペンツール',
                pathText: 'パス上文字ツール'
            };
            document.getElementById('toolHint').textContent = toolNames[tool] || tool;

            // Set cursor
            if (tool === 'text' || tool === 'textV') {
                canvas.style.cursor = 'text';
            } else if (tool === 'rotate') {
                canvas.style.cursor = 'grab';
            } else if (['rect', 'roundRect', 'ellipse', 'triangle', 'line', 'chamferRect', 'arc', 'pen', 'pathText'].includes(tool)) {
                canvas.style.cursor = 'crosshair';
            } else {
                canvas.style.cursor = 'default';
            }

            if (tool === 'select' && editingObjId) exitEditMode();
        }

        function alignToCenter(axis) {
            if (!selectedObjId) return;
            const obj = textObjects.find(o => o.id === selectedObjId);
            if (!obj) return;
            const bounds = getObjectBounds(obj);

            if (axis === 'h') {
                // よこ中央 = 水平方向の中央
                // バウンディングボックスの中心をキャンバスの中心に合わせる
                const offsetX = obj.x - bounds.x; // obj.xとバウンディングボックス左端の差
                obj.x = (canvas.width - bounds.w) / 2 + offsetX;
            } else if (axis === 'v') {
                // たて中央 = 垂直方向の中央
                // バウンディングボックスの中心をキャンバスの中心に合わせる
                const offsetY = obj.y - bounds.y; // obj.yとバウンディングボックス上端の差
                obj.y = (canvas.height - bounds.h) / 2 + offsetY;
            }

            updateLayerProps();
            render();
        }

        // IME入力対応
        imeInput.addEventListener('compositionstart', () => { isComposing = true; });
        imeInput.addEventListener('compositionend', (e) => {
            isComposing = false;
            const text = e.data || imeInput.value;
            if (editingObjId && text) insertText(text);
            imeInput.value = '';
        });
        imeInput.addEventListener('input', (e) => {
            if (!isComposing && editingObjId) {
                const text = e.data || imeInput.value;
                if (text) { insertText(text); imeInput.value = ''; }
            }
        });
        imeInput.addEventListener('blur', (e) => {
            if (editingObjId) {
                // 他の入力要素にフォーカスが移った場合はフォーカスを戻さない
                setTimeout(() => {
                    const active = document.activeElement;
                    if (active && (active.tagName === 'INPUT' || active.tagName === 'SELECT' || active.tagName === 'BUTTON')) {
                        return;
                    }
                    imeInput.focus();
                }, 0);
            }
        });

        function insertText(text) {
            const obj = textObjects.find(o => o.id === editingObjId);
            if (!obj) return;
            if (selectedCharStart !== -1 && selectedCharStart !== selectedCharEnd) {
                const start = Math.min(selectedCharStart, selectedCharEnd);
                const end = Math.max(selectedCharStart, selectedCharEnd);
                obj.chars.splice(start, end - start);
                cursorPos = start;
                selectedCharStart = -1;
                selectedCharEnd = -1;
            }
            const style = getDefaultStyle();
            const chars = text.split('').map(char => ({ char, ...style }));
            obj.chars.splice(cursorPos, 0, ...chars);
            cursorPos += chars.length;
            render();
            updateLayerList();
            debouncedSaveState();  // テキスト編集のUndo保存
        }

        function getHandleAtPoint(obj, x, y) {
            const bounds = getObjectBounds(obj);
            const handles = [
                { type: 'nw', x: bounds.x, y: bounds.y },
                { type: 'n', x: bounds.x + bounds.w / 2, y: bounds.y },
                { type: 'ne', x: bounds.x + bounds.w, y: bounds.y },
                { type: 'e', x: bounds.x + bounds.w, y: bounds.y + bounds.h / 2 },
                { type: 'se', x: bounds.x + bounds.w, y: bounds.y + bounds.h },
                { type: 's', x: bounds.x + bounds.w / 2, y: bounds.y + bounds.h },
                { type: 'sw', x: bounds.x, y: bounds.y + bounds.h },
                { type: 'w', x: bounds.x, y: bounds.y + bounds.h / 2 }
            ];
            const hs = 8 / scale;
            for (const h of handles) {
                if (Math.abs(x - h.x) < hs && Math.abs(y - h.y) < hs) return h.type;
            }
            return null;
        }

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            scale = canvas.width / rect.width;
            const x = (e.clientX - rect.left) * scale;
            const y = (e.clientY - rect.top) * scale;

            // スポイトモード
            if (pickingColor) {
                pickingColor = false;
                canvas.style.cursor = 'default';
                // キャンバスから色を取得
                const pixel = ctx.getImageData(x, y, 1, 1).data;
                const hex = '#' + [pixel[0], pixel[1], pixel[2]].map(c => c.toString(16).padStart(2, '0')).join('');
                document.getElementById('imageTransparentColor').value = hex;
                updateImageTransparency();
                return;
            }

            if (currentTool === 'select') {
                if (selectedObjId && !editingObjId) {
                    const obj = textObjects.find(o => o.id === selectedObjId);
                    if (obj) {
                        // ペンパスの制御点編集をチェック
                        if (obj.type === 'penPath') {
                            const cpInfo = getPenControlPointAt(obj, x, y);
                            if (cpInfo) {
                                saveState();
                                editingControlPoint = cpInfo;
                                editingPenPath = obj.id;
                                return;
                            }
                        }

                        const handle = getHandleAtPoint(obj, x, y);
                        if (handle) {
                            saveState();
                            isResizing = true;
                            resizeHandle = handle;
                            const bounds = getObjectBounds(obj);
                            resizeStart = { x, y, bounds, obj: JSON.parse(JSON.stringify(obj)) };
                            return;
                        }
                    }
                }
                const obj = findObjectAt(x, y);
                if (obj) {
                    // Ctrl/Shift+クリックの場合は追加選択
                    const isMultiSelect = e.shiftKey || e.ctrlKey || e.metaKey;

                    if (!isMultiSelect && !selectedObjIds.includes(obj.id)) {
                        // 通常クリック：新規選択
                        saveState();
                        selectObject(obj.id, false);
                    } else if (isMultiSelect) {
                        // Ctrl/Shift+クリック：追加/削除選択
                        saveState();
                        selectObject(obj.id, true);
                    }
                    // ドラッグ開始（複数選択時も対応）
                    isDragging = true;
                    dragOffset = { x: x - obj.x, y: y - obj.y };
                    // 複数選択時は各オブジェクトのオフセットを保存
                    if (selectedObjIds.length > 1) {
                        window.multiDragOffsets = {};
                        selectedObjIds.forEach(id => {
                            const o = textObjects.find(t => t.id === id);
                            if (o) window.multiDragOffsets[id] = { x: x - o.x, y: y - o.y };
                        });
                    }
                } else {
                    // 何もない場所をクリック：矩形選択開始
                    const isMultiSelect = e.shiftKey || e.ctrlKey || e.metaKey;
                    if (!isMultiSelect) {
                        selectedObjId = null;
                        selectedObjIds = [];
                    }
                    // 矩形選択開始
                    isBoxSelecting = true;
                    boxSelectStart = { x, y };
                    boxSelectEnd = { x, y };
                    updateLayerList();
                    updateLayerProps();
                    render();
                }
            } else if (currentTool === 'text') {
                const obj = findObjectAt(x, y);
                if (editingObjId) {
                    if (obj && obj.id === editingObjId) {
                        const charIdx = getCharIndexAt(obj, x, y);
                        selectedCharStart = charIdx;
                        selectedCharEnd = charIdx;
                        cursorPos = charIdx;
                        isSelecting = true;
                        render();
                    } else {
                        exitEditMode();
                        if (obj) {
                            enterEditMode(obj.id);
                            cursorPos = getCharIndexAt(obj, x, y);
                        } else {
                            createTextObject('', x, y);
                            enterEditMode(textObjects[textObjects.length - 1].id);
                        }
                    }
                } else if (obj) {
                    enterEditMode(obj.id);
                    cursorPos = getCharIndexAt(obj, x, y);
                    render();
                } else {
                    createTextObject('', x, y);
                    enterEditMode(textObjects[textObjects.length - 1].id);
                }
            } else if (currentTool === 'textV') {
                // 縦書きテキスト
                const obj = findObjectAt(x, y);
                if (obj && obj.type === 'text') {
                    enterEditMode(obj.id);
                    cursorPos = getCharIndexAt(obj, x, y);
                    render();
                } else {
                    createTextObject('', x, y, true); // vertical=true
                    enterEditMode(textObjects[textObjects.length - 1].id);
                }
            } else if (currentTool === 'rotate') {
                // 回転ツール
                const obj = findObjectAt(x, y);
                if (obj) {
                    saveState();
                    selectObject(obj.id);
                    isRotating = true;
                    const bounds = getObjectBounds(obj);
                    const cx = obj.x, cy = obj.y;
                    rotateStart = {
                        angle: Math.atan2(y - cy, x - cx),
                        rotation: obj.rotation || 0
                    };
                }
            } else if (['rect', 'roundRect', 'ellipse', 'triangle', 'line', 'chamferRect', 'arc'].includes(currentTool)) {
                // 図形描画ツール
                isDrawingShape = true;
                shapeStart = { x, y };
                tempShape = {
                    type: currentTool,
                    x1: x, y1: y,
                    x2: x, y2: y
                };
            } else if (currentTool === 'pathText') {
                // パス上文字ツール - ポイント追加（シンプルなポリライン）
                if (!isDrawingPath) {
                    isDrawingPath = true;
                    pathPoints = [{ x, y }];
                } else {
                    pathPoints.push({ x, y });
                }
                render();
            } else if (currentTool === 'pen') {
                // ペンツール - ベジェ曲線対応
                if (!isDrawingPath) {
                    isDrawingPath = true;
                    pathPoints = [{ x, y, cp1: null, cp2: null }];
                } else {
                    pathPoints.push({ x, y, cp1: null, cp2: null });
                }
                penDragging = true;
                penDragStart = { x, y };
                render();
            }
        });

        canvas.addEventListener('dblclick', (e) => {
            // ペンツール - パス完成
            if (currentTool === 'pen' && isDrawingPath && pathPoints.length >= 2) {
                saveState();
                const penObj = createPenObject(pathPoints);
                textObjects.push(penObj);
                selectObject(penObj.id);
                updateLayerList();
                pathPoints = [];
                isDrawingPath = false;
                render();
                return;
            }
            // パス上文字ツール - パス完成
            if (currentTool === 'pathText' && isDrawingPath && pathPoints.length >= 2) {
                const rect = canvas.getBoundingClientRect();
                scale = canvas.width / rect.width;
                const text = prompt('パスに表示するテキストを入力:', 'サンプルテキスト');
                if (text) {
                    saveState();
                    const pathTextObj = createPathTextObject(text, pathPoints);
                    textObjects.push(pathTextObj);
                    selectObject(pathTextObj.id);
                    updateLayerList();
                }
                pathPoints = [];
                isDrawingPath = false;
                render();
                return;
            }

            if (currentTool !== 'select') return;
            const rect = canvas.getBoundingClientRect();
            scale = canvas.width / rect.width;
            const x = (e.clientX - rect.left) * scale;
            const y = (e.clientY - rect.top) * scale;
            const obj = findObjectAt(x, y);
            if (obj) {
                setTool('text');
                enterEditMode(obj.id);
                cursorPos = getCharIndexAt(obj, x, y);
                render();
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * scale;
            const y = (e.clientY - rect.top) * scale;

            if (isBoxSelecting) {
                // 矩形選択中：終了位置を更新
                boxSelectEnd = { x, y };
                render();
            } else if (isResizing && resizeHandle) {
                const obj = textObjects.find(o => o.id === selectedObjId);
                if (obj) {
                    const dx = x - resizeStart.x;
                    const dy = y - resizeStart.y;
                    const origBounds = resizeStart.bounds;
                    let sfX = 1, sfY = 1;
                    if (resizeHandle.includes('e')) sfX = (origBounds.w + dx) / origBounds.w;
                    else if (resizeHandle.includes('w')) sfX = (origBounds.w - dx) / origBounds.w;
                    if (resizeHandle.includes('s')) sfY = (origBounds.h + dy) / origBounds.h;
                    else if (resizeHandle.includes('n')) sfY = (origBounds.h - dy) / origBounds.h;
                    if (sfX <= 0) sfX = 0.1;
                    if (sfY <= 0) sfY = 0.1;
                    const origObj = resizeStart.obj;
                    obj.chars.forEach((c, i) => {
                        if (origObj.chars[i]) {
                            c.fontSize = Math.max(1, Math.round(origObj.chars[i].fontSize * sfY));
                            c.scaleX = Math.max(10, Math.round((origObj.chars[i].scaleX || 100) * sfX / sfY));
                        }
                    });
                    render();
                    updateLayerProps();
                }
            } else if (isSelecting && editingObjId) {
                const obj = textObjects.find(o => o.id === editingObjId);
                if (obj) { selectedCharEnd = getCharIndexAt(obj, x, y); render(); }
            } else if (isDragging && selectedObjIds.length > 0) {
                // 複数オブジェクト移動
                if (selectedObjIds.length > 1 && window.multiDragOffsets) {
                    selectedObjIds.forEach(id => {
                        const obj = textObjects.find(o => o.id === id);
                        const offset = window.multiDragOffsets[id];
                        if (obj && offset) {
                            obj.x = x - offset.x;
                            obj.y = y - offset.y;
                        }
                    });
                } else if (selectedObjId) {
                    const obj = textObjects.find(o => o.id === selectedObjId);
                    if (obj) { obj.x = x - dragOffset.x; obj.y = y - dragOffset.y; }
                }
                updateLayerProps();
                render();
            } else if (currentTool === 'select' && selectedObjId && !editingObjId) {
                const obj = textObjects.find(o => o.id === selectedObjId);
                if (obj) {
                    const handle = getHandleAtPoint(obj, x, y);
                    if (handle) {
                        const cursors = { nw: 'nw-resize', n: 'n-resize', ne: 'ne-resize', e: 'e-resize', se: 'se-resize', s: 's-resize', sw: 'sw-resize', w: 'w-resize' };
                        canvas.style.cursor = cursors[handle];
                    } else canvas.style.cursor = 'default';
                }
            } else if (isRotating && selectedObjId) {
                // 回転処理
                const obj = textObjects.find(o => o.id === selectedObjId);
                if (obj) {
                    const cx = obj.x, cy = obj.y;
                    const currentAngle = Math.atan2(y - cy, x - cx);
                    const deltaAngle = (currentAngle - rotateStart.angle) * 180 / Math.PI;
                    obj.rotation = rotateStart.rotation + deltaAngle;
                    updateLayerProps();
                    render();
                }
            } else if (isDrawingShape && tempShape) {
                // 図形プレビュー
                tempShape.x2 = x;
                tempShape.y2 = y;
                render();
            } else if (penDragging && isDrawingPath && pathPoints.length > 0) {
                // ペンツール - ドラッグで制御点を設定
                const lastPoint = pathPoints[pathPoints.length - 1];
                const dx = x - penDragStart.x;
                const dy = y - penDragStart.y;
                // 対称的なベジェハンドルを設定
                lastPoint.cp2 = { x: x, y: y };
                lastPoint.cp1 = { x: penDragStart.x - dx, y: penDragStart.y - dy };
                render();
            } else if (editingControlPoint && editingPenPath) {
                // 制御点のドラッグ編集
                const obj = textObjects.find(o => o.id === editingPenPath);
                if (obj && obj.path) {
                    const point = obj.path[editingControlPoint.pointIndex];
                    const relX = x - obj.x;
                    const relY = y - obj.y;

                    if (editingControlPoint.type === 'anchor') {
                        // アンカーポイントを移動（制御点も一緒に移動）
                        const dx = relX - point.x;
                        const dy = relY - point.y;
                        point.x = relX;
                        point.y = relY;
                        if (point.cp1) {
                            point.cp1.x += dx;
                            point.cp1.y += dy;
                        }
                        if (point.cp2) {
                            point.cp2.x += dx;
                            point.cp2.y += dy;
                        }
                    } else if (editingControlPoint.type === 'cp1') {
                        point.cp1 = { x: relX, y: relY };
                    } else if (editingControlPoint.type === 'cp2') {
                        point.cp2 = { x: relX, y: relY };
                    }
                    render();
                }
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
            isSelecting = false;
            isResizing = false;
            resizeHandle = null;

            // 回転終了
            if (isRotating) {
                isRotating = false;
            }

            // 図形描画完了
            if (isDrawingShape && tempShape) {
                const minSize = 5;
                const w = Math.abs(tempShape.x2 - tempShape.x1);
                const h = Math.abs(tempShape.y2 - tempShape.y1);
                if (w > minSize || h > minSize) {
                    createShapeObject(tempShape);
                }
                isDrawingShape = false;
                tempShape = null;
                render();
            }

            // ペンツール - ドラッグ終了
            if (penDragging) {
                penDragging = false;
                penDragStart = null;
            }

            // 制御点編集終了
            if (editingControlPoint) {
                editingControlPoint = null;
                editingPenPath = null;
            }

            // 矩形選択終了
            if (isBoxSelecting) {
                isBoxSelecting = false;
                // 矩形内のオブジェクトを選択
                const selectedIds = findObjectsInBox(boxSelectStart, boxSelectEnd);
                if (selectedIds.length > 0) {
                    selectedObjIds = selectedIds;
                    selectedObjId = selectedIds[selectedIds.length - 1];  // 最後のオブジェクトを主選択
                }
                updateLayerList();
                updateLayerProps();
                render();
            }

            updateCharInfo();
        });

        document.addEventListener('keydown', (e) => {
            // Undo/Redo ショートカット
            if (e.ctrlKey && e.key === 'z') {
                e.preventDefault();
                undo();
                return;
            }
            if (e.ctrlKey && (e.key === 'y' || (e.shiftKey && e.key === 'Z'))) {
                e.preventDefault();
                redo();
                return;
            }
            // Copy/Paste ショートカット
            if (e.ctrlKey && e.key === 'c' && !editingObjId) {
                e.preventDefault();
                copySelected();
                return;
            }
            if (e.ctrlKey && e.key === 'v' && !editingObjId) {
                e.preventDefault();
                pasteObject();
                return;
            }
            // Delete ショートカット
            if ((e.key === 'Delete' || e.key === 'Backspace') && !editingObjId && selectedObjId) {
                e.preventDefault();
                deleteSelected();
                return;
            }
            // Group ショートカット (Ctrl+G)
            if (e.ctrlKey && e.key === 'g' && !e.shiftKey && !editingObjId) {
                e.preventDefault();
                groupSelected();
                return;
            }
            // Ungroup ショートカット (Ctrl+Shift+G)
            if (e.ctrlKey && e.shiftKey && (e.key === 'g' || e.key === 'G') && !editingObjId) {
                e.preventDefault();
                ungroupSelected();
                return;
            }
            // Duplicate ショートカット (Ctrl+D)
            if ((e.ctrlKey || e.metaKey) && (e.key === 'd' || e.key === 'D') && !editingObjId && selectedObjIds.length > 0) {
                e.preventDefault();
                copySelected();
                pasteObject();
                return;
            }
            // 矢印キー微調整
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key) && !editingObjId && selectedObjIds.length > 0) {
                e.preventDefault();
                const step = e.shiftKey ? 10 : 1;
                saveState();
                selectedObjIds.forEach(id => {
                    const obj = textObjects.find(o => o.id === id);
                    if (obj) {
                        if (e.key === 'ArrowUp') obj.y -= step;
                        else if (e.key === 'ArrowDown') obj.y += step;
                        else if (e.key === 'ArrowLeft') obj.x -= step;
                        else if (e.key === 'ArrowRight') obj.x += step;
                    }
                });
                updateLayerProps();
                render();
                return;
            }
            // スペースキーで再生/停止
            if (e.key === ' ' && !editingObjId && document.activeElement.tagName !== 'INPUT') {
                e.preventDefault();
                toggleAnimation();
                return;
            }
            if ((e.key === 'v' || e.key === 'V') && !editingObjId && document.activeElement.tagName !== 'INPUT') { setTool('select'); return; }
            if ((e.key === 't' || e.key === 'T') && !editingObjId && document.activeElement.tagName !== 'INPUT') { setTool('text'); return; }
            if ((e.key === 'r' || e.key === 'R') && !editingObjId && document.activeElement.tagName !== 'INPUT') { setTool('rotate'); return; }
            if ((e.key === 'p' || e.key === 'P') && !editingObjId && document.activeElement.tagName !== 'INPUT') { setTool('pen'); return; }
            if (!editingObjId) return;
            if ((e.target.tagName === 'INPUT' && e.target.id !== 'imeInput') || e.target.tagName === 'SELECT') return;
            if (isComposing) return;
            const obj = textObjects.find(o => o.id === editingObjId);
            if (!obj) return;

            if (e.key === 'Backspace') {
                e.preventDefault();
                if (selectedCharStart !== -1 && selectedCharStart !== selectedCharEnd) {
                    const s = Math.min(selectedCharStart, selectedCharEnd), en = Math.max(selectedCharStart, selectedCharEnd);
                    obj.chars.splice(s, en - s); cursorPos = s; selectedCharStart = -1; selectedCharEnd = -1;
                } else if (cursorPos > 0) { obj.chars.splice(cursorPos - 1, 1); cursorPos--; }
                render();
                debouncedSaveState();  // テキスト編集のUndo保存
            } else if (e.key === 'Delete') {
                e.preventDefault();
                if (selectedCharStart !== -1 && selectedCharStart !== selectedCharEnd) {
                    const s = Math.min(selectedCharStart, selectedCharEnd), en = Math.max(selectedCharStart, selectedCharEnd);
                    obj.chars.splice(s, en - s); cursorPos = s; selectedCharStart = -1; selectedCharEnd = -1;
                } else if (cursorPos < obj.chars.length) obj.chars.splice(cursorPos, 1);
                render();
                debouncedSaveState();  // テキスト編集のUndo保存
            } else if (e.key === 'ArrowLeft' || e.key === 'ArrowRight' || e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                e.preventDefault();
                selectedCharStart = -1;

                if (obj.vertical) {
                    // 縦書き: Up/Downで文字移動、Left/Rightで列移動
                    if (e.key === 'ArrowUp') {
                        if (cursorPos > 0) cursorPos--;
                    } else if (e.key === 'ArrowDown') {
                        if (cursorPos < obj.chars.length) cursorPos++;
                    } else if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                        // 列移動
                        const lines = getLines(obj);
                        let cCol = 0, cIdx = 0, count = 0;
                        for (let li = 0; li < lines.length; li++) {
                            if (cursorPos <= count + lines[li].length) { cCol = li; cIdx = cursorPos - count; break; }
                            count += lines[li].length + 1;
                        }
                        if (e.key === 'ArrowLeft') {
                            // 次の列（右から左なので次の列は左）
                            if (cCol < lines.length - 1) {
                                let newCount = 0;
                                for (let li = 0; li <= cCol; li++) newCount += lines[li].length + 1;
                                cursorPos = Math.min(newCount + cIdx, newCount + lines[cCol + 1].length);
                            }
                        } else {
                            // 前の列
                            if (cCol > 0) {
                                let newCount = 0;
                                for (let li = 0; li < cCol - 1; li++) newCount += lines[li].length + 1;
                                cursorPos = Math.min(newCount + cIdx, newCount + lines[cCol - 1].length);
                            }
                        }
                    }
                } else {
                    // 横書き: Left/Rightで文字移動、Up/Downで行移動
                    if (e.key === 'ArrowLeft') {
                        if (cursorPos > 0) cursorPos--;
                    } else if (e.key === 'ArrowRight') {
                        if (cursorPos < obj.chars.length) cursorPos++;
                    } else if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                        // 行移動
                        const lines = getLines(obj);
                        let cLine = 0, cIdx = 0, count = 0;
                        for (let li = 0; li < lines.length; li++) {
                            if (cursorPos <= count + lines[li].length) { cLine = li; cIdx = cursorPos - count; break; }
                            count += lines[li].length + 1;
                        }
                        if (e.key === 'ArrowUp' && cLine > 0) {
                            let newCount = 0;
                            for (let li = 0; li < cLine - 1; li++) newCount += lines[li].length + 1;
                            cursorPos = Math.min(newCount + cIdx, newCount + lines[cLine - 1].length);
                        } else if (e.key === 'ArrowDown' && cLine < lines.length - 1) {
                            let newCount = 0;
                            for (let li = 0; li <= cLine; li++) newCount += lines[li].length + 1;
                            cursorPos = Math.min(newCount + cIdx, newCount + lines[cLine + 1].length);
                        }
                    }
                }
                render();
            }
            else if (e.key === 'Escape') {
                if (isBoxSelecting) {
                    // Cancel box selection
                    isBoxSelecting = false;
                    render();
                } else if (isDrawingPath) {
                    // Cancel path drawing
                    pathPoints = [];
                    isDrawingPath = false;
                    render();
                } else {
                    exitEditMode();
                    setTool('select');
                }
            }
            else if (e.key === 'Enter') { e.preventDefault(); insertText('\n'); }
            else if (e.key === 'a' && e.ctrlKey) { e.preventDefault(); selectedCharStart = 0; selectedCharEnd = obj.chars.length; render(); updateCharInfo(); }
            else if (e.key.length === 1 && !e.ctrlKey && !e.metaKey) {
                if (document.activeElement === imeInput) return;
                e.preventDefault();
                insertText(e.key);
            }
            updateLayerList();
        });

        function getCharIndexAt(obj, x, y) {
            // パス上文字の場合
            if (obj.type === 'pathText' && obj.path && obj.chars) {
                const absPath = obj.path.map(p => ({ x: p.x + obj.x, y: p.y + obj.y }));
                const pathLen = getPathLength(absPath);
                const totalTextWidth = obj.chars.reduce((w, c) => w + getCharWidth(c), 0);
                let startOffset = 0;
                if (obj.textAlign === 'center') startOffset = (pathLen - totalTextWidth) / 2;
                else if (obj.textAlign === 'right') startOffset = pathLen - totalTextWidth;

                let offset = startOffset;
                for (let i = 0; i < obj.chars.length; i++) {
                    const charW = getCharWidth(obj.chars[i]);
                    const pos = getPointAtDistance(absPath, offset + charW / 2);
                    if (pos) {
                        const dist = Math.sqrt((x - pos.x) ** 2 + (y - pos.y) ** 2);
                        if (dist < obj.chars[i].fontSize) {
                            // 文字の前半か後半かで判定
                            const prevPos = getPointAtDistance(absPath, offset);
                            if (prevPos) {
                                const distToPrev = Math.sqrt((x - prevPos.x) ** 2 + (y - prevPos.y) ** 2);
                                const distToCurr = Math.sqrt((x - pos.x) ** 2 + (y - pos.y) ** 2);
                                if (distToPrev < distToCurr) return i;
                            }
                            return i;
                        }
                    }
                    offset += charW;
                }
                return obj.chars.length;
            }

            const lines = getLines(obj);

            // 縦書きの場合
            if (obj.vertical) {
                const colWidth = getVerticalLineWidth(obj) * (obj.lineHeight || 1.2);
                const totalWidth = lines.length * colWidth;

                let startX = obj.x;
                if (obj.textAlign === 'center') startX = obj.x + totalWidth / 2 - colWidth / 2;
                else if (obj.textAlign === 'left') startX = obj.x + totalWidth - colWidth;

                // 最も近い列を見つける
                let closestCol = 0;
                let closestDist = Infinity;
                for (let li = 0; li < lines.length; li++) {
                    const colX = startX - li * colWidth;
                    const dist = Math.abs(x - colX);
                    if (dist < closestDist) {
                        closestDist = dist;
                        closestCol = li;
                    }
                }

                let ci = 0;
                for (let li = 0; li < closestCol; li++) {
                    ci += lines[li].length + 1;
                }

                const line = lines[closestCol];
                const colX = startX - closestCol * colWidth;
                const lineH = getVerticalLineHeight(line);

                let startY = obj.y;
                if (obj.verticalAlign === 'top') startY = obj.y;
                else if (obj.verticalAlign === 'bottom') startY = obj.y - lineH;
                else startY = obj.y - lineH / 2;

                let py = startY;
                for (let i = 0; i < line.length; i++) {
                    const h = getCharHeight(line[i]);
                    if (y < py + h / 2) return ci + i;
                    py += h;
                }
                return ci + line.length;
            }

            // 横書きの場合
            const lh = getLineHeight(obj) * (obj.lineHeight || 1.2);
            const th = lines.length * lh;
            let startY = obj.y;
            if (obj.verticalAlign === 'top') startY = obj.y;
            else if (obj.verticalAlign === 'bottom') startY = obj.y - th + lh;
            else startY = obj.y - th / 2 + lh / 2;
            let ci = 0;
            for (let li = 0; li < lines.length; li++) {
                const line = lines[li], lineY = startY + li * lh, lw = getLineWidth(line);
                let lx = obj.x;
                if (obj.textAlign === 'center') lx = obj.x - lw / 2;
                else if (obj.textAlign === 'right') lx = obj.x - lw;
                if (y >= lineY - lh / 2 && y < lineY + lh / 2) {
                    let px = lx;
                    for (let i = 0; i < line.length; i++) {
                        const w = getCharWidth(line[i]);
                        if (x < px + w / 2) return ci + i;
                        px += w;
                    }
                    return ci + line.length;
                }
                ci += line.length + 1;
            }
            return obj.chars.length;
        }

        function getLines(obj) {
            const lines = [[]];
            obj.chars.forEach(c => { if (c.char === '\n') lines.push([]); else lines[lines.length - 1].push(c); });
            return lines;
        }

        function getCharWidth(c) {
            const dc = c.smallCaps && /[a-z]/.test(c.char) ? c.char.toUpperCase() : c.char;
            const fs = c.smallCaps && /[a-z]/.test(c.char) ? c.fontSize * (c.smallCapsSize || 70) / 100 : c.fontSize;
            const fontWeight = c.bold !== false ? 'bold' : 'normal';
            const fontStyle = c.italic ? 'italic' : 'normal';
            ctx.font = `${fontStyle} ${fontWeight} ${fs}px "${c.fontFamily}"`;
            // カーニング: 正の値で文字間隔を広げ、負の値で狭める
            return ctx.measureText(dc).width * (c.scaleX || 100) / 100 + (c.tracking || 0) + (c.kerning || 0);
        }

        function getLineWidth(line) { return line.reduce((w, c) => w + getCharWidth(c), 0); }
        function getLineHeight(obj) { return Math.max(...obj.chars.map(c => c.fontSize), 72); }

        // Vertical text helpers
        function getCharHeight(c) {
            const fs = c.smallCaps && /[a-z]/.test(c.char) ? c.fontSize * (c.smallCapsSize || 70) / 100 : c.fontSize;
            return fs * (c.lineHeight || 1.2) + (c.tracking || 0);
        }
        function getVerticalLineHeight(line) { return line.reduce((h, c) => h + getCharHeight(c), 0); }
        function getVerticalLineWidth(obj) { return Math.max(...obj.chars.map(c => c.fontSize), 72); }

        function createTextObject(text, x, y, vertical = false) {
            const style = getDefaultStyle();
            const chars = text.split('').map(char => ({ char, ...style }));
            const obj = {
                id: Date.now(),
                type: 'text',
                name: (vertical ? '縦書き ' : 'テキスト ') + (textObjects.length + 1),
                x, y,
                rotation: 0,
                opacity: 100,
                lineHeight: 1.2,
                textAlign: 'left',
                verticalAlign: 'middle',
                vertical: vertical,
                chars,
                // Name tag properties
                nameTag: {
                    enabled: false,
                    text: '',
                    font: 'Yu Gothic UI',
                    position: 'top-left',
                    gap: 10,
                    color: '#ffffff',
                    size: 36,
                    bgEnabled: true,
                    bgShape: 'rounded',
                    bgRadius: 5,
                    bgColor: '#0066cc',
                    bgOpacity: 100,
                    padX: 10,
                    padY: 5,
                    strokeEnabled: false,
                    strokeColor: '#ffffff',
                    strokeWidth: 2
                },
                // Balloon properties
                balloon: {
                    enabled: false,
                    shape: 'rounded',
                    radius: 20,
                    padX: 30,
                    padY: 20,
                    fill: '#ffffff',
                    fillOpacity: 100,
                    strokeEnabled: true,
                    strokeColor: '#000000',
                    strokeWidth: 3,
                    tailEnabled: true,
                    tailDir: 'bottom',
                    tailPos: 50,
                    tailWidth: 20,
                    tailLength: 30
                }
            };
            saveState();
            textObjects.push(obj);
            selectObject(obj.id);
            updateLayerList();
            render();
        }

        function createPathTextObject(text, points) {
            const style = getDefaultStyle();
            const chars = text.split('').map(char => ({ char, ...style }));

            // Calculate bounding box and center
            const xs = points.map(p => p.x), ys = points.map(p => p.y);
            const minX = Math.min(...xs), maxX = Math.max(...xs);
            const minY = Math.min(...ys), maxY = Math.max(...ys);
            const cx = (minX + maxX) / 2, cy = (minY + maxY) / 2;

            const obj = {
                id: Date.now(),
                type: 'pathText',
                name: 'パス上文字 ' + (textObjects.length + 1),
                x: cx, y: cy,
                rotation: 0,
                opacity: 100,
                chars,
                // Store path points relative to center
                path: points.map(p => ({ x: p.x - cx, y: p.y - cy })),
                pathOffset: 0,  // Offset along path for text start
                vertical: false,  // 縦書きモード
                // Name tag and balloon (disabled for path text)
                nameTag: { enabled: false },
                balloon: { enabled: false }
            };
            return obj;
        }

        function createPenObject(points) {
            // Calculate bounding box and center
            const xs = points.map(p => p.x), ys = points.map(p => p.y);
            const minX = Math.min(...xs), maxX = Math.max(...xs);
            const minY = Math.min(...ys), maxY = Math.max(...ys);
            const cx = (minX + maxX) / 2, cy = (minY + maxY) / 2;

            const obj = {
                id: Date.now(),
                type: 'penPath',
                name: 'パス ' + (textObjects.length + 1),
                x: cx, y: cy,
                width: maxX - minX || 10,
                height: maxY - minY || 10,
                rotation: 0,
                opacity: 100,
                // Store path points relative to center with bezier control points
                // Each point: {x, y, cp1: {x, y}, cp2: {x, y}}
                // cp1: control point for curve coming INTO this point
                // cp2: control point for curve going OUT OF this point
                path: points.map(p => ({
                    x: p.x - cx,
                    y: p.y - cy,
                    cp1: p.cp1 ? { x: p.cp1.x - cx, y: p.cp1.y - cy } : null,
                    cp2: p.cp2 ? { x: p.cp2.x - cx, y: p.cp2.y - cy } : null
                })),
                closed: false,  // 閉じたパス
                // 塗り設定
                fillType: 'none',
                fill: '#ffffff',
                fillOpacity: 100,
                // ストローク設定
                stroke: '#ffffff',
                strokeWidth: 3,
                strokeOpacity: 100
            };
            return obj;
        }

        // Calculate total length of path
        function getPathLength(points) {
            let len = 0;
            for (let i = 1; i < points.length; i++) {
                const dx = points[i].x - points[i-1].x;
                const dy = points[i].y - points[i-1].y;
                len += Math.sqrt(dx * dx + dy * dy);
            }
            return len;
        }

        // Get point and angle at distance along path
        function getPointAtDistance(points, dist) {
            let accumulated = 0;
            for (let i = 1; i < points.length; i++) {
                const dx = points[i].x - points[i-1].x;
                const dy = points[i].y - points[i-1].y;
                const segLen = Math.sqrt(dx * dx + dy * dy);

                if (accumulated + segLen >= dist) {
                    const t = (dist - accumulated) / segLen;
                    return {
                        x: points[i-1].x + dx * t,
                        y: points[i-1].y + dy * t,
                        angle: Math.atan2(dy, dx)
                    };
                }
                accumulated += segLen;
            }
            // Return last point
            const last = points[points.length - 1];
            const prev = points[points.length - 2] || points[0];
            return {
                x: last.x,
                y: last.y,
                angle: Math.atan2(last.y - prev.y, last.x - prev.x)
            };
        }

        function createShapeObject(shape) {
            const x = Math.min(shape.x1, shape.x2);
            const y = Math.min(shape.y1, shape.y2);
            const w = Math.abs(shape.x2 - shape.x1);
            const h = Math.abs(shape.y2 - shape.y1);

            const obj = {
                id: Date.now(),
                type: shape.type,
                name: getShapeName(shape.type) + ' ' + (textObjects.length + 1),
                x: x + w / 2,
                y: y + h / 2,
                width: w,
                height: h,
                rotation: 0,
                opacity: 100,
                // 塗り設定
                fillType: 'solid',  // solid, linear, radial, none
                fill: '#ffffff',
                fillOpacity: 100,
                gradientStops: [
                    { color: '#ffffff', ratio: 50, pos: 0, endPos: 50 },
                    { color: '#888888', ratio: 50, pos: 50, endPos: 100 }
                ],
                gradientAngle: 0,
                // ストローク設定
                stroke: '#000000',
                strokeWidth: 2,
                strokeOpacity: 100,
                cornerRadius: shape.type === 'roundRect' ? 20 : 0
            };

            saveState();
            textObjects.push(obj);
            selectObject(obj.id);
            updateLayerList();
            render();
        }

        function getShapeName(type) {
            const names = {
                rect: '長方形',
                roundRect: '角丸長方形',
                ellipse: '楕円',
                triangle: '三角形',
                line: 'ライン',
                chamferRect: '斜角長方形',
                arc: '円弧'
            };
            return names[type] || '図形';
        }

        function updateNameTag() {
            if (!selectedObjId) return;
            const obj = textObjects.find(o => o.id === selectedObjId);
            if (!obj) return;
            if (!obj.nameTag) obj.nameTag = {};
            obj.nameTag.enabled = document.getElementById('nameTagEnabled').checked;
            obj.nameTag.text = document.getElementById('nameTagText').value;
            obj.nameTag.font = getSelectedFont('nameTagFont', nameTagCustomFont);
            obj.nameTag.position = document.getElementById('nameTagPosition').value;
            obj.nameTag.gap = parseInt(document.getElementById('nameTagGap').value) || 10;
            obj.nameTag.color = document.getElementById('nameTagColor').value;
            obj.nameTag.size = parseInt(document.getElementById('nameTagSize').value) || 36;
            obj.nameTag.bgEnabled = document.getElementById('nameTagBgEnabled').checked;
            obj.nameTag.bgShape = document.getElementById('nameTagBgShape').value;
            obj.nameTag.bgRadius = parseInt(document.getElementById('nameTagBgRadius').value) || 5;
            obj.nameTag.bgColor = document.getElementById('nameTagBgColor').value;
            obj.nameTag.bgOpacity = parseInt(document.getElementById('nameTagBgOpacity').value) || 100;
            obj.nameTag.padX = parseInt(document.getElementById('nameTagPadX').value) || 10;
            obj.nameTag.padY = parseInt(document.getElementById('nameTagPadY').value) || 5;
            obj.nameTag.strokeEnabled = document.getElementById('nameTagStrokeEnabled').checked;
            obj.nameTag.strokeColor = document.getElementById('nameTagStrokeColor').value;
            obj.nameTag.strokeWidth = parseInt(document.getElementById('nameTagStrokeWidth').value) || 2;
            render();
        }

        function updateBalloon() {
            if (!selectedObjId) return;
            const obj = textObjects.find(o => o.id === selectedObjId);
            if (!obj) return;
            if (!obj.balloon) obj.balloon = {};
            obj.balloon.enabled = document.getElementById('balloonEnabled').checked;
            obj.balloon.shape = document.getElementById('balloonShape').value;
            obj.balloon.radius = parseInt(document.getElementById('balloonRadius').value) || 20;
            obj.balloon.padX = parseInt(document.getElementById('balloonPadX').value) || 30;
            obj.balloon.padY = parseInt(document.getElementById('balloonPadY').value) || 20;
            obj.balloon.fill = document.getElementById('balloonFill').value;
            obj.balloon.fillOpacity = parseInt(document.getElementById('balloonFillOpacity').value) || 100;
            obj.balloon.strokeEnabled = document.getElementById('balloonStrokeEnabled').checked;
            obj.balloon.strokeColor = document.getElementById('balloonStrokeColor').value;
            obj.balloon.strokeWidth = parseInt(document.getElementById('balloonStrokeWidth').value) || 3;
            obj.balloon.tailEnabled = document.getElementById('balloonTailEnabled').checked;
            obj.balloon.tailDir = document.getElementById('balloonTailDir').value;
            obj.balloon.tailPos = parseInt(document.getElementById('balloonTailPos').value) || 50;
            obj.balloon.tailWidth = parseInt(document.getElementById('balloonTailWidth').value) || 20;
            obj.balloon.tailLength = parseInt(document.getElementById('balloonTailLength').value) || 30;
            render();
        }

        function updateShapeStyle() {
            if (!selectedObjId) return;
            const obj = textObjects.find(o => o.id === selectedObjId);
            if (!obj || !['rect', 'roundRect', 'ellipse', 'triangle', 'line', 'arc', 'chamferRect'].includes(obj.type)) return;

            obj.fillType = document.getElementById('shapeFillType').value;
            obj.fill = document.getElementById('shapeFill').value;
            obj.fillOpacity = parseInt(document.getElementById('shapeFillOpacity').value) || 100;
            obj.gradientAngle = parseInt(document.getElementById('shapeGradientAngle').value) || 0;

            // Update gradient stops
            const fill2 = document.getElementById('shapeFill2').value;
            obj.gradientStops = [
                { color: obj.fill, ratio: 50, pos: 0, endPos: 50 },
                { color: fill2, ratio: 50, pos: 50, endPos: 100 }
            ];

            obj.stroke = document.getElementById('shapeStroke').value;
            obj.strokeWidth = parseInt(document.getElementById('shapeStrokeWidth').value) || 2;
            obj.strokeOpacity = parseInt(document.getElementById('shapeStrokeOpacity').value) || 100;

            render();
        }

        function loadShapeUI(obj) {
            if (!['rect', 'roundRect', 'ellipse', 'triangle', 'line', 'arc', 'chamferRect'].includes(obj.type)) return;

            document.getElementById('shapeFillType').value = obj.fillType || 'solid';
            document.getElementById('shapeFill').value = obj.fill || '#ffffff';
            document.getElementById('shapeFillOpacity').value = obj.fillOpacity || 100;
            document.getElementById('shapeGradientAngle').value = obj.gradientAngle || 0;

            // Load second gradient color
            if (obj.gradientStops && obj.gradientStops.length >= 2) {
                document.getElementById('shapeFill2').value = obj.gradientStops[1].color;
            } else {
                document.getElementById('shapeFill2').value = '#888888';
            }

            document.getElementById('shapeStroke').value = obj.stroke || '#000000';
            document.getElementById('shapeStrokeWidth').value = obj.strokeWidth || 2;
            document.getElementById('shapeStrokeOpacity').value = obj.strokeOpacity || 100;
        }

        function updatePathTextStyle() {
            if (!selectedObjId) return;
            const obj = textObjects.find(o => o.id === selectedObjId);
            if (!obj || obj.type !== 'pathText') return;

            obj.vertical = document.getElementById('pathTextVertical').checked;
            obj.pathOffset = parseInt(document.getElementById('pathTextOffset').value) || 0;

            render();
        }

        function loadPathTextUI(obj) {
            const panel = document.getElementById('pathTextSettings').parentElement.previousElementSibling;
            if (obj.type !== 'pathText') {
                // Hide pathText settings panel
                document.getElementById('pathTextSettings').classList.add('hidden');
                if (panel) panel.classList.add('collapsed');
                return;
            }

            // Show pathText settings panel
            document.getElementById('pathTextSettings').classList.remove('hidden');
            if (panel) panel.classList.remove('collapsed');

            document.getElementById('pathTextVertical').checked = obj.vertical || false;
            document.getElementById('pathTextOffset').value = obj.pathOffset || 0;
        }

        function updatePenPathStyle() {
            if (!selectedObjId) return;
            const obj = textObjects.find(o => o.id === selectedObjId);
            if (!obj || obj.type !== 'penPath') return;

            obj.fillType = document.getElementById('penPathFillType').value;
            obj.fill = document.getElementById('penPathFill').value;
            obj.fillOpacity = parseInt(document.getElementById('penPathFillOpacity').value) || 100;
            obj.stroke = document.getElementById('penPathStroke').value;
            obj.strokeWidth = parseInt(document.getElementById('penPathStrokeWidth').value) || 3;
            obj.strokeOpacity = parseInt(document.getElementById('penPathStrokeOpacity').value) || 100;
            obj.closed = document.getElementById('penPathClosed').checked;

            render();
        }

        function loadPenPathUI(obj) {
            const panel = document.getElementById('penPathSettings').parentElement.previousElementSibling;
            if (obj.type !== 'penPath') {
                // Hide penPath settings panel
                document.getElementById('penPathSettings').classList.add('hidden');
                if (panel) panel.classList.add('collapsed');
                return;
            }

            // Show penPath settings panel
            document.getElementById('penPathSettings').classList.remove('hidden');
            if (panel) panel.classList.remove('collapsed');

            document.getElementById('penPathFillType').value = obj.fillType || 'none';
            document.getElementById('penPathFill').value = obj.fill || '#ffffff';
            document.getElementById('penPathFillOpacity').value = obj.fillOpacity || 100;
            document.getElementById('penPathStroke').value = obj.stroke || '#ffffff';
            document.getElementById('penPathStrokeWidth').value = obj.strokeWidth || 3;
            document.getElementById('penPathStrokeOpacity').value = obj.strokeOpacity || 100;
            document.getElementById('penPathClosed').checked = obj.closed || false;
        }

        function loadNameTagUI(obj) {
            if (!obj.nameTag) return;
            document.getElementById('nameTagEnabled').checked = obj.nameTag.enabled || false;
            document.getElementById('nameTagText').value = obj.nameTag.text || '';
            document.getElementById('nameTagFont').value = obj.nameTag.font || 'Yu Gothic UI';
            document.getElementById('nameTagPosition').value = obj.nameTag.position || 'top-left';
            document.getElementById('nameTagGap').value = obj.nameTag.gap || 10;
            document.getElementById('nameTagColor').value = obj.nameTag.color || '#ffffff';
            document.getElementById('nameTagSize').value = obj.nameTag.size || 36;
            document.getElementById('nameTagBgEnabled').checked = obj.nameTag.bgEnabled !== false;
            document.getElementById('nameTagBgShape').value = obj.nameTag.bgShape || 'rounded';
            document.getElementById('nameTagBgRadius').value = obj.nameTag.bgRadius || 5;
            document.getElementById('nameTagBgColor').value = obj.nameTag.bgColor || '#0066cc';
            document.getElementById('nameTagBgOpacity').value = obj.nameTag.bgOpacity || 100;
            document.getElementById('nameTagPadX').value = obj.nameTag.padX || 10;
            document.getElementById('nameTagPadY').value = obj.nameTag.padY || 5;
            document.getElementById('nameTagStrokeEnabled').checked = obj.nameTag.strokeEnabled || false;
            document.getElementById('nameTagStrokeColor').value = obj.nameTag.strokeColor || '#ffffff';
            document.getElementById('nameTagStrokeWidth').value = obj.nameTag.strokeWidth || 2;
        }

        function loadBalloonUI(obj) {
            if (!obj.balloon) return;
            document.getElementById('balloonEnabled').checked = obj.balloon.enabled || false;
            document.getElementById('balloonShape').value = obj.balloon.shape || 'rounded';
            document.getElementById('balloonRadius').value = obj.balloon.radius || 20;
            document.getElementById('balloonPadX').value = obj.balloon.padX || 30;
            document.getElementById('balloonPadY').value = obj.balloon.padY || 20;
            document.getElementById('balloonFill').value = obj.balloon.fill || '#ffffff';
            document.getElementById('balloonFillOpacity').value = obj.balloon.fillOpacity || 100;
            document.getElementById('balloonStrokeEnabled').checked = obj.balloon.strokeEnabled !== false;
            document.getElementById('balloonStrokeColor').value = obj.balloon.strokeColor || '#000000';
            document.getElementById('balloonStrokeWidth').value = obj.balloon.strokeWidth || 3;
            document.getElementById('balloonTailEnabled').checked = obj.balloon.tailEnabled !== false;
            document.getElementById('balloonTailDir').value = obj.balloon.tailDir || 'bottom';
            document.getElementById('balloonTailPos').value = obj.balloon.tailPos || 50;
            document.getElementById('balloonTailWidth').value = obj.balloon.tailWidth || 20;
            document.getElementById('balloonTailLength').value = obj.balloon.tailLength || 30;
        }

        function findObjectAt(x, y) {
            for (let i = textObjects.length - 1; i >= 0; i--) {
                const obj = textObjects[i], b = getObjectBounds(obj);
                // テキスト系オブジェクトは広めの判定領域（30px）
                const margin = (obj.type === 'text' || obj.type === 'pathText' || obj.chars) ? 30 : 10;
                if (x >= b.x - margin && x <= b.x + b.w + margin && y >= b.y - margin && y <= b.y + b.h + margin) return obj;
            }
            return null;
        }

        function findObjectsInBox(start, end) {
            // 矩形の正規化（左上から右下に）
            const minX = Math.min(start.x, end.x);
            const minY = Math.min(start.y, end.y);
            const maxX = Math.max(start.x, end.x);
            const maxY = Math.max(start.y, end.y);

            const selected = [];
            for (let i = 0; i < textObjects.length; i++) {
                const obj = textObjects[i];
                const bounds = getObjectBounds(obj);
                const objCenterX = bounds.x + bounds.w / 2;
                const objCenterY = bounds.y + bounds.h / 2;

                // オブジェクトの中心が矩形内にあれば選択
                if (objCenterX >= minX && objCenterX <= maxX &&
                    objCenterY >= minY && objCenterY <= maxY) {
                    selected.push(obj.id);
                }
            }
            return selected;
        }

        function getObjectBounds(obj) {
            // グループオブジェクトの場合
            if (obj.type === 'group') {
                return {
                    x: obj.x - obj.width / 2,
                    y: obj.y - obj.height / 2,
                    w: obj.width,
                    h: obj.height
                };
            }

            // 画像オブジェクトの場合
            if (obj.type === 'image') {
                const crop = obj.crop || { left: 0, top: 0, right: 0, bottom: 0 };
                const srcW = obj.originalWidth - crop.left - crop.right;
                const srcH = obj.originalHeight - crop.top - crop.bottom;
                const dstW = obj.width * (srcW / obj.originalWidth);
                const dstH = obj.height * (srcH / obj.originalHeight);
                return {
                    x: obj.x - dstW / 2,
                    y: obj.y - dstH / 2,
                    w: dstW,
                    h: dstH
                };
            }

            // 図形オブジェクトの場合
            if (['rect', 'roundRect', 'ellipse', 'triangle', 'line', 'chamferRect', 'arc'].includes(obj.type)) {
                return {
                    x: obj.x - obj.width / 2,
                    y: obj.y - obj.height / 2,
                    w: obj.width,
                    h: obj.height
                };
            }

            // パス上文字オブジェクトの場合
            if (obj.type === 'pathText' && obj.path) {
                const absPath = obj.path.map(p => ({ x: p.x + obj.x, y: p.y + obj.y }));
                const xs = absPath.map(p => p.x), ys = absPath.map(p => p.y);
                const maxFs = obj.chars ? Math.max(...obj.chars.map(c => c.fontSize), 72) : 72;
                return {
                    x: Math.min(...xs) - maxFs / 2,
                    y: Math.min(...ys) - maxFs / 2,
                    w: Math.max(...xs) - Math.min(...xs) + maxFs,
                    h: Math.max(...ys) - Math.min(...ys) + maxFs
                };
            }

            if (obj.type === 'penPath' && obj.path) {
                const absPath = obj.path.map(p => ({
                    x: p.x + obj.x,
                    y: p.y + obj.y,
                    cp1: p.cp1 ? { x: p.cp1.x + obj.x, y: p.cp1.y + obj.y } : null,
                    cp2: p.cp2 ? { x: p.cp2.x + obj.x, y: p.cp2.y + obj.y } : null
                }));
                // Include control points in bounds calculation
                const allPoints = [];
                absPath.forEach(p => {
                    allPoints.push({ x: p.x, y: p.y });
                    if (p.cp1) allPoints.push(p.cp1);
                    if (p.cp2) allPoints.push(p.cp2);
                });
                const xs = allPoints.map(p => p.x), ys = allPoints.map(p => p.y);
                const sw = obj.strokeWidth || 3;
                return {
                    x: Math.min(...xs) - sw,
                    y: Math.min(...ys) - sw,
                    w: Math.max(...xs) - Math.min(...xs) + sw * 2,
                    h: Math.max(...ys) - Math.min(...ys) + sw * 2
                };
            }

            // テキストオブジェクトの場合
            if (!obj.chars || obj.chars.length === 0) {
                return { x: obj.x, y: obj.y, w: 10, h: 72 };
            }

            // 縦書きテキストの場合
            if (obj.vertical) {
                const lines = getLines(obj);
                const colWidth = getVerticalLineWidth(obj) * (obj.lineHeight || 1.2);
                const totalWidth = lines.length * colWidth;

                let maxHeight = 0;
                lines.forEach(l => {
                    const h = getVerticalLineHeight(l);
                    if (h > maxHeight) maxHeight = h;
                });

                // X位置（右から左へ）
                let right = obj.x;
                if (obj.textAlign === 'center') right = obj.x + totalWidth / 2;
                else if (obj.textAlign === 'left') right = obj.x + totalWidth;

                // Y位置
                let top = obj.y;
                if (obj.verticalAlign === 'bottom') top = obj.y - maxHeight;
                else if (obj.verticalAlign === 'middle') top = obj.y - maxHeight / 2;

                return { x: right - totalWidth, y: top, w: totalWidth || 10, h: maxHeight || 72 };
            }

            // 横書きテキストの場合
            const lines = getLines(obj), blh = getLineHeight(obj), lh = blh * (obj.lineHeight || 1.2);
            let mw = 0;
            lines.forEach(l => { const w = getLineWidth(l); if (w > mw) mw = w; });
            const th = lines.length * lh;
            let left = obj.x;
            if (obj.textAlign === 'center') left = obj.x - mw / 2;
            else if (obj.textAlign === 'right') left = obj.x - mw;
            let top = obj.y - lh / 2;
            if (obj.verticalAlign === 'bottom') top = obj.y - th + lh / 2;
            else if (obj.verticalAlign === 'middle') top = obj.y - th / 2;
            return { x: left, y: top, w: mw || 10, h: th || lh };
        }

        function selectObject(id, addToSelection = false) {
            if (addToSelection) {
                // Shift+クリック: 複数選択に追加/削除
                const idx = selectedObjIds.indexOf(id);
                if (idx === -1) {
                    selectedObjIds.push(id);
                } else {
                    selectedObjIds.splice(idx, 1);
                }
                // selectedObjIdは最後に追加したものに設定
                selectedObjId = selectedObjIds.length > 0 ? selectedObjIds[selectedObjIds.length - 1] : null;
            } else {
                // 通常クリック: 単一選択
                selectedObjId = id;
                selectedObjIds = id ? [id] : [];
            }
            updateLayerList();
            updateLayerProps();
            updateCharInfo();
            render();
        }

        function enterEditMode(id) {
            saveState();  // 編集開始前の状態を保存
            editingObjId = id; selectedObjId = id;
            const obj = textObjects.find(o => o.id === id);
            cursorPos = obj ? obj.chars.length : 0;
            cursorVisible = true;
            if (cursorInterval) clearInterval(cursorInterval);
            cursorInterval = setInterval(() => { cursorVisible = !cursorVisible; render(); }, 500);
            imeInput.focus();
            updateLayerList(); updateLayerProps();
        }

        function exitEditMode() {
            flushDebouncedSave();  // 保留中のUndo保存をフラッシュ
            if (editingObjId) {
                const obj = textObjects.find(o => o.id === editingObjId);
                if (obj && obj.chars.length === 0) {
                    textObjects = textObjects.filter(o => o.id !== editingObjId);
                    window.textObjects = textObjects;
                    selectedObjId = null;
                }
            }
            editingObjId = null; selectedCharStart = -1; selectedCharEnd = -1;
            if (cursorInterval) clearInterval(cursorInterval);
            imeInput.blur(); updateLayerList(); render();
        }

        // ペンパスの制御点を検出
        function getPenControlPointAt(obj, x, y) {
            if (obj.type !== 'penPath' || !obj.path) return null;
            const threshold = 8;

            for (let i = 0; i < obj.path.length; i++) {
                const p = obj.path[i];
                const absX = p.x + obj.x;
                const absY = p.y + obj.y;

                // 制御点1をチェック
                if (p.cp1) {
                    const cp1X = p.cp1.x + obj.x;
                    const cp1Y = p.cp1.y + obj.y;
                    if (Math.abs(x - cp1X) < threshold && Math.abs(y - cp1Y) < threshold) {
                        return { pointIndex: i, type: 'cp1' };
                    }
                }

                // 制御点2をチェック
                if (p.cp2) {
                    const cp2X = p.cp2.x + obj.x;
                    const cp2Y = p.cp2.y + obj.y;
                    if (Math.abs(x - cp2X) < threshold && Math.abs(y - cp2Y) < threshold) {
                        return { pointIndex: i, type: 'cp2' };
                    }
                }

                // アンカーポイントをチェック
                if (Math.abs(x - absX) < threshold && Math.abs(y - absY) < threshold) {
                    return { pointIndex: i, type: 'anchor' };
                }
            }

            return null;
        }

        function applyStyle() {
            // Undo/Redoのために現在の状態を保存
            saveState();

            // 編集モードで文字選択がある場合：選択範囲のみに適用
            if (editingObjId) {
                const obj = textObjects.find(o => o.id === editingObjId);
                if (!obj || !obj.chars) return;

                // 文字選択がある場合は選択範囲のみ
                if (selectedCharStart !== -1 && selectedCharStart !== selectedCharEnd) {
                    const s = Math.min(selectedCharStart, selectedCharEnd);
                    const en = Math.max(selectedCharStart, selectedCharEnd);
                    const style = getDefaultStyle();
                    for (let i = s; i < en; i++) Object.assign(obj.chars[i], style);
                }
                // 文字選択がない場合は全文字に適用
                else {
                    const style = getDefaultStyle();
                    obj.chars.forEach(c => Object.assign(c, style));
                }
                render();
                return;
            }

            // 選択ツールでレイヤーを選択している場合：全文字に適用
            if (selectedObjIds.length > 0) {
                const style = getDefaultStyle();
                // 複数選択時：すべての選択オブジェクトに適用
                selectedObjIds.forEach(id => {
                    const obj = textObjects.find(o => o.id === id);
                    if (obj && obj.chars) {  // テキストオブジェクトのみ
                        obj.chars.forEach(c => Object.assign(c, style));
                    }
                });
                render();
            }
        }

        function setTextAlign(a) {
            document.querySelectorAll('[data-align]').forEach(b => b.classList.remove('active'));
            document.querySelector(`[data-align="${a}"]`).classList.add('active');
            // 複数選択時：すべての選択オブジェクトに適用
            if (selectedObjIds.length > 0) {
                selectedObjIds.forEach(id => {
                    const obj = textObjects.find(o => o.id === id);
                    if (obj) { obj.textAlign = a; }
                });
                render();
            }
        }

        function setVerticalAlign(a) {
            document.querySelectorAll('[data-valign]').forEach(b => b.classList.remove('active'));
            document.querySelector(`[data-valign="${a}"]`).classList.add('active');
            // 複数選択時：すべての選択オブジェクトに適用
            if (selectedObjIds.length > 0) {
                selectedObjIds.forEach(id => {
                    const obj = textObjects.find(o => o.id === id);
                    if (obj) { obj.verticalAlign = a; }
                });
                render();
            }
        }

        function updateCharInfo() {
            const info = document.getElementById('charInfo');
            if (editingObjId && selectedCharStart !== -1 && selectedCharStart !== selectedCharEnd) {
                info.textContent = `${Math.abs(selectedCharEnd - selectedCharStart)}文字選択中`;
            } else if (selectedObjId && !editingObjId) {
                const obj = textObjects.find(o => o.id === selectedObjId);
                if (obj && obj.chars) {
                    info.textContent = `レイヤー全体 (${obj.chars.length}文字)`;
                } else {
                    info.textContent = 'テキストオブジェクトを選択してください';
                }
            } else {
                info.textContent = '文字を選択してください';
            }
        }

        function copySelected() {
            if (selectedObjIds.length === 0) return;
            // 複数選択時：すべての選択オブジェクトをコピー
            clipboard = selectedObjIds.map(id => {
                const obj = textObjects.find(o => o.id === id);
                return obj ? JSON.parse(JSON.stringify(obj)) : null;
            }).filter(o => o !== null);
        }

        function pasteObject() {
            if (!clipboard || clipboard.length === 0) return;
            saveState();
            const newIds = [];

            // 配列でない場合（旧形式の互換性のため）
            if (!Array.isArray(clipboard)) {
                clipboard = [clipboard];
            }

            clipboard.forEach((clipObj, index) => {
                const newObj = JSON.parse(JSON.stringify(clipObj));
                newObj.id = Date.now() + index;
                newObj.x += 20;  // オフセット
                newObj.y += 20;
                newObj.name = (newObj.name || 'Object') + ' (コピー)';
                textObjects.push(newObj);
                newIds.push(newObj.id);
            });

            // 貼り付けたオブジェクトを選択
            if (newIds.length === 1) {
                selectObject(newIds[0]);
            } else {
                selectedObjIds = newIds;
                selectedObjId = newIds[newIds.length - 1];
            }
            updateLayerList();
            render();
        }

        function deleteSelected() {
            if (selectedObjIds.length === 0) return;
            saveState();
            textObjects = textObjects.filter(o => !selectedObjIds.includes(o.id));
            window.textObjects = textObjects;
            selectedObjId = null;
            selectedObjIds = [];
            editingObjId = null;
            updateLayerList(); updateLayerProps(); render();
        }

        function groupSelected() {
            if (selectedObjIds.length < 2) return;
            saveState();

            // 選択されたオブジェクトを取得
            const objs = textObjects.filter(o => selectedObjIds.includes(o.id));
            if (objs.length < 2) return;

            // バウンディングボックスを計算
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            objs.forEach(obj => {
                const bounds = getObjectBounds(obj);
                minX = Math.min(minX, bounds.x);
                minY = Math.min(minY, bounds.y);
                maxX = Math.max(maxX, bounds.x + bounds.w);
                maxY = Math.max(maxY, bounds.y + bounds.h);
            });

            const cx = (minX + maxX) / 2;
            const cy = (minY + maxY) / 2;

            // グループ内のオブジェクトの位置を相対座標に変換
            const children = objs.map(obj => {
                const clone = JSON.parse(JSON.stringify(obj));
                clone.x = obj.x - cx;
                clone.y = obj.y - cy;
                return clone;
            });

            // グループオブジェクトを作成
            const groupObj = {
                id: Date.now(),
                type: 'group',
                name: 'グループ ' + (textObjects.filter(o => o.type === 'group').length + 1),
                x: cx,
                y: cy,
                width: maxX - minX,
                height: maxY - minY,
                rotation: 0,
                opacity: 100,
                children: children
            };

            // 元のオブジェクトを削除
            textObjects = textObjects.filter(o => !selectedObjIds.includes(o.id));
            window.textObjects = textObjects;

            // グループを追加
            textObjects.push(groupObj);

            // グループを選択
            selectedObjId = groupObj.id;
            selectedObjIds = [groupObj.id];

            updateLayerList();
            updateLayerProps();
            render();
        }

        function ungroupSelected() {
            if (selectedObjIds.length === 0) return;

            // 選択されたグループオブジェクトを取得
            const groupObjs = textObjects.filter(o => selectedObjIds.includes(o.id) && o.type === 'group');
            if (groupObjs.length === 0) return;

            saveState();

            const newObjIds = [];

            groupObjs.forEach(groupObj => {
                // グループ内のオブジェクトを展開
                if (groupObj.children) {
                    groupObj.children.forEach(child => {
                        const newObj = JSON.parse(JSON.stringify(child));
                        newObj.id = Date.now() + Math.random() * 1000;
                        // 相対座標を絶対座標に戻す
                        newObj.x = child.x + groupObj.x;
                        newObj.y = child.y + groupObj.y;
                        textObjects.push(newObj);
                        newObjIds.push(newObj.id);
                    });
                }
            });

            // グループオブジェクトを削除
            textObjects = textObjects.filter(o => !(selectedObjIds.includes(o.id) && o.type === 'group'));
            window.textObjects = textObjects;

            // 展開されたオブジェクトを選択
            selectedObjIds = newObjIds;
            selectedObjId = newObjIds.length > 0 ? newObjIds[newObjIds.length - 1] : null;

            updateLayerList();
            updateLayerProps();
            render();
        }

        function moveLayerUp() {
            if (!selectedObjId) return;
            const idx = textObjects.findIndex(o => o.id === selectedObjId);
            if (idx < textObjects.length - 1) { saveState(); [textObjects[idx], textObjects[idx + 1]] = [textObjects[idx + 1], textObjects[idx]]; updateLayerList(); render(); }
        }

        function moveLayerDown() {
            if (!selectedObjId) return;
            const idx = textObjects.findIndex(o => o.id === selectedObjId);
            if (idx > 0) { saveState(); [textObjects[idx], textObjects[idx - 1]] = [textObjects[idx - 1], textObjects[idx]]; updateLayerList(); render(); }
        }

        function updateLayerName() {
            if (selectedObjIds.length === 0) return;
            const newName = document.getElementById('layerName').value;
            // 複数選択時：最初のオブジェクトのみ名前変更（一括名前変更は複雑なので単一のみ）
            if (selectedObjIds.length === 1) {
                const obj = textObjects.find(o => o.id === selectedObjIds[0]);
                if (obj) { obj.name = newName; updateLayerList(); }
            }
        }
        function updateLayerPosition() {
            if (selectedObjIds.length === 0) return;
            const newX = parseFloat(document.getElementById('layerX').value) || 0;
            const newY = parseFloat(document.getElementById('layerY').value) || 0;
            // 複数選択時：すべての選択オブジェクトの相対位置を維持して移動
            if (selectedObjIds.length === 1) {
                const obj = textObjects.find(o => o.id === selectedObjIds[0]);
                if (obj) { obj.x = newX; obj.y = newY; render(); }
            } else {
                // 複数選択時は最初のオブジェクトを基準に相対移動
                const firstObj = textObjects.find(o => o.id === selectedObjIds[0]);
                if (firstObj) {
                    const deltaX = newX - firstObj.x;
                    const deltaY = newY - firstObj.y;
                    selectedObjIds.forEach(id => {
                        const obj = textObjects.find(o => o.id === id);
                        if (obj) { obj.x += deltaX; obj.y += deltaY; }
                    });
                    render();
                }
            }
        }
        function updateLayerRotation() {
            if (selectedObjIds.length === 0) return;
            const newRotation = parseFloat(document.getElementById('layerRotation').value) || 0;
            // 複数選択時：すべての選択オブジェクトに適用
            selectedObjIds.forEach(id => {
                const obj = textObjects.find(o => o.id === id);
                if (obj) { obj.rotation = newRotation; }
            });
            render();
        }
        function updateLayerLineHeight() {
            if (selectedObjIds.length === 0) return;
            const newLineHeight = parseFloat(document.getElementById('layerLineHeight').value) || 1.2;
            // 複数選択時：すべての選択オブジェクトに適用
            selectedObjIds.forEach(id => {
                const obj = textObjects.find(o => o.id === id);
                if (obj) { obj.lineHeight = newLineHeight; }
            });
            render();
        }
        function updateLayerOpacity() {
            if (selectedObjIds.length === 0) return;
            const newOpacity = parseInt(document.getElementById('layerOpacity').value);
            // 複数選択時：すべての選択オブジェクトに適用
            selectedObjIds.forEach(id => {
                const obj = textObjects.find(o => o.id === id);
                if (obj) { obj.opacity = newOpacity; }
            });
            document.getElementById('opacityVal').textContent = newOpacity;
            render();
        }

        function updateLayerSize() {
            if (!selectedObjId) return;
            const obj = textObjects.find(o => o.id === selectedObjId);
            if (!obj || !obj.chars.length) return;
            const bounds = getObjectBounds(obj);
            const newW = parseFloat(document.getElementById('layerWidth').value) || bounds.w;
            const newH = parseFloat(document.getElementById('layerHeight').value) || bounds.h;
            const sfX = newW / bounds.w, sfY = newH / bounds.h;
            obj.chars.forEach(c => {
                c.fontSize = Math.max(1, Math.round(c.fontSize * sfY));
                c.scaleX = Math.max(10, Math.round((c.scaleX || 100) * sfX / sfY));
            });
            render();
        }

        function updateLayerProps() {
            const propsDiv = document.getElementById('layerProps');
            if (!selectedObjId) { propsDiv.style.display = 'none'; return; }
            const obj = textObjects.find(o => o.id === selectedObjId);
            if (!obj) { propsDiv.style.display = 'none'; return; }
            propsDiv.style.display = 'block';

            // 複数選択時のメッセージ表示
            let bulkEditMsg = document.getElementById('bulkEditMessage');
            if (!bulkEditMsg) {
                bulkEditMsg = document.createElement('div');
                bulkEditMsg.id = 'bulkEditMessage';
                bulkEditMsg.style.cssText = 'background: #e3f2fd; padding: 8px; margin-bottom: 10px; border-radius: 4px; font-size: 12px; color: #1976d2;';
                propsDiv.insertBefore(bulkEditMsg, propsDiv.firstChild);
            }
            if (selectedObjIds.length > 1) {
                bulkEditMsg.style.display = 'block';
                bulkEditMsg.textContent = `📋 ${selectedObjIds.length}個のオブジェクトを選択中（一括編集モード）`;
            } else {
                bulkEditMsg.style.display = 'none';
            }

            const bounds = getObjectBounds(obj);
            document.getElementById('layerName').value = obj.name || '';
            document.getElementById('layerX').value = obj.x.toFixed(1);
            document.getElementById('layerY').value = obj.y.toFixed(1);
            document.getElementById('layerWidth').value = bounds.w.toFixed(1);
            document.getElementById('layerHeight').value = bounds.h.toFixed(1);
            document.getElementById('layerRotation').value = obj.rotation || 0;
            document.getElementById('layerLineHeight').value = obj.lineHeight || 1.2;
            document.getElementById('layerOpacity').value = obj.opacity || 100;
            document.getElementById('opacityVal').textContent = obj.opacity || 100;
            document.querySelectorAll('[data-align]').forEach(b => b.classList.remove('active'));
            document.querySelector(`[data-align="${obj.textAlign || 'left'}"]`)?.classList.add('active');
            document.querySelectorAll('[data-valign]').forEach(b => b.classList.remove('active'));
            document.querySelector(`[data-valign="${obj.verticalAlign || 'middle'}"]`)?.classList.add('active');
            // Load name tag, balloon, shape, pathText, and penPath UI
            loadNameTagUI(obj);
            loadBalloonUI(obj);
            loadShapeUI(obj);
            loadPathTextUI(obj);
            loadPenPathUI(obj);

            // テキストオブジェクトの場合、文字スタイルUIを更新
            if (obj.chars && obj.chars.length > 0) {
                loadCharStyleUI(obj);
            }

            // 画像オブジェクトの場合、画像設定UIを更新
            loadImageUI(obj);

            // アニメーション設定UIを更新
            loadAnimationUI(obj);
        }

        // テキストオブジェクト選択時に文字スタイルUIを更新
        function loadCharStyleUI(obj) {
            if (!obj.chars || obj.chars.length === 0) return;

            // 最初の文字のスタイルを取得（または全文字が同じなら共通値）
            const firstChar = obj.chars[0];

            // フォント
            const fontSel = document.getElementById('fontFamily');
            const customInput = document.getElementById('customFontInput');
            const fontValue = firstChar.fontFamily || 'Yu Gothic UI';
            if ([...fontSel.options].some(opt => opt.value === fontValue)) {
                fontSel.value = fontValue;
                customInput.style.display = 'none';
            } else {
                fontSel.value = '__custom__';
                customInput.value = fontValue;
                customInput.style.display = 'block';
            }

            // サイズ
            document.getElementById('fontSize').value = firstChar.fontSize || 72;

            // 縦横比
            document.getElementById('charScaleX').value = firstChar.scaleX || 100;

            // カーニング・トラッキング
            document.getElementById('charKerning').value = firstChar.kerning || 0;
            document.getElementById('charTracking').value = firstChar.tracking || 0;

            // ベースライン・傾き
            document.getElementById('charBaseline').value = firstChar.baseline || 0;
            document.getElementById('charSlant').value = firstChar.slant || 0;

            // 不透明度
            document.getElementById('charOpacity').value = firstChar.opacity || 100;

            // スモールキャップス
            document.getElementById('charSmallCaps').checked = firstChar.smallCaps || false;
            document.getElementById('charSmallCapsSize').value = firstChar.smallCapsSize || 70;

            // 塗り
            document.getElementById('fillType').value = firstChar.fillType || 'solid';

            // グラデーションストップ
            if (firstChar.gradientStops && firstChar.gradientStops.length >= 2) {
                const stops = document.querySelectorAll('#gradientStops .gradient-stop');
                if (stops.length >= 2) {
                    stops[0].querySelector('.grad-color').value = firstChar.gradientStops[0].color;
                    stops[0].querySelector('.grad-ratio').value = firstChar.gradientStops[0].ratio || 50;
                    stops[1].querySelector('.grad-color').value = firstChar.gradientStops[1].color;
                    stops[1].querySelector('.grad-ratio').value = firstChar.gradientStops[1].ratio || 50;
                }
            } else {
                const stops = document.querySelectorAll('#gradientStops .gradient-stop');
                if (stops.length >= 2) {
                    stops[0].querySelector('.grad-color').value = firstChar.color || '#ffffff';
                }
            }

            document.getElementById('gradientAngle').value = firstChar.gradientAngle || 0;
            document.getElementById('gradientBlur').value = firstChar.gradientBlur || 0;

            // 光沢
            document.getElementById('glossEnabled').checked = firstChar.gloss?.enabled || false;
            document.getElementById('glossWidth').value = firstChar.gloss?.width || 10;
            document.getElementById('glossBlur').value = firstChar.gloss?.blur || 5;
            document.getElementById('glossColor').value = firstChar.gloss?.color || '#ffffff';
            document.getElementById('glossOpacity').value = firstChar.gloss?.opacity || 50;

            // 影
            document.getElementById('shadowEnabled').checked = firstChar.shadow?.enabled || false;
            document.getElementById('shadowColor').value = firstChar.shadow?.color || '#000000';
            document.getElementById('shadowOpacity').value = firstChar.shadow?.opacity || 50;
            document.getElementById('shadowAngle').value = firstChar.shadow?.angle || 45;
            document.getElementById('shadowDistance').value = firstChar.shadow?.distance || 5;
            document.getElementById('shadowSize').value = firstChar.shadow?.size || 0;
            document.getElementById('shadowBlur').value = firstChar.shadow?.blur || 5;

            // ストローク
            loadStrokeUI(firstChar.strokes);
        }

        // ストロークUIを更新
        function loadStrokeUI(strokes) {
            const list = document.getElementById('strokeList');
            list.innerHTML = '';

            const strokesData = strokes || [{ enabled: true, type: 'edge', color: '#000000', width: 4, opacity: 100, join: 'round' }];

            strokesData.forEach((st, i) => {
                const div = document.createElement('div');
                div.className = 'stroke-item';
                div.innerHTML = `
                    <div class="stroke-header">
                        <label><input type="checkbox" class="stroke-enabled" ${st.enabled ? 'checked' : ''} onchange="applyStyle()"> ストローク${i + 1}</label>
                        <button class="btn btn-small btn-danger" onclick="this.parentElement.parentElement.remove();applyStyle()">×</button>
                    </div>
                    <div class="row2">
                        <div><label>種類</label><select class="stroke-type" onchange="applyStyle()">
                            <option value="edge" ${st.type === 'edge' ? 'selected' : ''}>エッジ</option>
                            <option value="depth" ${st.type === 'depth' ? 'selected' : ''}>奥行き</option>
                            <option value="drop" ${st.type === 'drop' ? 'selected' : ''}>ドロップ</option>
                        </select></div>
                        <div><label>色</label><input type="color" class="stroke-color" value="${st.color || '#000000'}" onchange="applyStyle()"></div>
                    </div>
                    <div class="row2">
                        <div><label>太さ</label><input type="number" class="stroke-width" value="${st.width || 4}" min="0" max="50" onchange="applyStyle()"></div>
                        <div><label>不透明度%</label><input type="number" class="stroke-opacity" value="${st.opacity || 100}" min="0" max="100" onchange="applyStyle()"></div>
                    </div>
                    <div class="row2">
                        <div><label>角度°</label><input type="number" class="stroke-angle" value="${st.angle || 45}" step="1" onchange="applyStyle()"></div>
                        <div><label>角</label><select class="stroke-join" onchange="applyStyle()">
                            <option value="round" ${st.join === 'round' ? 'selected' : ''}>丸み</option>
                            <option value="miter" ${st.join === 'miter' ? 'selected' : ''}>角</option>
                            <option value="bevel" ${st.join === 'bevel' ? 'selected' : ''}>面取り</option>
                        </select></div>
                    </div>
                    <div class="row2">
                        <div><label><input type="checkbox" class="stroke-blur" ${st.blur ? 'checked' : ''} onchange="applyStyle()"> ぼかし</label></div>
                        <div><label>量</label><input type="number" class="stroke-blur-amount" value="${st.blurAmount || 0}" min="0" max="20" onchange="applyStyle()"></div>
                    </div>
                `;
                list.appendChild(div);
            });
        }

        function updateLayerList() {
            const list = document.getElementById('layerList');
            list.innerHTML = '';
            textObjects.slice().reverse().forEach(obj => {
                const div = document.createElement('div');
                const isSelected = selectedObjIds.includes(obj.id);
                div.className = 'layer-item' + (isSelected ? ' selected' : '');

                // グループオブジェクトの表示
                if (obj.type === 'group') {
                    div.textContent = '📁 ' + (obj.name || 'グループ');
                } else {
                    div.textContent = obj.name || (obj.chars ? obj.chars.map(c => c.char).join('').substring(0, 10) : 'オブジェクト');
                }

                div.onclick = (e) => { exitEditMode(); selectObject(obj.id, e.shiftKey || e.ctrlKey || e.metaKey); };
                div.ondblclick = () => {
                    if (obj.type === 'group') {
                        // グループをダブルクリックで選択解除してグループ内を選択
                    } else if (obj.type === 'text' || obj.type === 'pathText') {
                        setTool('text');
                        enterEditMode(obj.id);
                    }
                };
                list.appendChild(div);
            });
        }

        function drawRoundedRect(ctx, x, y, w, h, r) {
            r = Math.min(r, w / 2, h / 2);
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + w - r, y);
            ctx.quadraticCurveTo(x + w, y, x + w, y + r);
            ctx.lineTo(x + w, y + h - r);
            ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            ctx.lineTo(x + r, y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - r);
            ctx.lineTo(x, y + r);
            ctx.quadraticCurveTo(x, y, x + r, y);
            ctx.closePath();
        }

        function drawShape(ctx, obj) {
            const hw = obj.width / 2;
            const hh = obj.height / 2;

            ctx.save();

            // 塗りつぶし
            const fillType = obj.fillType || 'solid';
            if (fillType !== 'none' && obj.fillOpacity > 0) {
                ctx.globalAlpha = (obj.fillOpacity || 100) / 100;

                // グラデーション設定
                if (fillType === 'linear' || fillType === 'radial') {
                    let grad;
                    if (fillType === 'linear') {
                        const a = (obj.gradientAngle || 0) * Math.PI / 180;
                        const dx = Math.cos(a) * hw, dy = Math.sin(a) * hh;
                        grad = ctx.createLinearGradient(obj.x - dx, obj.y - dy, obj.x + dx, obj.y + dy);
                    } else {
                        grad = ctx.createRadialGradient(obj.x, obj.y, 0, obj.x, obj.y, Math.max(hw, hh));
                    }

                    // グラデーションストップ
                    if (obj.gradientStops && obj.gradientStops.length >= 2) {
                        obj.gradientStops.forEach((stop, i) => {
                            if (i === 0) {
                                grad.addColorStop(0, stop.color);
                            } else if (i === obj.gradientStops.length - 1) {
                                grad.addColorStop(1, stop.color);
                            } else {
                                grad.addColorStop(stop.pos / 100, stop.color);
                            }
                        });
                    } else {
                        grad.addColorStop(0, obj.fill || '#ffffff');
                        grad.addColorStop(1, '#888888');
                    }
                    ctx.fillStyle = grad;
                } else {
                    ctx.fillStyle = obj.fill || '#ffffff';
                }

                if (obj.type === 'rect') {
                    ctx.fillRect(obj.x - hw, obj.y - hh, obj.width, obj.height);
                } else if (obj.type === 'roundRect') {
                    drawRoundedRect(ctx, obj.x - hw, obj.y - hh, obj.width, obj.height, obj.cornerRadius || 20);
                    ctx.fill();
                } else if (obj.type === 'ellipse') {
                    ctx.beginPath();
                    ctx.ellipse(obj.x, obj.y, hw, hh, 0, 0, Math.PI * 2);
                    ctx.fill();
                } else if (obj.type === 'triangle') {
                    ctx.beginPath();
                    ctx.moveTo(obj.x, obj.y - hh);
                    ctx.lineTo(obj.x + hw, obj.y + hh);
                    ctx.lineTo(obj.x - hw, obj.y + hh);
                    ctx.closePath();
                    ctx.fill();
                } else if (obj.type === 'chamferRect') {
                    const c = Math.min(obj.cornerRadius || 10, hw, hh);
                    ctx.beginPath();
                    ctx.moveTo(obj.x - hw + c, obj.y - hh);
                    ctx.lineTo(obj.x + hw - c, obj.y - hh);
                    ctx.lineTo(obj.x + hw, obj.y - hh + c);
                    ctx.lineTo(obj.x + hw, obj.y + hh - c);
                    ctx.lineTo(obj.x + hw - c, obj.y + hh);
                    ctx.lineTo(obj.x - hw + c, obj.y + hh);
                    ctx.lineTo(obj.x - hw, obj.y + hh - c);
                    ctx.lineTo(obj.x - hw, obj.y - hh + c);
                    ctx.closePath();
                    ctx.fill();
                } else if (obj.type === 'arc') {
                    ctx.beginPath();
                    ctx.arc(obj.x, obj.y + hh, Math.min(hw, hh * 2), Math.PI, 0);
                    ctx.fill();
                }
            }

            // 縁取り
            if (obj.stroke && obj.strokeWidth > 0 && obj.strokeOpacity > 0) {
                ctx.globalAlpha = (obj.strokeOpacity || 100) / 100;
                ctx.strokeStyle = obj.stroke;
                ctx.lineWidth = obj.strokeWidth;

                if (obj.type === 'rect') {
                    ctx.strokeRect(obj.x - hw, obj.y - hh, obj.width, obj.height);
                } else if (obj.type === 'roundRect') {
                    drawRoundedRect(ctx, obj.x - hw, obj.y - hh, obj.width, obj.height, obj.cornerRadius || 20);
                    ctx.stroke();
                } else if (obj.type === 'ellipse') {
                    ctx.beginPath();
                    ctx.ellipse(obj.x, obj.y, hw, hh, 0, 0, Math.PI * 2);
                    ctx.stroke();
                } else if (obj.type === 'triangle') {
                    ctx.beginPath();
                    ctx.moveTo(obj.x, obj.y - hh);
                    ctx.lineTo(obj.x + hw, obj.y + hh);
                    ctx.lineTo(obj.x - hw, obj.y + hh);
                    ctx.closePath();
                    ctx.stroke();
                } else if (obj.type === 'line') {
                    ctx.beginPath();
                    ctx.moveTo(obj.x - hw, obj.y - hh);
                    ctx.lineTo(obj.x + hw, obj.y + hh);
                    ctx.stroke();
                } else if (obj.type === 'chamferRect') {
                    const c = Math.min(obj.cornerRadius || 10, hw, hh);
                    ctx.beginPath();
                    ctx.moveTo(obj.x - hw + c, obj.y - hh);
                    ctx.lineTo(obj.x + hw - c, obj.y - hh);
                    ctx.lineTo(obj.x + hw, obj.y - hh + c);
                    ctx.lineTo(obj.x + hw, obj.y + hh - c);
                    ctx.lineTo(obj.x + hw - c, obj.y + hh);
                    ctx.lineTo(obj.x - hw + c, obj.y + hh);
                    ctx.lineTo(obj.x - hw, obj.y + hh - c);
                    ctx.lineTo(obj.x - hw, obj.y - hh + c);
                    ctx.closePath();
                    ctx.stroke();
                } else if (obj.type === 'arc') {
                    ctx.beginPath();
                    ctx.arc(obj.x, obj.y + hh, Math.min(hw, hh * 2), Math.PI, 0);
                    ctx.stroke();
                }
            }

            ctx.restore();
        }

        function drawBalloon(ctx, obj, bounds) {
            const b = obj.balloon;
            if (!b || !b.enabled) return;

            const padX = b.padX || 30;
            const padY = b.padY || 20;
            const bx = bounds.x - padX;
            const by = bounds.y - padY;
            const bw = bounds.w + padX * 2;
            const bh = bounds.h + padY * 2;
            const radius = b.radius || 20;

            ctx.save();

            // Calculate tail points
            let tailPoints = null;
            if (b.tailEnabled) {
                const tailWidth = b.tailWidth || 20;
                const tailLength = b.tailLength || 30;
                const tailPos = (b.tailPos || 50) / 100;
                const tailDir = b.tailDir || 'bottom';

                let tx, ty, t1x, t1y, t2x, t2y, tipX, tipY;

                if (tailDir === 'bottom' || tailDir === 'bottom-left' || tailDir === 'bottom-right') {
                    tx = bx + bw * tailPos;
                    ty = by + bh;
                    t1x = tx - tailWidth / 2;
                    t2x = tx + tailWidth / 2;
                    t1y = t2y = ty;
                    tipX = tailDir === 'bottom-left' ? tx - tailLength : (tailDir === 'bottom-right' ? tx + tailLength : tx);
                    tipY = ty + tailLength;
                } else if (tailDir === 'top') {
                    tx = bx + bw * tailPos;
                    ty = by;
                    t1x = tx - tailWidth / 2;
                    t2x = tx + tailWidth / 2;
                    t1y = t2y = ty;
                    tipX = tx;
                    tipY = ty - tailLength;
                } else if (tailDir === 'left') {
                    tx = bx;
                    ty = by + bh * tailPos;
                    t1y = ty - tailWidth / 2;
                    t2y = ty + tailWidth / 2;
                    t1x = t2x = tx;
                    tipX = tx - tailLength;
                    tipY = ty;
                } else { // right
                    tx = bx + bw;
                    ty = by + bh * tailPos;
                    t1y = ty - tailWidth / 2;
                    t2y = ty + tailWidth / 2;
                    t1x = t2x = tx;
                    tipX = tx + tailLength;
                    tipY = ty;
                }
                tailPoints = { t1x, t1y, t2x, t2y, tipX, tipY, dir: tailDir };
            }

            // For rounded rectangle, draw body and tail as single unified path
            if (b.shape !== 'ellipse' && b.shape !== 'cloud') {
                const r = Math.min(radius, bw / 2, bh / 2);

                ctx.beginPath();
                ctx.moveTo(bx + r, by);

                // Top edge
                if (tailPoints && tailPoints.dir === 'top') {
                    ctx.lineTo(tailPoints.t1x, tailPoints.t1y);
                    ctx.lineTo(tailPoints.tipX, tailPoints.tipY);
                    ctx.lineTo(tailPoints.t2x, tailPoints.t2y);
                }
                ctx.lineTo(bx + bw - r, by);
                ctx.quadraticCurveTo(bx + bw, by, bx + bw, by + r);

                // Right edge
                if (tailPoints && tailPoints.dir === 'right') {
                    ctx.lineTo(tailPoints.t1x, tailPoints.t1y);
                    ctx.lineTo(tailPoints.tipX, tailPoints.tipY);
                    ctx.lineTo(tailPoints.t2x, tailPoints.t2y);
                }
                ctx.lineTo(bx + bw, by + bh - r);
                ctx.quadraticCurveTo(bx + bw, by + bh, bx + bw - r, by + bh);

                // Bottom edge
                if (tailPoints && (tailPoints.dir === 'bottom' || tailPoints.dir === 'bottom-left' || tailPoints.dir === 'bottom-right')) {
                    ctx.lineTo(tailPoints.t2x, tailPoints.t2y);
                    ctx.lineTo(tailPoints.tipX, tailPoints.tipY);
                    ctx.lineTo(tailPoints.t1x, tailPoints.t1y);
                }
                ctx.lineTo(bx + r, by + bh);
                ctx.quadraticCurveTo(bx, by + bh, bx, by + bh - r);

                // Left edge
                if (tailPoints && tailPoints.dir === 'left') {
                    ctx.lineTo(tailPoints.t2x, tailPoints.t2y);
                    ctx.lineTo(tailPoints.tipX, tailPoints.tipY);
                    ctx.lineTo(tailPoints.t1x, tailPoints.t1y);
                }
                ctx.lineTo(bx, by + r);
                ctx.quadraticCurveTo(bx, by, bx + r, by);
                ctx.closePath();

                // Fill
                ctx.globalAlpha = (b.fillOpacity || 100) / 100;
                ctx.fillStyle = b.fill || '#ffffff';
                ctx.fill();

                // Stroke
                if (b.strokeEnabled) {
                    ctx.strokeStyle = b.strokeColor || '#000000';
                    ctx.lineWidth = b.strokeWidth || 3;
                    ctx.stroke();
                }
            } else if (b.shape === 'ellipse') {
                // Ellipse shape
                ctx.beginPath();
                ctx.ellipse(bx + bw / 2, by + bh / 2, bw / 2, bh / 2, 0, 0, Math.PI * 2);
                ctx.closePath();

                ctx.globalAlpha = (b.fillOpacity || 100) / 100;
                ctx.fillStyle = b.fill || '#ffffff';
                ctx.fill();

                // Draw tail separately for ellipse
                if (tailPoints) {
                    ctx.beginPath();
                    ctx.moveTo(tailPoints.t1x, tailPoints.t1y);
                    ctx.lineTo(tailPoints.tipX, tailPoints.tipY);
                    ctx.lineTo(tailPoints.t2x, tailPoints.t2y);
                    ctx.closePath();
                    ctx.fill();
                }

                // Stroke
                if (b.strokeEnabled) {
                    ctx.strokeStyle = b.strokeColor || '#000000';
                    ctx.lineWidth = b.strokeWidth || 3;
                    ctx.beginPath();
                    ctx.ellipse(bx + bw / 2, by + bh / 2, bw / 2, bh / 2, 0, 0, Math.PI * 2);
                    ctx.stroke();

                    if (tailPoints) {
                        ctx.beginPath();
                        ctx.moveTo(tailPoints.t1x, tailPoints.t1y);
                        ctx.lineTo(tailPoints.tipX, tailPoints.tipY);
                        ctx.lineTo(tailPoints.t2x, tailPoints.t2y);
                        ctx.stroke();
                    }
                }
            } else {
                // Cloud shape
                const cx = bx + bw / 2, cy = by + bh / 2;
                const rx = bw / 2, ry = bh / 2;
                const bumps = 8;

                ctx.beginPath();
                for (let i = 0; i < bumps; i++) {
                    const angle = (i / bumps) * Math.PI * 2;
                    const px = cx + Math.cos(angle) * rx * 0.8;
                    const py = cy + Math.sin(angle) * ry * 0.8;
                    const bumpR = Math.min(rx, ry) * 0.4;
                    if (i === 0) ctx.moveTo(px + bumpR, py);
                    ctx.arc(px, py, bumpR, 0, Math.PI * 2);
                }
                ctx.closePath();

                ctx.globalAlpha = (b.fillOpacity || 100) / 100;
                ctx.fillStyle = b.fill || '#ffffff';
                ctx.fill();

                if (tailPoints) {
                    ctx.beginPath();
                    ctx.moveTo(tailPoints.t1x, tailPoints.t1y);
                    ctx.lineTo(tailPoints.tipX, tailPoints.tipY);
                    ctx.lineTo(tailPoints.t2x, tailPoints.t2y);
                    ctx.closePath();
                    ctx.fill();
                }

                if (b.strokeEnabled) {
                    ctx.strokeStyle = b.strokeColor || '#000000';
                    ctx.lineWidth = b.strokeWidth || 3;
                    for (let i = 0; i < bumps; i++) {
                        const angle = (i / bumps) * Math.PI * 2;
                        const px = cx + Math.cos(angle) * rx * 0.8;
                        const py = cy + Math.sin(angle) * ry * 0.8;
                        const bumpR = Math.min(rx, ry) * 0.4;
                        ctx.beginPath();
                        ctx.arc(px, py, bumpR, 0, Math.PI * 2);
                        ctx.stroke();
                    }

                    if (tailPoints) {
                        ctx.beginPath();
                        ctx.moveTo(tailPoints.t1x, tailPoints.t1y);
                        ctx.lineTo(tailPoints.tipX, tailPoints.tipY);
                        ctx.lineTo(tailPoints.t2x, tailPoints.t2y);
                        ctx.stroke();
                    }
                }
            }

            ctx.restore();
        }

        // グループ内テキスト描画用のヘルパー関数
        function drawTextObject(ctx, obj) {
            if (!obj.chars || obj.chars.length === 0) return;

            const lines = getLines(obj);
            const lh = getLineHeight(obj) * (obj.lineHeight || 1.2);
            const th = lines.length * lh;
            let startY = obj.y - th / 2 + lh / 2;

            lines.forEach((line, li) => {
                const lw = getLineWidth(line);
                let lx = obj.x;
                if (obj.textAlign === 'center') lx = obj.x - lw / 2;
                else if (obj.textAlign === 'right') lx = obj.x - lw;

                const ly = startY + li * lh;

                // レガシータイトル互換：各文字の位置を事前計算
                const charPositions = [];
                let px = lx;
                line.forEach(c => {
                    const dc = c.smallCaps && /[a-z]/.test(c.char) ? c.char.toUpperCase() : c.char;
                    const fs = c.smallCaps && /[a-z]/.test(c.char) ? c.fontSize * (c.smallCapsSize || 70) / 100 : c.fontSize;
                    const charW = getCharWidth(c);
                    charPositions.push({ c, dc, fs, charW, px });
                    px += charW;
                });

                // 第1パス：すべての文字のストロークを後ろから前へ描画
                for (let charIdx = charPositions.length - 1; charIdx >= 0; charIdx--) {
                    const { c, dc, fs, charW, px } = charPositions[charIdx];

                    ctx.save();
                    const fontWeight = c.bold !== false ? 'bold' : 'normal';
                    const fontStyle = c.italic ? 'italic' : 'normal';
                    ctx.font = `${fontStyle} ${fontWeight} ${fs}px "${c.fontFamily}"`;
                    ctx.textBaseline = 'middle';
                    ctx.textAlign = 'left';
                    ctx.globalAlpha = (obj.opacity || 100) / 100 * (c.opacity || 100) / 100;

                    // ストローク（累積方式：外側から内側へ描画）
                    const strokes = c.strokes || [{ enabled: true, color: '#000', width: 4, opacity: 100 }];
                    // 有効なストロークのみ抽出
                    const enabledStrokes = strokes.filter(st => st.enabled);
                    // 累積幅を計算して外側から描画
                    for (let i = enabledStrokes.length - 1; i >= 0; i--) {
                        const st = enabledStrokes[i];
                        // 内側のストロークの累積幅
                        let innerWidth = 0;
                        for (let j = 0; j < i; j++) {
                            innerWidth += enabledStrokes[j].width;
                        }
                        let cumulativeWidth = innerWidth + st.width;
                        ctx.save();
                        ctx.globalAlpha = (obj.opacity || 100) / 100 * (c.opacity || 100) / 100 * (st.opacity || 100) / 100;
                        ctx.strokeStyle = st.color;
                        ctx.lineJoin = st.join || 'round';

                        if (st.type === 'depth') {
                            const depthAngle = (st.angle || 45) * Math.PI / 180;
                            const depthDx = Math.cos(depthAngle);
                            const depthDy = Math.sin(depthAngle);
                            for (let d = st.width; d > 0; d -= 0.5) {
                                ctx.lineWidth = innerWidth + d;
                                ctx.save();
                                ctx.translate((innerWidth + d) * depthDx, (innerWidth + d) * depthDy);
                                ctx.strokeText(dc, px, ly);
                                ctx.restore();
                            }
                        } else if (st.type === 'drop') {
                            ctx.save();
                            ctx.translate(innerWidth + st.width, innerWidth + st.width);
                            ctx.fillStyle = st.color;
                            ctx.fillText(dc, px, ly);
                            ctx.restore();
                        } else {
                            // エッジタイプ：内側の全ストローク＋文字本体の形状全体を均等に囲む
                            // マージンを大きくして隣の文字への干渉を減らす
                            const totalStrokeWidth = enabledStrokes.reduce((sum, s) => sum + s.width, 0);
                            const margin = Math.max(st.width * 6, totalStrokeWidth * 3);
                            const tempCanvas = document.createElement('canvas');
                            const metrics = ctx.measureText(dc);
                            tempCanvas.width = Math.ceil(metrics.width + charW + margin * 4);
                            tempCanvas.height = Math.ceil(fontSize * 3 + margin * 4);
                            const tempCtx = tempCanvas.getContext('2d');

                            // フォント設定をコピー
                            tempCtx.font = ctx.font;
                            tempCtx.textBaseline = ctx.textBaseline;
                            tempCtx.textAlign = ctx.textAlign;

                            const tempX = tempCanvas.width / 2;
                            const tempY = tempCanvas.height / 2;

                            // 内側の全ストロークを一時キャンバスに描画
                            for (let j = i - 1; j >= 0; j--) {
                                const innerSt = enabledStrokes[j];
                                let innerInnerWidth = 0;
                                for (let k = 0; k < j; k++) {
                                    innerInnerWidth += enabledStrokes[k].width;
                                }

                                if (innerSt.type === 'depth') {
                                    const depthAngle = (innerSt.angle || 45) * Math.PI / 180;
                                    const depthDx = Math.cos(depthAngle);
                                    const depthDy = Math.sin(depthAngle);
                                    for (let d = innerSt.width; d > 0; d -= 0.5) {
                                        tempCtx.lineWidth = innerInnerWidth + d;
                                        tempCtx.strokeStyle = innerSt.color;
                                        tempCtx.globalAlpha = (innerSt.opacity || 100) / 100;
                                        tempCtx.save();
                                        tempCtx.translate((innerInnerWidth + d) * depthDx, (innerInnerWidth + d) * depthDy);
                                        tempCtx.strokeText(dc, tempX, tempY);
                                        tempCtx.restore();
                                    }
                                } else if (innerSt.type === 'drop') {
                                    tempCtx.save();
                                    tempCtx.translate(innerInnerWidth + innerSt.width, innerInnerWidth + innerSt.width);
                                    tempCtx.fillStyle = innerSt.color;
                                    tempCtx.globalAlpha = (innerSt.opacity || 100) / 100;
                                    tempCtx.fillText(dc, tempX, tempY);
                                    tempCtx.restore();
                                } else {
                                    // 内側のエッジ（通常描画）
                                    tempCtx.lineWidth = innerInnerWidth + innerSt.width;
                                    tempCtx.strokeStyle = innerSt.color;
                                    tempCtx.globalAlpha = (innerSt.opacity || 100) / 100;
                                    tempCtx.strokeText(dc, tempX, tempY);
                                }
                            }

                            // 文字本体を一時キャンバスに描画
                            if (c.fillType !== 'none') {
                                tempCtx.fillStyle = c.color || '#ffffff';
                                tempCtx.globalAlpha = 1.0;
                                tempCtx.fillText(dc, tempX, tempY);
                            }

                            // エッジキャンバスを作成：一時キャンバスの内容を膨張させる
                            const edgeCanvas = document.createElement('canvas');
                            edgeCanvas.width = tempCanvas.width;
                            edgeCanvas.height = tempCanvas.height;
                            const edgeCtx = edgeCanvas.getContext('2d');

                            // st.joinに応じたエッジ描画アルゴリズム
                            const edgeSteps = Math.max(1, st.width);
                            const joinType = st.join || 'round';
                            const blurEnabled = st.blur || false;
                            const blurAmount = st.blurAmount || 0;

                            if (joinType === 'miter') {
                                // 角(miter): 正方形膨張（上下左右＋対角を同じ距離で）
                                for (let step = 1; step <= edgeSteps; step += 1) {
                                    edgeCtx.globalAlpha = 1.0;
                                    // 上下左右
                                    edgeCtx.drawImage(tempCanvas, step, 0);
                                    edgeCtx.drawImage(tempCanvas, -step, 0);
                                    edgeCtx.drawImage(tempCanvas, 0, step);
                                    edgeCtx.drawImage(tempCanvas, 0, -step);
                                    // 対角（正方形の角を埋める）
                                    edgeCtx.drawImage(tempCanvas, step, step);
                                    edgeCtx.drawImage(tempCanvas, step, -step);
                                    edgeCtx.drawImage(tempCanvas, -step, step);
                                    edgeCtx.drawImage(tempCanvas, -step, -step);
                                }
                            } else if (joinType === 'bevel') {
                                // 面取り(bevel): 8方向
                                const bevelStep = Math.PI / 4;
                                for (let step = 1; step <= edgeSteps; step += 1) {
                                    edgeCtx.globalAlpha = 1.0;
                                    for (let angle = 0; angle < Math.PI * 2; angle += bevelStep) {
                                        const dx = Math.cos(angle) * step;
                                        const dy = Math.sin(angle) * step;
                                        edgeCtx.drawImage(tempCanvas, dx, dy);
                                    }
                                }
                            } else {
                                // 丸み(round): 64方向で滑らかなエッジ
                                const roundStep = Math.PI / 32;
                                for (let step = 0.5; step <= edgeSteps; step += 0.5) {
                                    edgeCtx.globalAlpha = 1.0;
                                    for (let angle = 0; angle < Math.PI * 2; angle += roundStep) {
                                        const dx = Math.cos(angle) * step;
                                        const dy = Math.sin(angle) * step;
                                        edgeCtx.drawImage(tempCanvas, dx, dy);
                                    }
                                }
                            }

                            // 元の内容を引いてエッジ部分のみを残す
                            edgeCtx.globalCompositeOperation = 'destination-out';
                            edgeCtx.globalAlpha = 1.0;
                            edgeCtx.drawImage(tempCanvas, 0, 0);

                            // エッジに色を適用
                            edgeCtx.globalCompositeOperation = 'source-in';
                            edgeCtx.fillStyle = st.color;
                            edgeCtx.fillRect(0, 0, edgeCanvas.width, edgeCanvas.height);

                            // グラデーションぼかし（内側から外側へ）
                            if (blurEnabled && blurAmount > 0) {
                                const blurCanvas = document.createElement('canvas');
                                blurCanvas.width = edgeCanvas.width;
                                blurCanvas.height = edgeCanvas.height;
                                const blurCtx = blurCanvas.getContext('2d');
                                blurCtx.filter = `blur(${blurAmount}px)`;
                                blurCtx.drawImage(edgeCanvas, 0, 0);
                                edgeCtx.globalCompositeOperation = 'source-over';
                                edgeCtx.clearRect(0, 0, edgeCanvas.width, edgeCanvas.height);
                                edgeCtx.drawImage(blurCanvas, 0, 0);
                            }

                            // メインキャンバスに描画
                            ctx.globalAlpha = (obj.opacity || 100) / 100 * (c.opacity || 100) / 100 * (st.opacity || 100) / 100;
                            ctx.drawImage(edgeCanvas, px - tempX, ly - tempY);
                        }
                        ctx.restore();
                    }

                    ctx.restore();
                }

                // 第2パス：すべての文字の本体を後ろから前へ描画（レガシータイトル互換：個別キャンバスに描画）
                for (let charIdx = charPositions.length - 1; charIdx >= 0; charIdx--) {
                    const { c, dc, fs, charW, px } = charPositions[charIdx];

                    ctx.save();
                    const fontWeight = c.bold !== false ? 'bold' : 'normal';
                    const fontStyle = c.italic ? 'italic' : 'normal';
                    ctx.font = `${fontStyle} ${fontWeight} ${fs}px "${c.fontFamily}"`;
                    ctx.textBaseline = 'middle';
                    ctx.textAlign = 'left';

                    // レガシータイトル互換：各文字を一時キャンバスに描画して配置
                    if (c.fillType !== 'none') {
                        // 一時キャンバスを作成
                        const margin = 20;
                        const metrics = ctx.measureText(dc);
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = Math.ceil(metrics.width + margin * 2);
                        tempCanvas.height = Math.ceil(fs * 2 + margin * 2);
                        const tempCtx = tempCanvas.getContext('2d');

                        // フォント設定をコピー
                        tempCtx.font = ctx.font;
                        tempCtx.textBaseline = 'middle';
                        tempCtx.textAlign = 'left';

                        const tempX = margin;
                        const tempY = tempCanvas.height / 2;

                        // 文字を一時キャンバスに描画
                        tempCtx.fillStyle = c.color || '#ffffff';
                        tempCtx.globalAlpha = 1.0;
                        tempCtx.fillText(dc, tempX, tempY);

                        // メインキャンバスに配置
                        ctx.globalAlpha = (obj.opacity || 100) / 100 * (c.opacity || 100) / 100;
                        ctx.drawImage(tempCanvas, px - tempX, ly - tempY);
                    }

                    ctx.restore();
                }
            });
        }

        function drawNameTag(ctx, obj, bounds) {
            const nt = obj.nameTag;
            if (!nt || !nt.enabled || !nt.text) return;

            const fontSize = nt.size || 36;
            const fontFamily = nt.font || 'Yu Gothic UI';
            const padX = nt.padX || 10;
            const padY = nt.padY || 5;
            const gap = nt.gap || 10;
            const isVertical = obj.vertical || false;  // 親オブジェクトが縦書きかどうか

            ctx.save();
            ctx.font = `bold ${fontSize}px "${fontFamily}"`;

            let textWidth, textHeight, bgW, bgH;

            if (isVertical) {
                // 縦書き: 幅は1文字分、高さは文字数×フォントサイズ
                textWidth = fontSize;
                textHeight = nt.text.length * fontSize * 1.1;
                bgW = textWidth + padX * 2;
                bgH = textHeight + padY * 2;
            } else {
                // 横書き
                textWidth = ctx.measureText(nt.text).width;
                textHeight = fontSize;
                bgW = textWidth + padX * 2;
                bgH = textHeight + padY * 2;
            }

            // Calculate position based on position setting
            let nx, ny;
            const pos = nt.position || 'top-left';

            if (isVertical) {
                // 縦書きの場合の位置計算
                if (pos.includes('left')) {
                    nx = bounds.x - gap - bgW;
                } else if (pos.includes('right')) {
                    nx = bounds.x + bounds.w + gap;
                } else {
                    nx = bounds.x + (bounds.w - bgW) / 2;
                }

                if (pos.includes('top')) {
                    ny = bounds.y;
                } else if (pos.includes('bottom')) {
                    ny = bounds.y + bounds.h - bgH;
                } else {
                    ny = bounds.y + (bounds.h - bgH) / 2;
                }
            } else {
                // 横書きの場合の位置計算
                if (pos.includes('left')) {
                    nx = bounds.x;
                } else if (pos.includes('right')) {
                    nx = bounds.x + bounds.w - bgW;
                } else {
                    nx = bounds.x + (bounds.w - bgW) / 2;
                }

                if (pos.includes('top')) {
                    ny = bounds.y - gap - bgH;
                } else {
                    ny = bounds.y + bounds.h + gap;
                }
            }

            // Draw background
            if (nt.bgEnabled) {
                ctx.globalAlpha = (nt.bgOpacity || 100) / 100;

                let radius = nt.bgRadius || 5;
                if (nt.bgShape === 'pill') {
                    radius = Math.min(bgW, bgH) / 2;
                } else if (nt.bgShape === 'rect') {
                    radius = 0;
                }

                drawRoundedRect(ctx, nx, ny, bgW, bgH, radius);
                ctx.fillStyle = nt.bgColor || '#0066cc';
                ctx.fill();

                // Background stroke
                if (nt.strokeEnabled) {
                    ctx.strokeStyle = nt.strokeColor || '#ffffff';
                    ctx.lineWidth = nt.strokeWidth || 2;
                    ctx.stroke();
                }
            }

            // Draw text
            ctx.globalAlpha = 1;
            ctx.fillStyle = nt.color || '#ffffff';

            if (isVertical) {
                // 縦書きテキスト描画
                ctx.textBaseline = 'middle';
                ctx.textAlign = 'center';
                const chars = nt.text.split('');
                const charHeight = fontSize * 1.1;
                const startY = ny + padY + charHeight / 2;
                const centerX = nx + bgW / 2;

                chars.forEach((char, i) => {
                    ctx.fillText(char, centerX, startY + i * charHeight);
                });
            } else {
                // 横書きテキスト描画
                ctx.textBaseline = 'top';
                ctx.fillText(nt.text, nx + padX, ny + padY);
            }

            ctx.restore();
        }

        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 背景描画
            drawBackground(ctx);

            textObjects.forEach(obj => {
                ctx.save();

                // アニメーションプロパティを取得
                const animProps = getAnimatedProperties(obj);
                const animX = animProps.x;
                const animY = animProps.y;
                const animOpacity = animProps.opacity;
                const visibleChars = animProps.visibleChars;
                const charAnimations = animProps.charAnimations;

                // 一時的に位置と不透明度を変更
                const origX = obj.x, origY = obj.y;
                obj.x = animX;
                obj.y = animY;

                ctx.globalAlpha = animOpacity / 100;
                if (obj.rotation) { ctx.translate(obj.x, obj.y); ctx.rotate(obj.rotation * Math.PI / 180); ctx.translate(-obj.x, -obj.y); }

                // タイプライター効果と文字アニメーション用に保存
                obj._visibleChars = visibleChars;
                obj._charAnimations = charAnimations;

                // キーフレーム補間を適用
                const kfProps = interpolateKeyframes(obj);
                if (kfProps) {
                    obj._keyframeProps = kfProps;
                } else {
                    obj._keyframeProps = null;
                }

                // グループオブジェクトの描画
                if (obj.type === 'group' && obj.children) {
                    ctx.save();
                    // グループの子オブジェクトを描画
                    obj.children.forEach(child => {
                        const absChild = {
                            ...child,
                            x: child.x + obj.x,
                            y: child.y + obj.y
                        };
                        ctx.save();
                        ctx.globalAlpha = (obj.opacity || 100) / 100 * (child.opacity || 100) / 100;
                        if (child.rotation) {
                            ctx.translate(absChild.x, absChild.y);
                            ctx.rotate(child.rotation * Math.PI / 180);
                            ctx.translate(-absChild.x, -absChild.y);
                        }
                        // 子オブジェクトのタイプに応じて描画
                        if (['rect', 'roundRect', 'ellipse', 'triangle', 'line', 'chamferRect', 'arc'].includes(child.type)) {
                            drawShape(ctx, absChild);
                        } else if (child.type === 'penPath' && child.path) {
                            // ペンパスの描画（簡易版）
                            const absPath = child.path.map(p => ({
                                x: p.x + absChild.x,
                                y: p.y + absChild.y,
                                cp1: p.cp1 ? { x: p.cp1.x + absChild.x, y: p.cp1.y + absChild.y } : null,
                                cp2: p.cp2 ? { x: p.cp2.x + absChild.x, y: p.cp2.y + absChild.y } : null
                            }));
                            ctx.beginPath();
                            ctx.moveTo(absPath[0].x, absPath[0].y);
                            for (let i = 1; i < absPath.length; i++) {
                                const prev = absPath[i - 1];
                                const curr = absPath[i];
                                if (prev.cp2 || curr.cp1) {
                                    const cp1 = prev.cp2 || { x: prev.x, y: prev.y };
                                    const cp2 = curr.cp1 || { x: curr.x, y: curr.y };
                                    ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, curr.x, curr.y);
                                } else {
                                    ctx.lineTo(curr.x, curr.y);
                                }
                            }
                            if (child.closed) ctx.closePath();
                            if (child.fillType !== 'none') {
                                ctx.fillStyle = child.fill || '#ffffff';
                                ctx.fill();
                            }
                            ctx.strokeStyle = child.stroke || '#ffffff';
                            ctx.lineWidth = child.strokeWidth || 3;
                            ctx.stroke();
                        } else if (child.chars) {
                            // テキストオブジェクトの描画
                            drawTextObject(ctx, absChild);
                        }
                        ctx.restore();
                    });
                    ctx.restore();

                    // グループの選択枠
                    if (selectedObjIds.includes(obj.id)) {
                        const hw = obj.width / 2, hh = obj.height / 2;
                        ctx.strokeStyle = '#0066cc'; ctx.lineWidth = 2; ctx.setLineDash([5, 3]);
                        ctx.strokeRect(obj.x - hw - 5, obj.y - hh - 5, obj.width + 10, obj.height + 10);
                        ctx.setLineDash([]);
                        const handles = [
                            { x: obj.x - hw, y: obj.y - hh }, { x: obj.x, y: obj.y - hh }, { x: obj.x + hw, y: obj.y - hh },
                            { x: obj.x + hw, y: obj.y }, { x: obj.x + hw, y: obj.y + hh },
                            { x: obj.x, y: obj.y + hh }, { x: obj.x - hw, y: obj.y + hh }, { x: obj.x - hw, y: obj.y }
                        ];
                        ctx.fillStyle = '#fff'; ctx.strokeStyle = '#0066cc'; ctx.lineWidth = 1;
                        handles.forEach(h => { ctx.fillRect(h.x - 4, h.y - 4, 8, 8); ctx.strokeRect(h.x - 4, h.y - 4, 8, 8); });
                    }
                    ctx.restore();
                    // アニメーション位置を復元
                    obj.x = origX;
                    obj.y = origY;
                    return;
                }

                // 画像オブジェクトの描画
                if (obj.type === 'image') {
                    drawImageObject(ctx, obj);
                    ctx.restore();

                    // 選択枠
                    if (selectedObjIds.includes(obj.id)) {
                        const bounds = getObjectBounds(obj);
                        ctx.strokeStyle = '#0066cc'; ctx.lineWidth = 2; ctx.setLineDash([5, 3]);
                        ctx.strokeRect(bounds.x - 5, bounds.y - 5, bounds.w + 10, bounds.h + 10);
                        ctx.setLineDash([]);
                        const handles = [
                            { x: bounds.x, y: bounds.y }, { x: bounds.x + bounds.w / 2, y: bounds.y }, { x: bounds.x + bounds.w, y: bounds.y },
                            { x: bounds.x + bounds.w, y: bounds.y + bounds.h / 2 }, { x: bounds.x + bounds.w, y: bounds.y + bounds.h },
                            { x: bounds.x + bounds.w / 2, y: bounds.y + bounds.h }, { x: bounds.x, y: bounds.y + bounds.h }, { x: bounds.x, y: bounds.y + bounds.h / 2 }
                        ];
                        ctx.fillStyle = '#fff'; ctx.strokeStyle = '#0066cc'; ctx.lineWidth = 1;
                        handles.forEach(h => { ctx.fillRect(h.x - 4, h.y - 4, 8, 8); ctx.strokeRect(h.x - 4, h.y - 4, 8, 8); });
                    }
                    // アニメーション位置を復元
                    obj.x = origX;
                    obj.y = origY;
                    return;
                }

                // 図形オブジェクトの描画
                if (['rect', 'roundRect', 'ellipse', 'triangle', 'line', 'chamferRect', 'arc'].includes(obj.type)) {
                    drawShape(ctx, obj);
                    ctx.restore();

                    // 選択枠
                    if (selectedObjIds.includes(obj.id)) {
                        const hw = obj.width / 2, hh = obj.height / 2;
                        ctx.strokeStyle = '#0066cc'; ctx.lineWidth = 2; ctx.setLineDash([5, 3]);
                        ctx.strokeRect(obj.x - hw - 5, obj.y - hh - 5, obj.width + 10, obj.height + 10);
                        ctx.setLineDash([]);
                        const handles = [
                            { x: obj.x - hw, y: obj.y - hh }, { x: obj.x, y: obj.y - hh }, { x: obj.x + hw, y: obj.y - hh },
                            { x: obj.x + hw, y: obj.y }, { x: obj.x + hw, y: obj.y + hh },
                            { x: obj.x, y: obj.y + hh }, { x: obj.x - hw, y: obj.y + hh }, { x: obj.x - hw, y: obj.y }
                        ];
                        ctx.fillStyle = '#fff'; ctx.strokeStyle = '#0066cc'; ctx.lineWidth = 1;
                        handles.forEach(h => { ctx.fillRect(h.x - 4, h.y - 4, 8, 8); ctx.strokeRect(h.x - 4, h.y - 4, 8, 8); });
                    }
                    // アニメーション位置を復元
                    obj.x = origX;
                    obj.y = origY;
                    return;
                }

                // パス上文字オブジェクトの描画
                if (obj.type === 'pathText' && obj.path && obj.chars) {
                    // Convert relative path points to absolute
                    const absPath = obj.path.map(p => ({ x: p.x + obj.x, y: p.y + obj.y }));
                    const pathLen = getPathLength(absPath);

                    // Draw path line (faded)
                    if (selectedObjIds.includes(obj.id)) {
                        ctx.save();
                        ctx.strokeStyle = 'rgba(0, 120, 212, 0.3)';
                        ctx.lineWidth = 2;
                        ctx.setLineDash([5, 5]);
                        ctx.beginPath();
                        ctx.moveTo(absPath[0].x, absPath[0].y);
                        for (let i = 1; i < absPath.length; i++) {
                            ctx.lineTo(absPath[i].x, absPath[i].y);
                        }
                        ctx.stroke();
                        ctx.setLineDash([]);
                        ctx.restore();
                    }

                    // Calculate total text length along path
                    let totalTextLen = 0;
                    if (obj.vertical) {
                        // 縦書き: 文字の高さ（フォントサイズ）で計算
                        obj.chars.forEach(c => { totalTextLen += c.fontSize * 1.1; });
                    } else {
                        // 横書き: 文字の幅で計算
                        obj.chars.forEach(c => { totalTextLen += getCharWidth(c); });
                    }

                    // Start position along path (center text by default)
                    let dist = (pathLen - totalTextLen) / 2 + (obj.pathOffset || 0);

                    // レガシータイトル互換：各文字の位置とパラメータを事前計算
                    const pathCharData = [];
                    obj.chars.forEach(c => {
                        let charLen;
                        if (obj.vertical) {
                            charLen = c.fontSize * 1.1;
                        } else {
                            charLen = getCharWidth(c);
                        }
                        const pos = getPointAtDistance(absPath, dist + charLen / 2);
                        const dc = c.smallCaps && /[a-z]/.test(c.char) ? c.char.toUpperCase() : c.char;
                        const fs = c.smallCaps && /[a-z]/.test(c.char) ? c.fontSize * (c.smallCapsSize || 70) / 100 : c.fontSize;

                        pathCharData.push({ c, dc, fs, charLen, pos });
                        dist += charLen;
                    });

                    // 第1パス：すべての文字のストロークを後ろから前へ描画
                    for (let charIdx = pathCharData.length - 1; charIdx >= 0; charIdx--) {
                        const { c, dc, fs, charLen, pos } = pathCharData[charIdx];

                        ctx.save();
                        const fontWeight = c.bold !== false ? 'bold' : 'normal';
                        const fontStyle = c.italic ? 'italic' : 'normal';
                        ctx.font = `${fontStyle} ${fontWeight} ${fs}px "${c.fontFamily}"`;
                        ctx.textBaseline = 'middle';
                        ctx.textAlign = 'center';
                        ctx.globalAlpha = (obj.opacity || 100) / 100 * (c.opacity || 100) / 100;

                        ctx.translate(pos.x, pos.y);

                        if (obj.vertical) {
                            // 縦書き: パスに沿って文字を直立させ、90度回転
                            ctx.rotate(pos.angle + Math.PI / 2);
                        } else {
                            // 横書き: パスの方向に沿って回転
                            ctx.rotate(pos.angle);
                        }

                        // Strokes（累積方式：外側から内側へ描画）
                        const strokes = c.strokes || [{ enabled: true, type: 'edge', color: '#000', width: 4, opacity: 100 }];
                        const enabledStrokes = strokes.filter(st => st.enabled);
                        for (let i = enabledStrokes.length - 1; i >= 0; i--) {
                            const st = enabledStrokes[i];
                            // 内側のストロークの累積幅
                            let innerWidth = 0;
                            for (let j = 0; j < i; j++) {
                                innerWidth += enabledStrokes[j].width;
                            }
                            let cumulativeWidth = innerWidth + st.width;
                            ctx.save();
                            ctx.globalAlpha = (obj.opacity || 100) / 100 * (c.opacity || 100) / 100 * (st.opacity || 100) / 100;
                            ctx.strokeStyle = st.color;
                            ctx.lineJoin = st.join || 'round';

                            if (st.type === 'depth') {
                                const depthAngle = (st.angle || 45) * Math.PI / 180;
                                const depthDx = Math.cos(depthAngle);
                                const depthDy = Math.sin(depthAngle);
                                for (let d = st.width; d > 0; d -= 0.5) {
                                    ctx.lineWidth = innerWidth + d;
                                    ctx.save();
                                    ctx.translate((innerWidth + d) * depthDx, (innerWidth + d) * depthDy);
                                    ctx.strokeText(dc, 0, 0);
                                    ctx.restore();
                                }
                            } else if (st.type === 'drop') {
                                ctx.save();
                                ctx.translate(innerWidth + st.width, innerWidth + st.width);
                                ctx.fillStyle = st.color;
                                ctx.fillText(dc, 0, 0);
                                ctx.restore();
                            } else {
                                // エッジタイプ：内側の全ストローク＋文字本体の形状全体を均等に囲む
                                // マージンを大きくして隣の文字への干渉を減らす
                                const totalStrokeWidth = enabledStrokes.reduce((sum, s) => sum + s.width, 0);
                                const margin = Math.max(st.width * 6, totalStrokeWidth * 3);
                                const tempCanvas = document.createElement('canvas');
                                const metrics = ctx.measureText(dc);
                                tempCanvas.width = Math.ceil(metrics.width + fs + margin * 4);
                                tempCanvas.height = Math.ceil(fs * 3 + margin * 4);
                                const tempCtx = tempCanvas.getContext('2d');

                                // フォント設定をコピー
                                tempCtx.font = ctx.font;
                                tempCtx.textBaseline = ctx.textBaseline;
                                tempCtx.textAlign = ctx.textAlign;

                                const tempX = tempCanvas.width / 2;
                                const tempY = tempCanvas.height / 2;

                                // 内側の全ストロークを一時キャンバスに描画
                                for (let j = i - 1; j >= 0; j--) {
                                    const innerSt = enabledStrokes[j];
                                    let innerInnerWidth = 0;
                                    for (let k = 0; k < j; k++) {
                                        innerInnerWidth += enabledStrokes[k].width;
                                    }

                                    if (innerSt.type === 'depth') {
                                        const depthAngle = (innerSt.angle || 45) * Math.PI / 180;
                                        const depthDx = Math.cos(depthAngle);
                                        const depthDy = Math.sin(depthAngle);
                                        for (let d = innerSt.width; d > 0; d -= 0.5) {
                                            tempCtx.lineWidth = innerInnerWidth + d;
                                            tempCtx.strokeStyle = innerSt.color;
                                            tempCtx.globalAlpha = (innerSt.opacity || 100) / 100;
                                            tempCtx.save();
                                            tempCtx.translate((innerInnerWidth + d) * depthDx, (innerInnerWidth + d) * depthDy);
                                            tempCtx.strokeText(dc, tempX, tempY);
                                            tempCtx.restore();
                                        }
                                    } else if (innerSt.type === 'drop') {
                                        tempCtx.save();
                                        tempCtx.translate(innerInnerWidth + innerSt.width, innerInnerWidth + innerSt.width);
                                        tempCtx.fillStyle = innerSt.color;
                                        tempCtx.globalAlpha = (innerSt.opacity || 100) / 100;
                                        tempCtx.fillText(dc, tempX, tempY);
                                        tempCtx.restore();
                                    } else {
                                        // 内側のエッジ（通常描画）
                                        tempCtx.lineWidth = innerInnerWidth + innerSt.width;
                                        tempCtx.strokeStyle = innerSt.color;
                                        tempCtx.globalAlpha = (innerSt.opacity || 100) / 100;
                                        tempCtx.strokeText(dc, tempX, tempY);
                                    }
                                }

                                // 文字本体を一時キャンバスに描画
                                if (c.fillType !== 'none') {
                                    tempCtx.fillStyle = c.color;
                                    tempCtx.globalAlpha = 1.0;
                                    tempCtx.fillText(dc, tempX, tempY);
                                }

                                // エッジキャンバスを作成：一時キャンバスの内容を膨張させる
                                const edgeCanvas = document.createElement('canvas');
                                edgeCanvas.width = tempCanvas.width;
                                edgeCanvas.height = tempCanvas.height;
                                const edgeCtx = edgeCanvas.getContext('2d');

                                // st.joinに応じたエッジ描画アルゴリズム
                                const edgeSteps = Math.max(1, st.width);
                                const joinType = st.join || 'round';
                                const blurEnabled = st.blur || false;
                                const blurAmount = st.blurAmount || 0;

                                if (joinType === 'miter') {
                                    // 角(miter): 正方形膨張（上下左右＋対角を同じ距離で）
                                    for (let step = 1; step <= edgeSteps; step += 1) {
                                        edgeCtx.globalAlpha = 1.0;
                                        // 上下左右
                                        edgeCtx.drawImage(tempCanvas, step, 0);
                                        edgeCtx.drawImage(tempCanvas, -step, 0);
                                        edgeCtx.drawImage(tempCanvas, 0, step);
                                        edgeCtx.drawImage(tempCanvas, 0, -step);
                                        // 対角（正方形の角を埋める）
                                        edgeCtx.drawImage(tempCanvas, step, step);
                                        edgeCtx.drawImage(tempCanvas, step, -step);
                                        edgeCtx.drawImage(tempCanvas, -step, step);
                                        edgeCtx.drawImage(tempCanvas, -step, -step);
                                    }
                                } else if (joinType === 'bevel') {
                                    // 面取り(bevel): 8方向
                                    const bevelStep = Math.PI / 4;
                                    for (let step = 1; step <= edgeSteps; step += 1) {
                                        edgeCtx.globalAlpha = 1.0;
                                        for (let angle = 0; angle < Math.PI * 2; angle += bevelStep) {
                                            const dx = Math.cos(angle) * step;
                                            const dy = Math.sin(angle) * step;
                                            edgeCtx.drawImage(tempCanvas, dx, dy);
                                        }
                                    }
                                } else {
                                    // 丸み(round): 64方向で滑らかなエッジ
                                    const roundStep = Math.PI / 32;
                                    for (let step = 0.5; step <= edgeSteps; step += 0.5) {
                                        edgeCtx.globalAlpha = 1.0;
                                        for (let angle = 0; angle < Math.PI * 2; angle += roundStep) {
                                            const dx = Math.cos(angle) * step;
                                            const dy = Math.sin(angle) * step;
                                            edgeCtx.drawImage(tempCanvas, dx, dy);
                                        }
                                    }
                                }

                                // 元の内容を引いてエッジ部分のみを残す
                                edgeCtx.globalCompositeOperation = 'destination-out';
                                edgeCtx.globalAlpha = 1.0;
                                edgeCtx.drawImage(tempCanvas, 0, 0);

                                // エッジに色を適用
                                edgeCtx.globalCompositeOperation = 'source-in';
                                edgeCtx.fillStyle = st.color;
                                edgeCtx.fillRect(0, 0, edgeCanvas.width, edgeCanvas.height);

                                // グラデーションぼかし（内側から外側へ）
                                if (blurEnabled && blurAmount > 0) {
                                    const blurCanvas = document.createElement('canvas');
                                    blurCanvas.width = edgeCanvas.width;
                                    blurCanvas.height = edgeCanvas.height;
                                    const blurCtx = blurCanvas.getContext('2d');
                                    blurCtx.filter = `blur(${blurAmount}px)`;
                                    blurCtx.drawImage(edgeCanvas, 0, 0);
                                    edgeCtx.globalCompositeOperation = 'source-over';
                                    edgeCtx.clearRect(0, 0, edgeCanvas.width, edgeCanvas.height);
                                    edgeCtx.drawImage(blurCanvas, 0, 0);
                                }

                                // メインキャンバスに描画
                                ctx.globalAlpha = (obj.opacity || 100) / 100 * (c.opacity || 100) / 100 * (st.opacity || 100) / 100;
                                ctx.drawImage(edgeCanvas, -tempX, -tempY);
                            }
                            ctx.restore();
                        }

                        ctx.restore();
                    }

                    // 第2パス：すべての文字の本体を後ろから前へ描画
                    for (let charIdx = pathCharData.length - 1; charIdx >= 0; charIdx--) {
                        const { c, dc, fs, charLen, pos } = pathCharData[charIdx];

                        ctx.save();
                        const fontWeight = c.bold !== false ? 'bold' : 'normal';
                        const fontStyle = c.italic ? 'italic' : 'normal';
                        ctx.font = `${fontStyle} ${fontWeight} ${fs}px "${c.fontFamily}"`;
                        ctx.textBaseline = 'middle';
                        ctx.textAlign = 'center';

                        ctx.translate(pos.x, pos.y);

                        if (obj.vertical) {
                            ctx.rotate(pos.angle + Math.PI / 2);
                        } else {
                            ctx.rotate(pos.angle);
                        }

                        // Fill
                        if (c.fillType !== 'none') {
                            ctx.globalAlpha = (obj.opacity || 100) / 100 * (c.opacity || 100) / 100;
                            ctx.fillStyle = c.color;
                            ctx.fillText(dc, 0, 0);
                        }

                        ctx.restore();
                    }

                    // Selection highlight for pathText
                    if (obj.id === editingObjId && selectedCharStart !== -1 && selectedCharStart !== selectedCharEnd) {
                        const s = Math.min(selectedCharStart, selectedCharEnd);
                        const en = Math.max(selectedCharStart, selectedCharEnd);
                        let hlDist = (pathLen - totalTextLen) / 2 + (obj.pathOffset || 0);

                        for (let i = 0; i < obj.chars.length; i++) {
                            const charLen = obj.vertical ? obj.chars[i].fontSize * 1.1 : getCharWidth(obj.chars[i]);
                            if (i >= s && i < en) {
                                const pos = getPointAtDistance(absPath, hlDist + charLen / 2);
                                ctx.save();
                                ctx.fillStyle = 'rgba(0,120,212,0.3)';
                                ctx.beginPath();
                                ctx.arc(pos.x, pos.y, obj.chars[i].fontSize / 2, 0, Math.PI * 2);
                                ctx.fill();
                                ctx.restore();
                            }
                            hlDist += charLen;
                        }
                    }

                    // Cursor for pathText
                    if (obj.id === editingObjId && cursorVisible && selectedCharStart === -1) {
                        let cDist = (pathLen - totalTextLen) / 2 + (obj.pathOffset || 0);
                        for (let i = 0; i < cursorPos && i < obj.chars.length; i++) {
                            cDist += obj.vertical ? obj.chars[i].fontSize * 1.1 : getCharWidth(obj.chars[i]);
                        }
                        const cPos = getPointAtDistance(absPath, cDist);
                        const maxFs = Math.max(...obj.chars.map(c => c.fontSize), 72);

                        ctx.save();
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 2;
                        ctx.translate(cPos.x, cPos.y);
                        ctx.rotate(cPos.angle + (obj.vertical ? Math.PI / 2 : 0));
                        ctx.beginPath();
                        ctx.moveTo(0, -maxFs / 2);
                        ctx.lineTo(0, maxFs / 2);
                        ctx.stroke();
                        ctx.restore();
                    }

                    // Selection box
                    if (obj.id === selectedObjId && obj.id !== editingObjId) {
                        const xs = absPath.map(p => p.x), ys = absPath.map(p => p.y);
                        const minX = Math.min(...xs), maxX = Math.max(...xs);
                        const minY = Math.min(...ys), maxY = Math.max(...ys);
                        const maxFs = Math.max(...obj.chars.map(c => c.fontSize));
                        ctx.strokeStyle = '#0066cc'; ctx.lineWidth = 2; ctx.setLineDash([5, 3]);
                        ctx.strokeRect(minX - maxFs/2 - 5, minY - maxFs/2 - 5, maxX - minX + maxFs + 10, maxY - minY + maxFs + 10);
                        ctx.setLineDash([]);
                    }

                    ctx.restore();
                    // アニメーション位置を復元
                    obj.x = origX;
                    obj.y = origY;
                    return;
                }

                // ペンパスオブジェクトの描画
                if (obj.type === 'penPath' && obj.path) {
                    const absPath = obj.path.map(p => ({
                        x: p.x + obj.x,
                        y: p.y + obj.y,
                        cp1: p.cp1 ? { x: p.cp1.x + obj.x, y: p.cp1.y + obj.y } : null,
                        cp2: p.cp2 ? { x: p.cp2.x + obj.x, y: p.cp2.y + obj.y } : null
                    }));

                    ctx.beginPath();
                    ctx.moveTo(absPath[0].x, absPath[0].y);
                    for (let i = 1; i < absPath.length; i++) {
                        const prev = absPath[i - 1];
                        const curr = absPath[i];
                        // ベジェ曲線または直線を描画
                        if (prev.cp2 || curr.cp1) {
                            const cp1 = prev.cp2 || { x: prev.x, y: prev.y };
                            const cp2 = curr.cp1 || { x: curr.x, y: curr.y };
                            ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, curr.x, curr.y);
                        } else {
                            ctx.lineTo(curr.x, curr.y);
                        }
                    }
                    if (obj.closed) ctx.closePath();

                    // Fill
                    if (obj.fillType !== 'none') {
                        ctx.globalAlpha = (obj.opacity || 100) / 100 * (obj.fillOpacity || 100) / 100;
                        ctx.fillStyle = obj.fill || '#ffffff';
                        ctx.fill();
                    }

                    // Stroke
                    ctx.globalAlpha = (obj.opacity || 100) / 100 * (obj.strokeOpacity || 100) / 100;
                    ctx.strokeStyle = obj.stroke || '#ffffff';
                    ctx.lineWidth = obj.strokeWidth || 3;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.stroke();

                    // Selection box and control points
                    if (selectedObjIds.includes(obj.id)) {
                        const bounds = getObjectBounds(obj);
                        ctx.strokeStyle = '#0066cc'; ctx.lineWidth = 2; ctx.setLineDash([5, 3]);
                        ctx.strokeRect(bounds.x - 5, bounds.y - 5, bounds.w + 10, bounds.h + 10);
                        ctx.setLineDash([]);

                        // Draw control point handles for editing
                        ctx.globalAlpha = 1;
                        absPath.forEach((p, i) => {
                            // Draw anchor point
                            ctx.fillStyle = '#0066cc';
                            ctx.beginPath();
                            ctx.rect(p.x - 4, p.y - 4, 8, 8);
                            ctx.fill();

                            // Draw control point handles
                            if (p.cp1) {
                                ctx.strokeStyle = '#ff6600';
                                ctx.lineWidth = 1;
                                ctx.beginPath();
                                ctx.moveTo(p.x, p.y);
                                ctx.lineTo(p.cp1.x, p.cp1.y);
                                ctx.stroke();
                                ctx.fillStyle = '#ff6600';
                                ctx.beginPath();
                                ctx.arc(p.cp1.x, p.cp1.y, 3, 0, Math.PI * 2);
                                ctx.fill();
                            }
                            if (p.cp2) {
                                ctx.strokeStyle = '#ff6600';
                                ctx.lineWidth = 1;
                                ctx.beginPath();
                                ctx.moveTo(p.x, p.y);
                                ctx.lineTo(p.cp2.x, p.cp2.y);
                                ctx.stroke();
                                ctx.fillStyle = '#ff6600';
                                ctx.beginPath();
                                ctx.arc(p.cp2.x, p.cp2.y, 3, 0, Math.PI * 2);
                                ctx.fill();
                            }
                        });
                    }

                    ctx.restore();
                    // アニメーション位置を復元
                    obj.x = origX;
                    obj.y = origY;
                    return;
                }

                // テキストオブジェクトの描画
                if (!obj.chars) {
                    ctx.restore();
                    // アニメーション位置を復元
                    obj.x = origX;
                    obj.y = origY;
                    return;
                }

                // 縦書きテキストの場合
                if (obj.vertical) {
                    const lines = getLines(obj);
                    const colWidth = getVerticalLineWidth(obj) * (obj.lineHeight || 1.2);
                    const totalWidth = lines.length * colWidth;

                    // 開始X位置（右から左へ描画）
                    let startX = obj.x;
                    if (obj.textAlign === 'center') startX = obj.x + totalWidth / 2 - colWidth / 2;
                    else if (obj.textAlign === 'left') startX = obj.x + totalWidth - colWidth;

                    // Get bounds for balloon and name tag
                    const bounds = getObjectBounds(obj);
                    drawBalloon(ctx, obj, bounds);

                    let ci = 0;
                    const maxVisibleChars = obj._visibleChars !== undefined ? obj._visibleChars : Infinity;
                    let totalCharIndex = 0;
                    for (let li = 0; li < lines.length; li++) {
                        const line = lines[li];
                        const colX = startX - li * colWidth;
                        const lineH = getVerticalLineHeight(line);

                        // 開始Y位置（縦揃え）
                        let startY = obj.y;
                        if (obj.verticalAlign === 'top') startY = obj.y;
                        else if (obj.verticalAlign === 'bottom') startY = obj.y - lineH;
                        else startY = obj.y - lineH / 2;

                        // Selection highlight for vertical text
                        if (obj.id === editingObjId && selectedCharStart !== -1 && selectedCharStart !== selectedCharEnd) {
                            const s = Math.min(selectedCharStart, selectedCharEnd), en = Math.max(selectedCharStart, selectedCharEnd);
                            let hlY = startY, hlSY = null, hlH = 0;
                            for (let i = 0; i < line.length; i++) {
                                const gi = ci + i, h = getCharHeight(line[i]);
                                if (gi >= s && gi < en) { if (hlSY === null) hlSY = hlY; hlH += h; }
                                hlY += h;
                            }
                            if (hlSY !== null && hlH > 0) {
                                ctx.fillStyle = 'rgba(0,120,212,0.3)';
                                ctx.fillRect(colX - colWidth / 2, hlSY, colWidth, hlH);
                            }
                        }

                        // Draw characters vertically
                        let py = startY;
                        line.forEach(c => {
                            // タイプライター効果: visibleCharsを超えた文字はスキップ
                            if (totalCharIndex >= maxVisibleChars) {
                                py += getCharHeight(c);
                                totalCharIndex++;
                                return;
                            }
                            const charIdx = totalCharIndex;
                            totalCharIndex++;

                            // 文字アニメーションを取得
                            const charAnim = obj._charAnimations ? obj._charAnimations[charIdx] : null;
                            if (charAnim && charAnim.opacity === 0) {
                                py += getCharHeight(c);
                                return;
                            }

                            const dc = c.smallCaps && /[a-z]/.test(c.char) ? c.char.toUpperCase() : c.char;
                            const fs = c.smallCaps && /[a-z]/.test(c.char) ? c.fontSize * (c.smallCapsSize || 70) / 100 : c.fontSize;
                            ctx.save();
                            const fontWeight = c.bold !== false ? 'bold' : 'normal';
            const fontStyle = c.italic ? 'italic' : 'normal';
            ctx.font = `${fontStyle} ${fontWeight} ${fs}px "${c.fontFamily}"`;
                            ctx.textBaseline = 'top';
                            ctx.textAlign = 'center';

                            // 文字アニメーションの不透明度を適用
                            let charOpacity = (obj.opacity || 100) / 100 * (c.opacity || 100) / 100;
                            if (charAnim) charOpacity *= charAnim.opacity;
                            ctx.globalAlpha = charOpacity;

                            const bw = ctx.measureText(dc).width;
                            const sx = (c.scaleX || 100) / 100;
                            const cx = colX - (c.baselineShift || 0);

                            // 文字アニメーションのオフセットを適用
                            let animOffsetX = charAnim ? (charAnim.offsetX || 0) : 0;
                            let animOffsetY = charAnim ? (charAnim.offsetY || 0) : 0;

                            ctx.translate(cx + animOffsetX, py + animOffsetY);

                            // 文字アニメーションの回転とスケールを適用
                            if (charAnim) {
                                if (charAnim.rotation) ctx.rotate(charAnim.rotation * Math.PI / 180);
                                if (charAnim.scale && charAnim.scale !== 1) ctx.scale(charAnim.scale, charAnim.scale);
                            }

                            if (c.slant) ctx.transform(1, Math.tan(c.slant * Math.PI / 180), 0, 1, 0, 0);

                            // Shadow
                            if (c.shadowEnabled) {
                                const sa = (c.shadowAngle || 45) * Math.PI / 180;
                                const sd = c.shadowDistance || 5;
                                const sox = Math.cos(sa) * sd, soy = Math.sin(sa) * sd;
                                ctx.save();
                                ctx.scale(1, sx);
                                ctx.translate(sox, soy / sx);
                                ctx.globalAlpha = (obj.opacity || 100) / 100 * (c.opacity || 100) / 100 * (c.shadowOpacity || 50) / 100;
                                ctx.shadowColor = c.shadowColor || '#000';
                                ctx.shadowBlur = c.shadowBlur || 5;
                                ctx.fillStyle = c.shadowColor || '#000';
                                ctx.fillText(dc, 0, 0);
                                ctx.restore();
                            }

                            ctx.scale(1, sx);

                            // Strokes（累積方式：外側から内側へ描画）
                            const strokes = c.strokes || [{ enabled: true, type: 'edge', color: '#000', width: 4, opacity: 100 }];
                            const enabledStrokes = strokes.filter(st => st.enabled);
                            for (let si = enabledStrokes.length - 1; si >= 0; si--) {
                                const st = enabledStrokes[si];
                                // 内側のストロークの累積幅
                                let innerWidth = 0;
                                for (let sj = 0; sj < si; sj++) {
                                    innerWidth += enabledStrokes[sj].width;
                                }
                                let cumulativeWidth = innerWidth + st.width;
                                ctx.save();
                                ctx.globalAlpha = (obj.opacity || 100) / 100 * (c.opacity || 100) / 100 * (st.opacity || 100) / 100;
                                ctx.strokeStyle = st.color;
                                ctx.lineJoin = st.join || 'round';

                                if (st.type === 'depth') {
                                    const depthAngle = (st.angle || 45) * Math.PI / 180;
                                    const depthDx = Math.cos(depthAngle);
                                    const depthDy = Math.sin(depthAngle);
                                    for (let d = st.width; d > 0; d -= 0.5) {
                                        ctx.lineWidth = innerWidth + d;
                                        ctx.save();
                                        ctx.translate((innerWidth + d) * depthDx, (innerWidth + d) * depthDy);
                                        ctx.strokeText(dc, 0, 0);
                                        ctx.restore();
                                    }
                                } else if (st.type === 'drop') {
                                    ctx.save();
                                    ctx.translate(innerWidth + st.width, innerWidth + st.width);
                                    ctx.fillStyle = st.color;
                                    ctx.fillText(dc, 0, 0);
                                    ctx.restore();
                                } else {
                                    // エッジタイプ：内側の全ストローク＋文字本体の形状全体を均等に囲む
                                    const margin = st.width * 4;
                                    const tempCanvas = document.createElement('canvas');
                                    const metrics = ctx.measureText(dc);
                                    tempCanvas.width = Math.ceil(metrics.width + fs + margin * 2);
                                    tempCanvas.height = Math.ceil(fs * 2 + margin * 2);
                                    const tempCtx = tempCanvas.getContext('2d');

                                    // フォント設定をコピー
                                    tempCtx.font = ctx.font;
                                    tempCtx.textBaseline = ctx.textBaseline;
                                    tempCtx.textAlign = ctx.textAlign;

                                    const tempX = tempCanvas.width / 2;
                                    const tempY = tempCanvas.height / 2;

                                    // 内側の全ストロークを一時キャンバスに描画
                                    for (let sj = si - 1; sj >= 0; sj--) {
                                        const innerSt = enabledStrokes[sj];
                                        let innerInnerWidth = 0;
                                        for (let sk = 0; sk < sj; sk++) {
                                            innerInnerWidth += enabledStrokes[sk].width;
                                        }

                                        if (innerSt.type === 'depth') {
                                            const depthAngle = (innerSt.angle || 45) * Math.PI / 180;
                                            const depthDx = Math.cos(depthAngle);
                                            const depthDy = Math.sin(depthAngle);
                                            for (let d = innerSt.width; d > 0; d -= 0.5) {
                                                tempCtx.lineWidth = innerInnerWidth + d;
                                                tempCtx.strokeStyle = innerSt.color;
                                                tempCtx.globalAlpha = (innerSt.opacity || 100) / 100;
                                                tempCtx.save();
                                                tempCtx.translate((innerInnerWidth + d) * depthDx, (innerInnerWidth + d) * depthDy);
                                                tempCtx.strokeText(dc, tempX, tempY);
                                                tempCtx.restore();
                                            }
                                        } else if (innerSt.type === 'drop') {
                                            tempCtx.save();
                                            tempCtx.translate(innerInnerWidth + innerSt.width, innerInnerWidth + innerSt.width);
                                            tempCtx.fillStyle = innerSt.color;
                                            tempCtx.globalAlpha = (innerSt.opacity || 100) / 100;
                                            tempCtx.fillText(dc, tempX, tempY);
                                            tempCtx.restore();
                                        } else {
                                            // 内側のエッジ（通常描画）
                                            tempCtx.lineWidth = innerInnerWidth + innerSt.width;
                                            tempCtx.strokeStyle = innerSt.color;
                                            tempCtx.globalAlpha = (innerSt.opacity || 100) / 100;
                                            tempCtx.strokeText(dc, tempX, tempY);
                                        }
                                    }

                                    // 文字本体を一時キャンバスに描画
                                    if (c.fillType !== 'none') {
                                        tempCtx.fillStyle = c.color;
                                        tempCtx.globalAlpha = 1.0;
                                        tempCtx.fillText(dc, tempX, tempY);
                                    }

                                    // エッジキャンバスを作成：一時キャンバスの内容を膨張させる
                                    const edgeCanvas = document.createElement('canvas');
                                    edgeCanvas.width = tempCanvas.width;
                                    edgeCanvas.height = tempCanvas.height;
                                    const edgeCtx = edgeCanvas.getContext('2d');

                                    // st.joinに応じたエッジ描画アルゴリズム
                                    const edgeSteps = Math.max(1, st.width);
                                    const joinType = st.join || 'round';
                                    const blurEnabled = st.blur || false;
                                    const blurAmount = st.blurAmount || 0;

                                    if (joinType === 'miter') {
                                        // 角(miter): 4方向のみで角張ったエッジ
                                        const miterAngles = [0, Math.PI/2, Math.PI, Math.PI*3/2];
                                        for (let step = 1; step <= edgeSteps; step += 1) {
                                            edgeCtx.globalAlpha = 1.0;
                                            for (const angle of miterAngles) {
                                                const dx = Math.cos(angle) * step;
                                                const dy = Math.sin(angle) * step;
                                                edgeCtx.drawImage(tempCanvas, dx, dy);
                                            }
                                            // 斜め方向も追加（角を埋める）
                                            const diagonalStep = step * Math.SQRT2;
                                            for (let da = Math.PI/4; da < Math.PI*2; da += Math.PI/2) {
                                                const dx = Math.cos(da) * diagonalStep;
                                                const dy = Math.sin(da) * diagonalStep;
                                                edgeCtx.drawImage(tempCanvas, dx, dy);
                                            }
                                        }
                                    } else if (joinType === 'bevel') {
                                        // 面取り(bevel): 8方向
                                        const bevelStep = Math.PI / 4;
                                        for (let step = 1; step <= edgeSteps; step += 1) {
                                            edgeCtx.globalAlpha = 1.0;
                                            for (let angle = 0; angle < Math.PI * 2; angle += bevelStep) {
                                                const dx = Math.cos(angle) * step;
                                                const dy = Math.sin(angle) * step;
                                                edgeCtx.drawImage(tempCanvas, dx, dy);
                                            }
                                        }
                                    } else {
                                        // 丸み(round): 64方向で滑らかなエッジ
                                        const roundStep = Math.PI / 32;
                                        for (let step = 0.5; step <= edgeSteps; step += 0.5) {
                                            edgeCtx.globalAlpha = 1.0;
                                            for (let angle = 0; angle < Math.PI * 2; angle += roundStep) {
                                                const dx = Math.cos(angle) * step;
                                                const dy = Math.sin(angle) * step;
                                                edgeCtx.drawImage(tempCanvas, dx, dy);
                                            }
                                        }
                                    }

                                    // 元の内容を引いてエッジ部分のみを残す
                                    edgeCtx.globalCompositeOperation = 'destination-out';
                                    edgeCtx.globalAlpha = 1.0;
                                    edgeCtx.drawImage(tempCanvas, 0, 0);

                                    // エッジに色を適用
                                    edgeCtx.globalCompositeOperation = 'source-in';
                                    edgeCtx.fillStyle = st.color;
                                    edgeCtx.fillRect(0, 0, edgeCanvas.width, edgeCanvas.height);

                                    // グラデーションぼかし（内側から外側へ）
                                    if (blurEnabled && blurAmount > 0) {
                                        const blurCanvas = document.createElement('canvas');
                                        blurCanvas.width = edgeCanvas.width;
                                        blurCanvas.height = edgeCanvas.height;
                                        const blurCtx = blurCanvas.getContext('2d');
                                        blurCtx.filter = `blur(${blurAmount}px)`;
                                        blurCtx.drawImage(edgeCanvas, 0, 0);
                                        edgeCtx.globalCompositeOperation = 'source-over';
                                        edgeCtx.clearRect(0, 0, edgeCanvas.width, edgeCanvas.height);
                                        edgeCtx.drawImage(blurCanvas, 0, 0);
                                    }

                                    // メインキャンバスに描画
                                    ctx.globalAlpha = (obj.opacity || 100) / 100 * (c.opacity || 100) / 100 * (st.opacity || 100) / 100;
                                    ctx.drawImage(edgeCanvas, -tempX, -tempY);
                                }
                                ctx.restore();
                            }

                            // Fill
                            if (c.fillType !== 'none') {
                                if (c.fillType === 'linear' || c.fillType === 'radial') {
                                    const gh = fs, gw = bw;
                                    let grad;
                                    if (c.fillType === 'linear') {
                                        const a = (c.gradientAngle || 0) * Math.PI / 180;
                                        const dx = Math.cos(a) * gw / 2, dy = Math.sin(a) * gh / 2;
                                        grad = ctx.createLinearGradient(-dx, gh / 2 - dy, dx, gh / 2 + dy);
                                    } else {
                                        grad = ctx.createRadialGradient(0, gh / 2, 0, 0, gh / 2, Math.max(gw, gh) / 2);
                                    }
                                    if (c.gradientStops && c.gradientStops.length >= 2) {
                                        c.gradientStops.forEach((stop, i) => {
                                            const startPos = Math.max(0, stop.pos / 100);
                                            const endPos = Math.min(1, stop.endPos / 100);
                                            if (i === 0) grad.addColorStop(0, stop.color);
                                            else grad.addColorStop(startPos + 0.001, stop.color);
                                            if (i === c.gradientStops.length - 1) grad.addColorStop(1, stop.color);
                                            else grad.addColorStop(endPos - 0.001, stop.color);
                                        });
                                    } else {
                                        grad.addColorStop(0, c.color);
                                        grad.addColorStop(1, c.color2 || '#888');
                                    }
                                    ctx.fillStyle = grad;
                                } else {
                                    ctx.fillStyle = c.color;
                                }
                                ctx.fillText(dc, 0, 0);
                            }

                            ctx.restore();
                            py += getCharHeight(c);
                        });
                        ci += line.length + 1;
                    }

                    // Cursor for vertical text
                    if (obj.id === editingObjId && cursorVisible && selectedCharStart === -1) {
                        let cCol = 0, cIdx = 0, count = 0;
                        for (let li = 0; li < lines.length; li++) {
                            if (cursorPos <= count + lines[li].length) { cCol = li; cIdx = cursorPos - count; break; }
                            count += lines[li].length + 1;
                        }
                        const line = lines[cCol] || [];
                        const colX = startX - cCol * colWidth;
                        const lineH = getVerticalLineHeight(line);

                        let cStartY = obj.y;
                        if (obj.verticalAlign === 'top') cStartY = obj.y;
                        else if (obj.verticalAlign === 'bottom') cStartY = obj.y - lineH;
                        else cStartY = obj.y - lineH / 2;

                        let cY = cStartY;
                        for (let i = 0; i < cIdx; i++) cY += getCharHeight(line[i]);

                        ctx.strokeStyle = '#fff'; ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(colX - colWidth / 2, cY);
                        ctx.lineTo(colX + colWidth / 2, cY);
                        ctx.stroke();
                    }

                    // Selection box for vertical text
                    if (obj.id === selectedObjId && obj.id !== editingObjId) {
                        const b = bounds;
                        ctx.strokeStyle = '#0066cc'; ctx.lineWidth = 2; ctx.setLineDash([5, 3]);
                        ctx.strokeRect(b.x - 5, b.y - 5, b.w + 10, b.h + 10);
                        ctx.setLineDash([]);
                    }

                    drawNameTag(ctx, obj, bounds);
                    ctx.restore();
                    return;
                }

                // 横書きテキストの描画
                const lines = getLines(obj), blh = getLineHeight(obj), lh = blh * (obj.lineHeight || 1.2), th = lines.length * lh;
                let startY = obj.y;
                if (obj.verticalAlign === 'top') startY = obj.y;
                else if (obj.verticalAlign === 'bottom') startY = obj.y - th + lh;
                else startY = obj.y - th / 2 + lh / 2;

                // Get bounds for balloon and name tag
                const bounds = getObjectBounds(obj);

                // Draw balloon (behind text)
                drawBalloon(ctx, obj, bounds);

                let ci = 0;
                const maxVisibleChars = obj._visibleChars !== undefined ? obj._visibleChars : Infinity;
                let totalCharIndex = 0;
                for (let li = 0; li < lines.length; li++) {
                    const line = lines[li], lineY = startY + li * lh, lw = getLineWidth(line);
                    let lx = obj.x;
                    if (obj.textAlign === 'center') lx = obj.x - lw / 2;
                    else if (obj.textAlign === 'right') lx = obj.x - lw;

                    // Selection highlight
                    if (obj.id === editingObjId && selectedCharStart !== -1 && selectedCharStart !== selectedCharEnd) {
                        const s = Math.min(selectedCharStart, selectedCharEnd), en = Math.max(selectedCharStart, selectedCharEnd);
                        let hlX = lx, hlSX = null, hlW = 0;
                        for (let i = 0; i < line.length; i++) {
                            const gi = ci + i, w = getCharWidth(line[i]);
                            if (gi >= s && gi < en) { if (hlSX === null) hlSX = hlX; hlW += w; }
                            hlX += w;
                        }
                        if (hlSX !== null && hlW > 0) { ctx.fillStyle = 'rgba(0,120,212,0.3)'; ctx.fillRect(hlSX, lineY - lh / 2, hlW, lh); }
                    }

                    // Draw characters
                    let px = lx;
                    line.forEach(c => {
                        // タイプライター効果: visibleCharsを超えた文字はスキップ
                        if (totalCharIndex >= maxVisibleChars) {
                            px += getCharWidth(c);
                            totalCharIndex++;
                            return;
                        }
                        const charIdx = totalCharIndex;
                        totalCharIndex++;

                        // 文字アニメーションを取得
                        const charAnim = obj._charAnimations ? obj._charAnimations[charIdx] : null;
                        if (charAnim && charAnim.opacity === 0) {
                            px += getCharWidth(c);
                            return;
                        }

                        const dc = c.smallCaps && /[a-z]/.test(c.char) ? c.char.toUpperCase() : c.char;

                        // キーフレームプロパティを適用
                        const kfp = obj._keyframeProps;
                        const fontSize = kfp ? kfp.fontSize : c.fontSize;
                        const charColor = kfp ? kfp.color : c.color;
                        const charColor2 = kfp ? kfp.color2 : c.color2;
                        const charOpacityBase = kfp ? kfp.opacity : (c.opacity || 100);
                        const charScaleX = kfp ? kfp.scaleX : (c.scaleX || 100);
                        const charSlant = kfp ? kfp.slant : (c.slant || 0);
                        const charSpacing = kfp ? kfp.letterSpacing : (c.letterSpacing || 0);

                        const fs = c.smallCaps && /[a-z]/.test(c.char) ? fontSize * (c.smallCapsSize || 70) / 100 : fontSize;
                        ctx.save();
                        const fontWeight = c.bold !== false ? 'bold' : 'normal';
            const fontStyle = c.italic ? 'italic' : 'normal';
            ctx.font = `${fontStyle} ${fontWeight} ${fs}px "${c.fontFamily}"`;
                        ctx.textBaseline = 'middle';

                        // 文字アニメーションの不透明度を適用
                        let charOpacity = (obj.opacity || 100) / 100 * charOpacityBase / 100;
                        if (charAnim) charOpacity *= charAnim.opacity;
                        ctx.globalAlpha = charOpacity;

                        const bw = ctx.measureText(dc).width, sx = charScaleX / 100, cy = lineY - (c.baselineShift || 0);

                        // 文字アニメーションのオフセットを適用
                        let animOffsetX = charAnim ? (charAnim.offsetX || 0) : 0;
                        let animOffsetY = charAnim ? (charAnim.offsetY || 0) : 0;

                        ctx.translate(px + animOffsetX, cy + animOffsetY);

                        // 文字アニメーションの回転とスケールを適用
                        if (charAnim) {
                            if (charAnim.rotation) ctx.rotate(charAnim.rotation * Math.PI / 180);
                            if (charAnim.scale && charAnim.scale !== 1) ctx.scale(charAnim.scale, charAnim.scale);
                        }

                        if (charSlant) ctx.transform(1, 0, Math.tan(charSlant * Math.PI / 180), 1, 0, 0);

                        // カーソル追従: カーソル描画
                        if (charAnim && charAnim.showCursor) {
                            ctx.save();
                            ctx.fillStyle = '#fff';
                            ctx.fillRect(-2, -fs/2, bw + 4, fs);
                            ctx.restore();
                        }

                        // Shadow (draw before scale to avoid offset distortion)
                        if (c.shadowEnabled) {
                            const sa = (c.shadowAngle || 45) * Math.PI / 180;
                            const sd = c.shadowDistance || 5;
                            const sox = Math.cos(sa) * sd, soy = Math.sin(sa) * sd;
                            ctx.save();
                            ctx.scale(sx, 1);
                            ctx.translate(sox / sx, soy); // Adjust for scale
                            ctx.globalAlpha = (obj.opacity || 100) / 100 * (c.opacity || 100) / 100 * (c.shadowOpacity || 50) / 100;

                            // Apply blur effect
                            ctx.shadowColor = c.shadowColor || '#000';
                            ctx.shadowBlur = c.shadowBlur || 5;
                            ctx.shadowOffsetX = 0;
                            ctx.shadowOffsetY = 0;

                            // Shadow size (expansion) using stroke
                            const shadowSize = c.shadowSize || 0;
                            if (shadowSize > 0) {
                                ctx.lineWidth = shadowSize * 2;
                                ctx.lineJoin = 'round';
                                ctx.strokeStyle = c.shadowColor || '#000';
                                ctx.strokeText(dc, 0, 0);
                            }

                            ctx.fillStyle = c.shadowColor || '#000';
                            ctx.fillText(dc, 0, 0);
                            ctx.restore();
                        }

                        ctx.scale(sx, 1);

                        // Strokes（累積方式：外側から内側へ描画）
                        const strokes = c.strokes || [{ enabled: true, type: 'edge', color: '#000', width: 4, opacity: 100, join: 'round' }];
                        const enabledStrokes = strokes.filter(st => st.enabled);
                        for (let si = enabledStrokes.length - 1; si >= 0; si--) {
                            const st = enabledStrokes[si];
                            // 内側のストロークの累積幅（このストロークより前のストロークの合計）
                            let innerWidth = 0;
                            for (let sj = 0; sj < si; sj++) {
                                innerWidth += enabledStrokes[sj].width;
                            }
                            // このストロークまでの累積幅
                            let cumulativeWidth = innerWidth + st.width;

                            ctx.save();
                            ctx.globalAlpha = (obj.opacity || 100) / 100 * (c.opacity || 100) / 100 * (st.opacity || 100) / 100;

                            // ストロークグラデーション対応
                            if (st.gradientEnabled && st.gradientStops && st.gradientStops.length >= 2) {
                                const gw = bw, gh = fs;
                                const centerX = gw / 2;
                                let grad;
                                if (st.gradientType === 'radial') {
                                    grad = ctx.createRadialGradient(centerX, 0, 0, centerX, 0, Math.max(gw, gh) / 2);
                                } else {
                                    const a = (st.gradientAngle || 90) * Math.PI / 180;
                                    const dx = Math.cos(a) * gw / 2, dy = Math.sin(a) * gh / 2;
                                    grad = ctx.createLinearGradient(centerX - dx, -dy, centerX + dx, dy);
                                }
                                st.gradientStops.forEach((stop, idx) => {
                                    const pos = Math.max(0, Math.min(1, stop.pos / 100));
                                    grad.addColorStop(pos, stop.color);
                                });
                                ctx.strokeStyle = grad;
                            } else {
                                ctx.strokeStyle = st.color;
                            }

                            ctx.lineJoin = st.join || 'round';
                            if (st.type === 'depth') {
                                const depthAngle = (st.angle || 45) * Math.PI / 180;
                                const depthDx = Math.cos(depthAngle);
                                const depthDy = Math.sin(depthAngle);
                                // 内側のストロークの外側から描画開始
                                for (let d = st.width; d > 0; d -= 0.5) {
                                    if (!st.gradientEnabled) ctx.strokeStyle = st.color;
                                    ctx.lineWidth = innerWidth + d;
                                    ctx.save();
                                    ctx.translate((innerWidth + d) * depthDx, (innerWidth + d) * depthDy);
                                    ctx.strokeText(dc, 0, 0);
                                    ctx.restore();
                                }
                            } else if (st.type === 'drop') {
                                ctx.save();
                                // 内側のストロークの外側にドロップを配置
                                ctx.translate(innerWidth + st.width, innerWidth + st.width);
                                ctx.fillStyle = st.gradientEnabled ? ctx.strokeStyle : st.color;
                                ctx.fillText(dc, 0, 0);
                                ctx.restore();
                            } else {
                                // エッジタイプ：内側の全ストローク＋文字本体の形状全体を均等に囲む
                                const margin = st.width * 4;
                                const tempCanvas = document.createElement('canvas');
                                const metrics = ctx.measureText(dc);
                                tempCanvas.width = Math.ceil(metrics.width + fontSize + margin * 2);
                                tempCanvas.height = Math.ceil(fontSize * 2 + margin * 2);
                                const tempCtx = tempCanvas.getContext('2d');

                                // フォント設定をコピー
                                tempCtx.font = ctx.font;
                                tempCtx.textBaseline = ctx.textBaseline;
                                tempCtx.textAlign = ctx.textAlign;

                                const tempX = tempCanvas.width / 2;
                                const tempY = tempCanvas.height / 2;

                                // 内側の全ストロークを一時キャンバスに描画
                                for (let sj = si - 1; sj >= 0; sj--) {
                                    const innerSt = enabledStrokes[sj];
                                    let innerInnerWidth = 0;
                                    for (let sk = 0; sk < sj; sk++) {
                                        innerInnerWidth += enabledStrokes[sk].width;
                                    }

                                    if (innerSt.type === 'depth') {
                                        const depthAngle = (innerSt.angle || 45) * Math.PI / 180;
                                        const depthDx = Math.cos(depthAngle);
                                        const depthDy = Math.sin(depthAngle);
                                        for (let d = innerSt.width; d > 0; d -= 0.5) {
                                            tempCtx.lineWidth = innerInnerWidth + d;
                                            tempCtx.strokeStyle = innerSt.color;
                                            tempCtx.globalAlpha = (innerSt.opacity || 100) / 100;
                                            tempCtx.save();
                                            tempCtx.translate((innerInnerWidth + d) * depthDx, (innerInnerWidth + d) * depthDy);
                                            tempCtx.strokeText(dc, tempX, tempY);
                                            tempCtx.restore();
                                        }
                                    } else if (innerSt.type === 'drop') {
                                        tempCtx.save();
                                        tempCtx.translate(innerInnerWidth + innerSt.width, innerInnerWidth + innerSt.width);
                                        tempCtx.fillStyle = innerSt.color;
                                        tempCtx.globalAlpha = (innerSt.opacity || 100) / 100;
                                        tempCtx.fillText(dc, tempX, tempY);
                                        tempCtx.restore();
                                    } else {
                                        // 内側のエッジ（通常描画）
                                        tempCtx.lineWidth = innerInnerWidth + innerSt.width;
                                        tempCtx.strokeStyle = innerSt.color;
                                        tempCtx.globalAlpha = (innerSt.opacity || 100) / 100;
                                        tempCtx.strokeText(dc, tempX, tempY);
                                    }
                                }

                                // 文字本体を一時キャンバスに描画
                                if (c.fillType !== 'none') {
                                    tempCtx.fillStyle = charColor || '#ffffff';
                                    tempCtx.globalAlpha = 1.0;
                                    tempCtx.fillText(dc, tempX, tempY);
                                }

                                // エッジキャンバスを作成：一時キャンバスの内容を膨張させる
                                const edgeCanvas = document.createElement('canvas');
                                edgeCanvas.width = tempCanvas.width;
                                edgeCanvas.height = tempCanvas.height;
                                const edgeCtx = edgeCanvas.getContext('2d');

                                // st.joinに応じたエッジ描画アルゴリズム
                                const edgeSteps = Math.max(1, st.width);
                                const joinType = st.join || 'round';
                                const blurEnabled = st.blur || false;
                                const blurAmount = st.blurAmount || 0;

                                if (joinType === 'miter') {
                                    // 角(miter): 正方形膨張（上下左右＋対角を同じ距離で）
                                    for (let step = 1; step <= edgeSteps; step += 1) {
                                        edgeCtx.globalAlpha = 1.0;
                                        // 上下左右
                                        edgeCtx.drawImage(tempCanvas, step, 0);
                                        edgeCtx.drawImage(tempCanvas, -step, 0);
                                        edgeCtx.drawImage(tempCanvas, 0, step);
                                        edgeCtx.drawImage(tempCanvas, 0, -step);
                                        // 対角（正方形の角を埋める）
                                        edgeCtx.drawImage(tempCanvas, step, step);
                                        edgeCtx.drawImage(tempCanvas, step, -step);
                                        edgeCtx.drawImage(tempCanvas, -step, step);
                                        edgeCtx.drawImage(tempCanvas, -step, -step);
                                    }
                                } else if (joinType === 'bevel') {
                                    // 面取り(bevel): 8方向
                                    const bevelStep = Math.PI / 4;
                                    for (let step = 1; step <= edgeSteps; step += 1) {
                                        edgeCtx.globalAlpha = 1.0;
                                        for (let angle = 0; angle < Math.PI * 2; angle += bevelStep) {
                                            const dx = Math.cos(angle) * step;
                                            const dy = Math.sin(angle) * step;
                                            edgeCtx.drawImage(tempCanvas, dx, dy);
                                        }
                                    }
                                } else {
                                    // 丸み(round): 64方向で滑らかなエッジ
                                    const roundStep = Math.PI / 32;
                                    for (let step = 0.5; step <= edgeSteps; step += 0.5) {
                                        edgeCtx.globalAlpha = 1.0;
                                        for (let angle = 0; angle < Math.PI * 2; angle += roundStep) {
                                            const dx = Math.cos(angle) * step;
                                            const dy = Math.sin(angle) * step;
                                            edgeCtx.drawImage(tempCanvas, dx, dy);
                                        }
                                    }
                                }

                                // 元の内容を引いてエッジ部分のみを残す
                                edgeCtx.globalCompositeOperation = 'destination-out';
                                edgeCtx.globalAlpha = 1.0;
                                edgeCtx.drawImage(tempCanvas, 0, 0);

                                // エッジに色を適用
                                edgeCtx.globalCompositeOperation = 'source-in';
                                edgeCtx.fillStyle = st.color;
                                edgeCtx.fillRect(0, 0, edgeCanvas.width, edgeCanvas.height);

                                // グラデーションぼかし（内側から外側へ）
                                if (blurEnabled && blurAmount > 0) {
                                    const blurCanvas = document.createElement('canvas');
                                    blurCanvas.width = edgeCanvas.width;
                                    blurCanvas.height = edgeCanvas.height;
                                    const blurCtx = blurCanvas.getContext('2d');
                                    blurCtx.filter = `blur(${blurAmount}px)`;
                                    blurCtx.drawImage(edgeCanvas, 0, 0);
                                    edgeCtx.globalCompositeOperation = 'source-over';
                                    edgeCtx.clearRect(0, 0, edgeCanvas.width, edgeCanvas.height);
                                    edgeCtx.drawImage(blurCanvas, 0, 0);
                                }

                                // メインキャンバスに描画
                                ctx.globalAlpha = (obj.opacity || 100) / 100 * (c.opacity || 100) / 100 * (st.opacity || 100) / 100;
                                ctx.drawImage(edgeCanvas, -tempX, -tempY);
                            }
                            ctx.restore();
                        }

                        // Fill
                        if (c.fillType !== 'none') {
                            if (c.fillType === 'linear' || c.fillType === 'radial') {
                                // Use character width in current coordinate system (after scale)
                                const gw = bw, gh = fs;
                                const centerX = gw / 2; // Character center X
                                let grad;
                                if (c.fillType === 'linear') {
                                    const a = (c.gradientAngle || 0) * Math.PI / 180;
                                    const dx = Math.cos(a) * gw / 2, dy = Math.sin(a) * gh / 2;
                                    // Center gradient at character center
                                    grad = ctx.createLinearGradient(centerX - dx, -dy, centerX + dx, dy);
                                } else {
                                    grad = ctx.createRadialGradient(centerX, 0, 0, centerX, 0, Math.max(gw, gh) / 2);
                                }
                            // Use multiple color stops based on ratio with blur support
                            if (c.gradientStops && c.gradientStops.length >= 2) {
                                const blur = (c.gradientBlur || 0) / 100; // 0-1 range

                                c.gradientStops.forEach((stop, i) => {
                                    const startPos = Math.max(0, Math.min(1, (stop.pos || 0) / 100));
                                    // Use endPos if defined, otherwise use next stop's pos or 100
                                    let endPosValue = stop.endPos;
                                    if (endPosValue === undefined) {
                                        endPosValue = (i < c.gradientStops.length - 1) ?
                                            c.gradientStops[i + 1].pos : 100;
                                    }
                                    const endPos = Math.max(0, Math.min(1, endPosValue / 100));

                                    if (blur === 0) {
                                        // Sharp boundaries
                                        if (i === 0) {
                                            grad.addColorStop(0, stop.color);
                                        } else {
                                            grad.addColorStop(Math.min(1, startPos + 0.001), stop.color);
                                        }
                                        if (i === c.gradientStops.length - 1) {
                                            grad.addColorStop(1, stop.color);
                                        } else {
                                            grad.addColorStop(Math.max(0, endPos - 0.001), stop.color);
                                        }
                                    } else {
                                        // Smooth transitions with blur
                                        const blurAmount = blur * 0.5; // Max 50% of range for blur

                                        if (i === 0) {
                                            grad.addColorStop(0, stop.color);
                                            // Blend towards next color
                                            if (i < c.gradientStops.length - 1) {
                                                const blendEnd = Math.max(0, Math.min(1, endPos - blurAmount));
                                                if (blendEnd > 0) grad.addColorStop(blendEnd, stop.color);
                                            }
                                        } else if (i === c.gradientStops.length - 1) {
                                            // Blend from previous color
                                            const blendStart = Math.max(0, Math.min(1, startPos + blurAmount));
                                            if (blendStart < 1) grad.addColorStop(blendStart, stop.color);
                                            grad.addColorStop(1, stop.color);
                                        } else {
                                            // Middle colors - blend on both sides
                                            const blendStart = Math.max(0, Math.min(1, startPos + blurAmount));
                                            const blendEnd = Math.max(0, Math.min(1, endPos - blurAmount));
                                            if (blendStart < blendEnd) {
                                                grad.addColorStop(blendStart, stop.color);
                                                grad.addColorStop(blendEnd, stop.color);
                                            } else {
                                                // Range too small, just use midpoint
                                                const midPoint = Math.max(0, Math.min(1, (startPos + endPos) / 2));
                                                grad.addColorStop(midPoint, stop.color);
                                            }
                                        }
                                    }
                                });
                            } else {
                                grad.addColorStop(0, charColor);
                                grad.addColorStop(1, charColor2 || '#888');
                            }
                                ctx.fillStyle = grad;
                            } else {
                                ctx.fillStyle = charColor;
                            }
                            ctx.fillText(dc, 0, 0);
                        }

                        // Gloss - horizontal band overlay on text fill only (not strokes)
                        if (c.glossEnabled) {
                            const glossWidth = c.glossWidth || 10;
                            const glossBlur = c.glossBlur || 5;
                            const glossCol = c.glossColor || '#ffffff';
                            const glossOpacity = (c.glossOpacity || 50) / 100;

                            // Parse color
                            const gr = parseInt(glossCol.slice(1, 3), 16);
                            const gg = parseInt(glossCol.slice(3, 5), 16);
                            const gb = parseInt(glossCol.slice(5, 7), 16);

                            // Create temp canvas for gloss clipping to text fill only
                            const glossCanvas = document.createElement('canvas');
                            const margin = 10;
                            glossCanvas.width = bw + margin * 2;
                            glossCanvas.height = fs + margin * 2;
                            const glossCtx = glossCanvas.getContext('2d');

                            // Draw text fill as mask
                            glossCtx.font = ctx.font;
                            glossCtx.textBaseline = 'middle';
                            glossCtx.textAlign = 'left';
                            glossCtx.fillStyle = '#fff';
                            glossCtx.fillText(dc, margin, glossCanvas.height / 2);

                            // Apply gloss only inside text
                            glossCtx.globalCompositeOperation = 'source-in';

                            // Calculate band dimensions
                            const bandHeight = glossWidth;
                            const fadeHeight = glossBlur;
                            const totalHeight = bandHeight + fadeHeight * 2;
                            // Position gloss in center of text
                            const glossY = glossCanvas.height * 0.5;

                            // Create vertical gradient for horizontal band
                            const glossGrad = glossCtx.createLinearGradient(0, glossY - totalHeight/2, 0, glossY + totalHeight/2);
                            glossGrad.addColorStop(0, `rgba(${gr},${gg},${gb},0)`);
                            if (fadeHeight > 0 && totalHeight > 0) {
                                const fadeRatio = Math.min(0.49, fadeHeight / totalHeight);
                                glossGrad.addColorStop(fadeRatio, `rgba(${gr},${gg},${gb},${glossOpacity})`);
                                glossGrad.addColorStop(1 - fadeRatio, `rgba(${gr},${gg},${gb},${glossOpacity})`);
                            } else {
                                glossGrad.addColorStop(0.01, `rgba(${gr},${gg},${gb},${glossOpacity})`);
                                glossGrad.addColorStop(0.99, `rgba(${gr},${gg},${gb},${glossOpacity})`);
                            }
                            glossGrad.addColorStop(1, `rgba(${gr},${gg},${gb},0)`);

                            glossCtx.fillStyle = glossGrad;
                            glossCtx.fillRect(0, glossY - totalHeight/2, glossCanvas.width, totalHeight);

                            // Draw gloss result on main canvas
                            ctx.drawImage(glossCanvas, -margin, -glossCanvas.height/2);
                        }

                        ctx.restore();
                        px += getCharWidth(c) + charSpacing;
                    });
                    ci += line.length + 1;
                }

                // Cursor
                if (obj.id === editingObjId && cursorVisible && selectedCharStart === -1) {
                    let cLine = 0, cIdx = 0, count = 0;
                    for (let li = 0; li < lines.length; li++) {
                        if (cursorPos <= count + lines[li].length) { cLine = li; cIdx = cursorPos - count; break; }
                        count += lines[li].length + 1;
                    }
                    const line = lines[cLine] || [], lineY = startY + cLine * lh, lw = getLineWidth(line);
                    let clx = obj.x;
                    if (obj.textAlign === 'center') clx = obj.x - lw / 2;
                    else if (obj.textAlign === 'right') clx = obj.x - lw;
                    let cX = clx;
                    for (let i = 0; i < cIdx; i++) cX += getCharWidth(line[i]);
                    ctx.strokeStyle = '#fff'; ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.moveTo(cX, lineY - lh / 2); ctx.lineTo(cX, lineY + lh / 2); ctx.stroke();
                }

                ctx.restore();

                // Draw name tag (after text)
                drawNameTag(ctx, obj, bounds);

                // Selection box and handles
                if (obj.id === selectedObjId && obj.id !== editingObjId) {
                    const b = getObjectBounds(obj);
                    ctx.strokeStyle = '#0066cc'; ctx.lineWidth = 2; ctx.setLineDash([5, 3]);
                    ctx.strokeRect(b.x - 5, b.y - 5, b.w + 10, b.h + 10);
                    ctx.setLineDash([]);
                    const handles = [
                        { x: b.x, y: b.y }, { x: b.x + b.w / 2, y: b.y }, { x: b.x + b.w, y: b.y },
                        { x: b.x + b.w, y: b.y + b.h / 2 }, { x: b.x + b.w, y: b.y + b.h },
                        { x: b.x + b.w / 2, y: b.y + b.h }, { x: b.x, y: b.y + b.h }, { x: b.x, y: b.y + b.h / 2 }
                    ];
                    ctx.fillStyle = '#fff'; ctx.strokeStyle = '#0066cc'; ctx.lineWidth = 1;
                    handles.forEach(h => { ctx.fillRect(h.x - 4, h.y - 4, 8, 8); ctx.strokeRect(h.x - 4, h.y - 4, 8, 8); });
                }

                // アニメーション位置を復元
                obj.x = origX;
                obj.y = origY;
            });

            // 図形描画プレビュー
            if (tempShape && isDrawingShape) {
                ctx.save();
                ctx.strokeStyle = '#0066cc';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                const x = Math.min(tempShape.x1, tempShape.x2);
                const y = Math.min(tempShape.y1, tempShape.y2);
                const w = Math.abs(tempShape.x2 - tempShape.x1);
                const h = Math.abs(tempShape.y2 - tempShape.y1);

                if (tempShape.type === 'rect') {
                    ctx.strokeRect(x, y, w, h);
                } else if (tempShape.type === 'roundRect') {
                    const r = Math.min(20, w / 2, h / 2);
                    drawRoundedRect(ctx, x, y, w, h, r);
                    ctx.stroke();
                } else if (tempShape.type === 'ellipse') {
                    ctx.beginPath();
                    ctx.ellipse(x + w / 2, y + h / 2, w / 2, h / 2, 0, 0, Math.PI * 2);
                    ctx.stroke();
                } else if (tempShape.type === 'triangle') {
                    ctx.beginPath();
                    ctx.moveTo(x + w / 2, y);
                    ctx.lineTo(x + w, y + h);
                    ctx.lineTo(x, y + h);
                    ctx.closePath();
                    ctx.stroke();
                } else if (tempShape.type === 'line') {
                    ctx.beginPath();
                    ctx.moveTo(tempShape.x1, tempShape.y1);
                    ctx.lineTo(tempShape.x2, tempShape.y2);
                    ctx.stroke();
                } else if (tempShape.type === 'chamferRect') {
                    const c = Math.min(10, w / 4, h / 4);
                    ctx.beginPath();
                    ctx.moveTo(x + c, y);
                    ctx.lineTo(x + w - c, y);
                    ctx.lineTo(x + w, y + c);
                    ctx.lineTo(x + w, y + h - c);
                    ctx.lineTo(x + w - c, y + h);
                    ctx.lineTo(x + c, y + h);
                    ctx.lineTo(x, y + h - c);
                    ctx.lineTo(x, y + c);
                    ctx.closePath();
                    ctx.stroke();
                } else if (tempShape.type === 'arc') {
                    ctx.beginPath();
                    ctx.arc(x + w / 2, y + h, Math.min(w / 2, h), Math.PI, 0);
                    ctx.stroke();
                }
                ctx.restore();
            }

            // パス描画プレビュー
            if (isDrawingPath && pathPoints.length > 0) {
                ctx.save();
                ctx.strokeStyle = '#0066cc';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(pathPoints[0].x, pathPoints[0].y);
                for (let i = 1; i < pathPoints.length; i++) {
                    const prev = pathPoints[i - 1];
                    const curr = pathPoints[i];
                    // ベジェ曲線または直線
                    if (prev.cp2 || curr.cp1) {
                        const cp1 = prev.cp2 || { x: prev.x, y: prev.y };
                        const cp2 = curr.cp1 || { x: curr.x, y: curr.y };
                        ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, curr.x, curr.y);
                    } else {
                        ctx.lineTo(curr.x, curr.y);
                    }
                }
                ctx.stroke();
                ctx.setLineDash([]);

                // Draw anchor points
                ctx.fillStyle = '#0066cc';
                pathPoints.forEach(p => {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                    ctx.fill();
                });

                // Draw control point handles for last point (during drag)
                if (currentTool === 'pen' && pathPoints.length > 0) {
                    const lastPoint = pathPoints[pathPoints.length - 1];
                    if (lastPoint.cp1 || lastPoint.cp2) {
                        ctx.strokeStyle = '#ff6600';
                        ctx.lineWidth = 1;
                        ctx.setLineDash([]);

                        // Draw handle lines and control points
                        if (lastPoint.cp1) {
                            ctx.beginPath();
                            ctx.moveTo(lastPoint.x, lastPoint.y);
                            ctx.lineTo(lastPoint.cp1.x, lastPoint.cp1.y);
                            ctx.stroke();
                            ctx.beginPath();
                            ctx.arc(lastPoint.cp1.x, lastPoint.cp1.y, 3, 0, Math.PI * 2);
                            ctx.fillStyle = '#ff6600';
                            ctx.fill();
                        }
                        if (lastPoint.cp2) {
                            ctx.beginPath();
                            ctx.moveTo(lastPoint.x, lastPoint.y);
                            ctx.lineTo(lastPoint.cp2.x, lastPoint.cp2.y);
                            ctx.stroke();
                            ctx.beginPath();
                            ctx.arc(lastPoint.cp2.x, lastPoint.cp2.y, 3, 0, Math.PI * 2);
                            ctx.fillStyle = '#ff6600';
                            ctx.fill();
                        }
                    }
                }
                ctx.restore();
            }

            // 矩形選択の描画
            if (isBoxSelecting) {
                ctx.save();
                ctx.strokeStyle = '#0066cc';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 3]);
                ctx.fillStyle = 'rgba(0, 102, 204, 0.1)';

                const minX = Math.min(boxSelectStart.x, boxSelectEnd.x);
                const minY = Math.min(boxSelectStart.y, boxSelectEnd.y);
                const width = Math.abs(boxSelectEnd.x - boxSelectStart.x);
                const height = Math.abs(boxSelectEnd.y - boxSelectStart.y);

                ctx.fillRect(minX, minY, width, height);
                ctx.strokeRect(minX, minY, width, height);
                ctx.setLineDash([]);
                ctx.restore();
            }

            // セーフマージン描画（最前面）
            drawSafeMargins(ctx);

            let statusMsg = `オブジェクト: ${textObjects.length}`;
            if (editingObjId) {
                statusMsg = '編集中 (Esc終了)';
            } else if (isDrawingPath) {
                statusMsg = `パス描画中 (${pathPoints.length}点) - ダブルクリックで完成`;
            } else if (selectedObjIds.length > 1) {
                statusMsg = `${selectedObjIds.length}個選択中 (Ctrl+G: グループ化)`;
            }
            document.getElementById('statusText').textContent = statusMsg;

            // サムネイル更新をスケジュール（サムネイル更新中でない場合のみ）
            if (!isUpdatingThumbnail && activeCanvasId) {
                scheduleThumbnailUpdate();
            }
        }

        function changeResolution() {
            const [w, h] = document.getElementById('resolution').value.split('x').map(Number);
            canvas.width = w; canvas.height = h;
            document.getElementById('resolution-display').textContent = `${w}×${h}`;
            render();
        }

        // 画像関連の関数
        let pickingColor = false;  // スポイトモード

        function insertImage() {
            document.getElementById('imageInput').click();
        }

        function handleImageLoad(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(event) {
                const img = new Image();
                img.onload = function() {
                    saveState();
                    const imageObj = {
                        id: Date.now(),
                        type: 'image',
                        name: file.name.substring(0, 20),
                        x: canvas.width / 2,
                        y: canvas.height / 2,
                        width: img.width,
                        height: img.height,
                        originalWidth: img.width,
                        originalHeight: img.height,
                        rotation: 0,
                        opacity: 100,
                        flipH: false,
                        flipV: false,
                        crop: { left: 0, top: 0, right: 0, bottom: 0 },
                        transparent: { enabled: false, color: '#00ff00', tolerance: 30 },
                        stroke: { color: '#000000', width: 0 },
                        imageData: event.target.result  // Base64データ
                    };
                    // キャンバスに収まるようにリサイズ
                    const maxW = canvas.width * 0.8;
                    const maxH = canvas.height * 0.8;
                    if (imageObj.width > maxW || imageObj.height > maxH) {
                        const scale = Math.min(maxW / imageObj.width, maxH / imageObj.height);
                        imageObj.width = Math.round(imageObj.width * scale);
                        imageObj.height = Math.round(imageObj.height * scale);
                    }
                    textObjects.push(imageObj);
                    selectObject(imageObj.id);
                    updateLayerList();
                    render();
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
            e.target.value = '';
        }

        function updateImageSize() {
            if (!selectedObjId) return;
            const obj = textObjects.find(o => o.id === selectedObjId);
            if (!obj || obj.type !== 'image') return;

            const newW = parseInt(document.getElementById('imageWidth').value) || obj.width;
            const newH = parseInt(document.getElementById('imageHeight').value) || obj.height;
            const lockAspect = document.getElementById('imageLockAspect').checked;

            if (lockAspect) {
                if (newW !== obj.width) {
                    const scale = newW / obj.width;
                    obj.width = newW;
                    obj.height = Math.round(obj.height * scale);
                    document.getElementById('imageHeight').value = obj.height;
                } else if (newH !== obj.height) {
                    const scale = newH / obj.height;
                    obj.height = newH;
                    obj.width = Math.round(obj.width * scale);
                    document.getElementById('imageWidth').value = obj.width;
                }
            } else {
                obj.width = newW;
                obj.height = newH;
            }
            render();
        }

        function flipImage(direction) {
            if (!selectedObjId) return;
            const obj = textObjects.find(o => o.id === selectedObjId);
            if (!obj || obj.type !== 'image') return;
            saveState();
            if (direction === 'h') obj.flipH = !obj.flipH;
            else obj.flipV = !obj.flipV;
            render();
        }

        function updateImageCrop() {
            if (!selectedObjId) return;
            const obj = textObjects.find(o => o.id === selectedObjId);
            if (!obj || obj.type !== 'image') return;

            obj.crop = {
                left: parseInt(document.getElementById('imageCropLeft').value) || 0,
                top: parseInt(document.getElementById('imageCropTop').value) || 0,
                right: parseInt(document.getElementById('imageCropRight').value) || 0,
                bottom: parseInt(document.getElementById('imageCropBottom').value) || 0
            };
            render();
        }

        function updateImageTransparency() {
            if (!selectedObjId) return;
            const obj = textObjects.find(o => o.id === selectedObjId);
            if (!obj || obj.type !== 'image') return;

            obj.transparent = {
                enabled: document.getElementById('imageTransparentEnabled').checked,
                color: document.getElementById('imageTransparentColor').value,
                tolerance: parseInt(document.getElementById('imageTransparentTolerance').value) || 30
            };
            render();
        }

        function pickTransparentColor() {
            pickingColor = true;
            canvas.style.cursor = 'crosshair';
        }

        function updateImageStroke() {
            if (!selectedObjId) return;
            const obj = textObjects.find(o => o.id === selectedObjId);
            if (!obj || obj.type !== 'image') return;

            obj.stroke = {
                color: document.getElementById('imageStrokeColor').value,
                width: parseInt(document.getElementById('imageStrokeWidth').value) || 0
            };
            render();
        }

        function loadImageUI(obj) {
            const panel = document.getElementById('imageSettings');
            if (!obj || obj.type !== 'image') {
                panel.classList.add('hidden');
                panel.previousElementSibling.classList.add('collapsed');
                return;
            }

            panel.classList.remove('hidden');
            panel.previousElementSibling.classList.remove('collapsed');

            document.getElementById('imageWidth').value = obj.width;
            document.getElementById('imageHeight').value = obj.height;
            document.getElementById('imageCropLeft').value = obj.crop?.left || 0;
            document.getElementById('imageCropTop').value = obj.crop?.top || 0;
            document.getElementById('imageCropRight').value = obj.crop?.right || 0;
            document.getElementById('imageCropBottom').value = obj.crop?.bottom || 0;
            document.getElementById('imageTransparentEnabled').checked = obj.transparent?.enabled || false;
            document.getElementById('imageTransparentColor').value = obj.transparent?.color || '#00ff00';
            document.getElementById('imageTransparentTolerance').value = obj.transparent?.tolerance || 30;
            document.getElementById('imageStrokeColor').value = obj.stroke?.color || '#000000';
            document.getElementById('imageStrokeWidth').value = obj.stroke?.width || 0;
        }

        // 画像の描画関数
        const imageCache = {};  // 画像キャッシュ

        function drawImageObject(ctx, obj) {
            if (!obj.imageData) return;

            // 画像をキャッシュから取得または作成
            let img = imageCache[obj.id];
            if (!img || img.src !== obj.imageData) {
                img = new Image();
                img.src = obj.imageData;
                imageCache[obj.id] = img;
            }

            if (!img.complete) return;

            const crop = obj.crop || { left: 0, top: 0, right: 0, bottom: 0 };
            const srcX = crop.left;
            const srcY = crop.top;
            const srcW = obj.originalWidth - crop.left - crop.right;
            const srcH = obj.originalHeight - crop.top - crop.bottom;

            if (srcW <= 0 || srcH <= 0) return;

            ctx.save();

            // 反転
            const scaleX = obj.flipH ? -1 : 1;
            const scaleY = obj.flipV ? -1 : 1;
            ctx.translate(obj.x, obj.y);
            ctx.scale(scaleX, scaleY);
            ctx.translate(-obj.x, -obj.y);

            const dstW = obj.width * (srcW / obj.originalWidth);
            const dstH = obj.height * (srcH / obj.originalHeight);
            const dstX = obj.x - dstW / 2;
            const dstY = obj.y - dstH / 2;

            // 色透過処理
            if (obj.transparent?.enabled) {
                // オフスクリーンキャンバスで処理
                const offCanvas = document.createElement('canvas');
                offCanvas.width = srcW;
                offCanvas.height = srcH;
                const offCtx = offCanvas.getContext('2d');
                offCtx.drawImage(img, srcX, srcY, srcW, srcH, 0, 0, srcW, srcH);

                const imageData = offCtx.getImageData(0, 0, srcW, srcH);
                const data = imageData.data;
                const targetColor = hexToRgb(obj.transparent.color);
                const tolerance = obj.transparent.tolerance;

                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i], g = data[i + 1], b = data[i + 2];
                    const diff = Math.abs(r - targetColor.r) + Math.abs(g - targetColor.g) + Math.abs(b - targetColor.b);
                    if (diff <= tolerance * 3) {
                        data[i + 3] = 0;  // 透明に
                    }
                }
                offCtx.putImageData(imageData, 0, 0);
                ctx.drawImage(offCanvas, dstX, dstY, dstW, dstH);
            } else {
                ctx.drawImage(img, srcX, srcY, srcW, srcH, dstX, dstY, dstW, dstH);
            }

            // ストローク
            if (obj.stroke?.width > 0) {
                ctx.strokeStyle = obj.stroke.color;
                ctx.lineWidth = obj.stroke.width;
                ctx.strokeRect(dstX, dstY, dstW, dstH);
            }

            ctx.restore();
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 0, g: 0, b: 0 };
        }

        function exportPNG() {
            exitEditMode(); selectedObjId = null; selectedObjIds = [];

            // ファイル名を入力
            const fileName = prompt('PNG書き出しファイル名を入力してください（.png は自動で付きます）', 'telop');
            if (!fileName) return;

            // 一時的にセーフマージンを非表示にしてレンダリング
            const safeMarginCheckbox = document.getElementById('safeMarginEnabled');
            const wasEnabled = safeMarginCheckbox.checked;
            safeMarginCheckbox.checked = false;

            // 背景透過設定
            exportingTransparent = document.getElementById('exportTransparent').checked;
            render();

            const link = document.createElement('a');
            link.download = `${fileName}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();

            // 元に戻す
            exportingTransparent = false;
            safeMarginCheckbox.checked = wasEnabled;
            render();
        }

        // ========== アニメーション機能 ==========

        function updateAnimation() {
            if (!selectedObjId) return;
            const obj = textObjects.find(o => o.id === selectedObjId);
            if (!obj) return;

            obj.animation = {
                type: document.getElementById('animType').value,
                duration: parseFloat(document.getElementById('animDuration').value) || 2,
                delay: parseFloat(document.getElementById('animDelay').value) || 0,
                speed: parseFloat(document.getElementById('animSpeed').value) || 100,
                easing: document.getElementById('animEasing').value,
                loop: document.getElementById('animLoop').checked
            };
            render();
        }

        function loadAnimationUI(obj) {
            const panel = document.getElementById('animationSettings');
            if (!obj || !obj.animation) {
                document.getElementById('animType').value = 'none';
                document.getElementById('animDuration').value = 2;
                document.getElementById('animDelay').value = 0;
                document.getElementById('animSpeed').value = 100;
                document.getElementById('animEasing').value = 'linear';
                document.getElementById('animLoop').checked = false;
                return;
            }

            document.getElementById('animType').value = obj.animation.type || 'none';
            document.getElementById('animDuration').value = obj.animation.duration || 2;
            document.getElementById('animDelay').value = obj.animation.delay || 0;
            document.getElementById('animSpeed').value = obj.animation.speed || 100;
            document.getElementById('animEasing').value = obj.animation.easing || 'linear';
            document.getElementById('animLoop').checked = obj.animation.loop || false;
            updateKeyframeList();
        }

        // キーフレーム関連関数
        function addKeyframe() {
            if (!selectedObjId) return;
            const obj = textObjects.find(o => o.id === selectedObjId);
            if (!obj) return;

            if (!obj.keyframes) obj.keyframes = [];

            const newTime = obj.keyframes.length > 0 ?
                Math.max(...obj.keyframes.map(k => k.time)) + 1 : 0;

            obj.keyframes.push({
                time: newTime,
                props: {
                    fontSize: 60,
                    color: '#ffffff',
                    opacity: 100,
                    scaleX: 100,
                    letterSpacing: 0,
                    slant: 0
                }
            });

            obj.keyframes.sort((a, b) => a.time - b.time);
            updateKeyframeList();
        }

        function addKeyframeFromCurrent() {
            if (!selectedObjId) return;
            const obj = textObjects.find(o => o.id === selectedObjId);
            if (!obj || !obj.chars || obj.chars.length === 0) return;

            if (!obj.keyframes) obj.keyframes = [];

            // 現在の最初の文字のスタイルを取得
            const c = obj.chars[0];
            const newTime = obj.keyframes.length > 0 ?
                Math.max(...obj.keyframes.map(k => k.time)) + 1 : 0;

            obj.keyframes.push({
                time: newTime,
                props: {
                    fontSize: c.fontSize || 60,
                    color: c.color || '#ffffff',
                    color2: c.color2 || '#888888',
                    fillType: c.fillType || 'solid',
                    gradientAngle: c.gradientAngle || 0,
                    opacity: c.opacity || 100,
                    scaleX: c.scaleX || 100,
                    letterSpacing: c.letterSpacing || 0,
                    slant: c.slant || 0
                }
            });

            obj.keyframes.sort((a, b) => a.time - b.time);
            updateKeyframeList();
        }

        function updateKeyframeList() {
            const list = document.getElementById('keyframeList');
            if (!selectedObjId) {
                list.innerHTML = '<div style="color:#888;font-size:11px;">オブジェクトを選択してください</div>';
                return;
            }

            const obj = textObjects.find(o => o.id === selectedObjId);
            if (!obj || !obj.keyframes || obj.keyframes.length === 0) {
                list.innerHTML = '<div style="color:#888;font-size:11px;">キーフレームなし</div>';
                return;
            }

            list.innerHTML = obj.keyframes.map((kf, i) => `
                <div style="border-bottom:1px solid #444;padding:5px 0;font-size:11px;">
                    <div style="display:flex;justify-content:space-between;align-items:center;">
                        <span><b>${kf.time}秒</b></span>
                        <div>
                            <button class="btn btn-small" onclick="editKeyframe(${i})" style="padding:2px 5px;font-size:10px;">編集</button>
                            <button class="btn btn-small btn-danger" onclick="deleteKeyframe(${i})" style="padding:2px 5px;font-size:10px;">×</button>
                        </div>
                    </div>
                    <div style="color:#aaa;font-size:10px;margin-top:3px;">
                        ${kf.props.fontSize}px / ${kf.props.opacity}% / ${kf.props.color}
                    </div>
                </div>
            `).join('');
        }

        function deleteKeyframe(index) {
            if (!selectedObjId) return;
            const obj = textObjects.find(o => o.id === selectedObjId);
            if (!obj || !obj.keyframes) return;

            obj.keyframes.splice(index, 1);
            updateKeyframeList();
        }

        function editKeyframe(index) {
            if (!selectedObjId) return;
            const obj = textObjects.find(o => o.id === selectedObjId);
            if (!obj || !obj.keyframes || !obj.keyframes[index]) return;

            const kf = obj.keyframes[index];
            const newTime = prompt('時間（秒）:', kf.time);
            if (newTime === null) return;
            kf.time = parseFloat(newTime) || 0;

            const newSize = prompt('フォントサイズ:', kf.props.fontSize);
            if (newSize !== null) kf.props.fontSize = parseInt(newSize) || 60;

            const newOpacity = prompt('不透明度 (0-100):', kf.props.opacity);
            if (newOpacity !== null) kf.props.opacity = parseInt(newOpacity) || 100;

            const newColor = prompt('色 (#xxxxxx):', kf.props.color);
            if (newColor !== null) kf.props.color = newColor || '#ffffff';

            const newScaleX = prompt('縦横比率 (%):', kf.props.scaleX);
            if (newScaleX !== null) kf.props.scaleX = parseInt(newScaleX) || 100;

            const newSpacing = prompt('カーニング:', kf.props.letterSpacing);
            if (newSpacing !== null) kf.props.letterSpacing = parseInt(newSpacing) || 0;

            const newSlant = prompt('斜め角度:', kf.props.slant);
            if (newSlant !== null) kf.props.slant = parseInt(newSlant) || 0;

            obj.keyframes.sort((a, b) => a.time - b.time);
            updateKeyframeList();
        }

        // キーフレーム補間
        function interpolateKeyframes(obj) {
            if (!obj.keyframes || obj.keyframes.length === 0) return null;

            const kfs = obj.keyframes;
            const t = animationTime;

            // 時間範囲外
            if (t <= kfs[0].time) return kfs[0].props;
            if (t >= kfs[kfs.length - 1].time) return kfs[kfs.length - 1].props;

            // 補間するキーフレームを探す
            let prev = kfs[0], next = kfs[1];
            for (let i = 0; i < kfs.length - 1; i++) {
                if (t >= kfs[i].time && t <= kfs[i + 1].time) {
                    prev = kfs[i];
                    next = kfs[i + 1];
                    break;
                }
            }

            // 補間率
            const duration = next.time - prev.time;
            const progress = duration > 0 ? (t - prev.time) / duration : 0;

            // 各プロパティを補間
            return {
                fontSize: lerp(prev.props.fontSize, next.props.fontSize, progress),
                color: lerpColor(prev.props.color, next.props.color, progress),
                color2: lerpColor(prev.props.color2 || prev.props.color, next.props.color2 || next.props.color, progress),
                fillType: progress < 0.5 ? prev.props.fillType : next.props.fillType,
                gradientAngle: lerp(prev.props.gradientAngle || 0, next.props.gradientAngle || 0, progress),
                opacity: lerp(prev.props.opacity, next.props.opacity, progress),
                scaleX: lerp(prev.props.scaleX, next.props.scaleX, progress),
                letterSpacing: lerp(prev.props.letterSpacing || 0, next.props.letterSpacing || 0, progress),
                slant: lerp(prev.props.slant || 0, next.props.slant || 0, progress)
            };
        }

        // 線形補間
        function lerp(a, b, t) {
            return a + (b - a) * t;
        }

        // 色の補間
        function lerpColor(c1, c2, t) {
            if (!c1 || !c2) return c1 || c2 || '#ffffff';
            const r1 = parseInt(c1.slice(1, 3), 16);
            const g1 = parseInt(c1.slice(3, 5), 16);
            const b1 = parseInt(c1.slice(5, 7), 16);
            const r2 = parseInt(c2.slice(1, 3), 16);
            const g2 = parseInt(c2.slice(3, 5), 16);
            const b2 = parseInt(c2.slice(5, 7), 16);
            const r = Math.round(lerp(r1, r2, t));
            const g = Math.round(lerp(g1, g2, t));
            const b = Math.round(lerp(b1, b2, t));
            return '#' + [r, g, b].map(v => v.toString(16).padStart(2, '0')).join('');
        }

        function toggleAnimation() {
            if (isPlaying) {
                stopAnimation();
            } else {
                startAnimation();
            }
        }

        function startAnimation() {
            isPlaying = true;
            animationStartTime = performance.now() - animationTime * 1000;
            document.getElementById('playIcon').innerHTML = '<rect x="6" y="4" width="4" height="16" fill="currentColor"/><rect x="14" y="4" width="4" height="16" fill="currentColor"/>';
            animationLoop();
        }

        function stopAnimation() {
            isPlaying = false;
            if (animationFrame) cancelAnimationFrame(animationFrame);
            document.getElementById('playIcon').innerHTML = '<path d="M8 5v14l11-7z" fill="currentColor"/>';
        }

        function resetAnimation() {
            stopAnimation();
            animationTime = 0;
            document.getElementById('timeline').value = 0;
            render();
        }

        function seekAnimation(value) {
            animationTime = (value / 100) * totalDuration;
            if (isPlaying) {
                animationStartTime = performance.now() - animationTime * 1000;
            }
            render();
        }

        function animationLoop() {
            if (!isPlaying) return;

            const now = performance.now();
            animationTime = (now - animationStartTime) / 1000;

            // 最大時間を超えたらループまたは停止
            if (animationTime >= totalDuration) {
                const hasLoop = textObjects.some(obj => obj.animation?.loop);
                if (hasLoop) {
                    animationTime = 0;
                    animationStartTime = now;
                } else {
                    stopAnimation();
                    animationTime = totalDuration;
                }
            }

            // タイムラインスライダーを更新
            document.getElementById('timeline').value = (animationTime / totalDuration) * 100;

            render();
            animationFrame = requestAnimationFrame(animationLoop);
        }

        // イージング関数
        function easeValue(t, easing) {
            switch (easing) {
                case 'easeIn': return t * t;
                case 'easeOut': return t * (2 - t);
                case 'easeInOut': return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
                default: return t; // linear
            }
        }

        // アニメーション適用（renderの前に呼ばれる）
        function getAnimatedProperties(obj) {
            const charCount = obj.chars?.length || 0;
            if (!obj.animation || obj.animation.type === 'none') {
                return { opacity: obj.opacity || 100, x: obj.x, y: obj.y, visibleChars: charCount, charAnimations: null };
            }

            const anim = obj.animation;
            const delay = anim.delay || 0;
            const duration = anim.duration || 2;
            const speed = (anim.speed || 100) / 100;

            let t = (animationTime - delay) / duration;
            if (t < 0) t = 0;
            if (t > 1) t = anim.loop ? (t % 1) : 1;

            t = easeValue(t, anim.easing);

            let opacity = obj.opacity || 100;
            let x = obj.x;
            let y = obj.y;
            let visibleChars = charCount;
            let charAnimations = null;  // 各文字ごとのアニメーション

            switch (anim.type) {
                case 'fadeIn':
                    opacity = t * (obj.opacity || 100);
                    break;
                case 'fadeOut':
                    opacity = (1 - t) * (obj.opacity || 100);
                    break;
                case 'slideLeft':
                    x = obj.x - (1 - t) * canvas.width * 0.5;
                    break;
                case 'slideRight':
                    x = obj.x + (1 - t) * canvas.width * 0.5;
                    break;
                case 'slideUp':
                    y = obj.y - (1 - t) * canvas.height * 0.5;
                    break;
                case 'slideDown':
                    y = obj.y + (1 - t) * canvas.height * 0.5;
                    break;
                case 'typewriter':
                    if (obj.chars) {
                        visibleChars = Math.floor(t * charCount);
                    }
                    break;
                case 'rotateIn':
                    // 1文字ずつ回転して出現
                    if (obj.chars && charCount > 0) {
                        charAnimations = [];
                        for (let i = 0; i < charCount; i++) {
                            const charT = Math.max(0, Math.min(1, (t * charCount - i) * 2));
                            charAnimations.push({
                                opacity: charT,
                                rotation: (1 - charT) * 360,
                                scale: 0.5 + charT * 0.5,
                                offsetX: 0,
                                offsetY: 0
                            });
                        }
                    }
                    break;
                case 'cursorReveal':
                    // カーソルが動いて文字を表示
                    if (obj.chars && charCount > 0) {
                        charAnimations = [];
                        const cursorPos = t * charCount;
                        for (let i = 0; i < charCount; i++) {
                            const visible = i < cursorPos;
                            const isCursor = Math.floor(cursorPos) === i;
                            charAnimations.push({
                                opacity: visible ? 1 : 0,
                                rotation: 0,
                                scale: 1,
                                offsetX: 0,
                                offsetY: 0,
                                showCursor: isCursor && t < 1
                            });
                        }
                    }
                    break;
                case 'zoomIn':
                    // ズームインしてドン！
                    if (obj.chars && charCount > 0) {
                        charAnimations = [];
                        for (let i = 0; i < charCount; i++) {
                            const charT = Math.max(0, Math.min(1, (t * charCount - i) * 1.5));
                            // バウンス効果
                            let scale = 1;
                            if (charT < 0.6) {
                                scale = 3 - charT * 3.33;  // 3 -> 1
                            } else if (charT < 0.8) {
                                scale = 1 + (charT - 0.6) * 1.5;  // 1 -> 1.3
                            } else {
                                scale = 1.3 - (charT - 0.8) * 1.5;  // 1.3 -> 1
                            }
                            charAnimations.push({
                                opacity: charT > 0 ? 1 : 0,
                                rotation: 0,
                                scale: scale,
                                offsetX: 0,
                                offsetY: 0
                            });
                        }
                    }
                    break;
                case 'splitMerge':
                    // 上下に分割して合体
                    if (obj.chars && charCount > 0) {
                        charAnimations = [];
                        for (let i = 0; i < charCount; i++) {
                            const charT = Math.max(0, Math.min(1, (t * charCount - i) * 2));
                            const offset = (1 - charT) * 50;
                            charAnimations.push({
                                opacity: 1,
                                rotation: 0,
                                scale: 1,
                                offsetX: 0,
                                offsetY: 0,
                                splitTop: -offset,
                                splitBottom: offset
                            });
                        }
                    }
                    break;
                case 'slot':
                    // スロットのように縦スクロールして左から順番に止まる
                    if (obj.chars && charCount > 0) {
                        charAnimations = [];
                        for (let i = 0; i < charCount; i++) {
                            // 左の文字から順番に止まる（各文字に遅延）
                            const stopDelay = i * (0.8 / charCount);  // 全体の80%の時間で順番に止まる
                            const charT = Math.max(0, Math.min(1, (t - stopDelay) / (1 - stopDelay)));

                            // スクロール効果（上から下へ流れる）
                            let slotOffset = 0;
                            if (charT < 1) {
                                // 高速スクロール中
                                const scrollSpeed = 8;  // スクロール速度
                                const phase = (1 - charT) * scrollSpeed * Math.PI * 2;
                                // サイン波で上下にスクロール（上から下へ流れるように見える）
                                slotOffset = Math.sin(phase) * 30;

                                // 止まる直前は減速
                                if (charT > 0.7) {
                                    const slowdown = (charT - 0.7) / 0.3;
                                    slotOffset *= (1 - slowdown);
                                }
                            }

                            charAnimations.push({
                                opacity: 1,
                                rotation: 0,
                                scale: 1,
                                offsetX: 0,
                                offsetY: slotOffset,
                                slotEffect: true
                            });
                        }
                    }
                    break;
                case 'rollUp':
                    y = obj.y + canvas.height - t * (canvas.height * 2) * speed;
                    break;
                case 'rollLeft':
                    x = obj.x + canvas.width - t * (canvas.width * 2) * speed;
                    break;
                case 'preset':
                    // プリセートアニメーション
                    if (obj.presetKeyframes && window.AnimationPresets) {
                        const unit = obj.presetUnit || 'all';
                        const stagger = obj.presetStagger || 0;
                        const charCount = obj.chars?.length || 0;

                        if (unit === 'all') {
                            // 全体に適用
                            const values = window.AnimationPresets.interpolate(
                                obj.presetKeyframes,
                                t,
                                anim.easing
                            );

                            // 透明度
                            if (values.opacity !== undefined) {
                                opacity = values.opacity * (obj.opacity || 100);
                            }

                            // 位置（translateX, translateY）
                            if (values.translateX !== undefined) {
                                x = obj.x + values.translateX;
                            }
                            if (values.translateY !== undefined) {
                                y = obj.y + values.translateY;
                            }

                            // スケールと回転は文字単位で適用
                            if (values.scale !== undefined || values.rotate !== undefined) {
                                charAnimations = [];
                                for (let i = 0; i < charCount; i++) {
                                    charAnimations.push({
                                        opacity: 1,
                                        rotation: values.rotate || 0,
                                        scale: values.scale !== undefined ? values.scale : 1,
                                        offsetX: 0,
                                        offsetY: 0
                                    });
                                }
                            }
                        } else if (unit === 'character' && obj.chars) {
                            // 文字単位で適用（stagger付き）
                            charAnimations = [];
                            const staggerDelay = (stagger / 1000) / duration;  // 秒単位に変換

                            for (let i = 0; i < charCount; i++) {
                                // 各文字の開始タイミングを遅延
                                const charDelay = i * staggerDelay;
                                const charT = Math.max(0, Math.min(1, (t - charDelay) / (1 - charDelay * charCount)));

                                const values = window.AnimationPresets.interpolate(
                                    obj.presetKeyframes,
                                    charT,
                                    anim.easing
                                );

                                charAnimations.push({
                                    opacity: values.opacity !== undefined ? values.opacity : 1,
                                    rotation: values.rotate || 0,
                                    scale: values.scale !== undefined ? values.scale : 1,
                                    offsetX: values.translateX || 0,
                                    offsetY: values.translateY || 0
                                });
                            }
                        } else if (unit === 'word' && obj.chars) {
                            // 単語単位で適用（簡易実装：スペースで区切る）
                            charAnimations = [];
                            let wordIndex = 0;
                            const staggerDelay = (stagger / 1000) / duration;

                            for (let i = 0; i < charCount; i++) {
                                // スペースまたは句読点で単語を区切る
                                if (i > 0 && (obj.chars[i-1].char === ' ' || obj.chars[i-1].char === '　')) {
                                    wordIndex++;
                                }

                                const wordDelay = wordIndex * staggerDelay;
                                const wordT = Math.max(0, Math.min(1, (t - wordDelay) / Math.max(0.01, 1 - wordDelay)));

                                const values = window.AnimationPresets.interpolate(
                                    obj.presetKeyframes,
                                    wordT,
                                    anim.easing
                                );

                                charAnimations.push({
                                    opacity: values.opacity !== undefined ? values.opacity : 1,
                                    rotation: values.rotate || 0,
                                    scale: values.scale !== undefined ? values.scale : 1,
                                    offsetX: values.translateX || 0,
                                    offsetY: values.translateY || 0
                                });
                            }
                        }
                    }
                    break;
            }

            return { opacity, x, y, visibleChars, charAnimations };
        }

        // 連番PNGエクスポート
        async function exportSequencePNG() {
            const fps = parseInt(document.getElementById('exportFps').value) || 30;
            const duration = parseFloat(document.getElementById('exportDuration').value) || 3;
            const totalFrames = Math.ceil(fps * duration);

            // 状態を保存
            const wasPlaying = isPlaying;
            if (isPlaying) toggleAnimation();
            const safeMarginCheckbox = document.getElementById('safeMarginEnabled');
            const wasEnabled = safeMarginCheckbox.checked;
            safeMarginCheckbox.checked = false;
            exportingTransparent = document.getElementById('exportTransparent').checked;
            const prevSelectedIds = [...selectedObjIds];
            selectedObjId = null;
            selectedObjIds = [];

            // 進捗表示
            const progress = document.createElement('div');
            progress.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:#333;color:#fff;padding:20px;border-radius:8px;z-index:10000;';
            progress.innerHTML = `<div>連番PNGエクスポート中...</div><div id="exportProgress">0/${totalFrames}</div>`;
            document.body.appendChild(progress);

            // ZIPファイルを作成（JSZipがなければ個別ダウンロード）
            const frames = [];

            for (let i = 0; i < totalFrames; i++) {
                animationTime = (i / fps);
                render();

                const dataUrl = canvas.toDataURL('image/png');
                const frameNum = String(i).padStart(5, '0');
                frames.push({ name: `frame_${frameNum}.png`, data: dataUrl });

                document.getElementById('exportProgress').textContent = `${i + 1}/${totalFrames}`;
                await new Promise(r => setTimeout(r, 10)); // UIを更新
            }

            // ZIPファイルを作成してダウンロード
            progress.innerHTML = `<div>ZIPファイル作成中...</div><div>お待ちください</div>`;

            const zip = new JSZip();
            for (const frame of frames) {
                // data URLからbase64部分を抽出
                const base64Data = frame.data.split(',')[1];
                zip.file(frame.name, base64Data, { base64: true });
            }

            // ZIPファイルを生成してダウンロード
            const blob = await zip.generateAsync({ type: 'blob' });
            const link = document.createElement('a');
            link.download = `telop_sequence_${totalFrames}frames.zip`;
            link.href = URL.createObjectURL(blob);
            link.click();
            URL.revokeObjectURL(link.href);

            // 状態を復元
            animationTime = 0;
            exportingTransparent = false;
            selectedObjId = prevSelectedIds.length > 0 ? prevSelectedIds[prevSelectedIds.length - 1] : null;
            selectedObjIds = prevSelectedIds;
            safeMarginCheckbox.checked = wasEnabled;
            render();
            document.body.removeChild(progress);
        }

        // GIFエクスポート（簡易版）
        async function exportGIF() {
            const fps = parseInt(document.getElementById('exportFps').value) || 30;
            const duration = parseFloat(document.getElementById('exportDuration').value) || 3;
            const totalFrames = Math.ceil(fps * duration);

            // 状態を保存
            if (isPlaying) toggleAnimation();
            const safeMarginCheckbox = document.getElementById('safeMarginEnabled');
            const wasEnabled = safeMarginCheckbox.checked;
            safeMarginCheckbox.checked = false;
            exportingTransparent = document.getElementById('exportTransparent').checked;
            const prevSelectedIds = [...selectedObjIds];
            selectedObjId = null;
            selectedObjIds = [];

            // 進捗表示
            const progress = document.createElement('div');
            progress.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:#333;color:#fff;padding:20px;border-radius:8px;z-index:10000;';
            progress.innerHTML = `<div>GIFエクスポート中...</div><div id="gifProgress">フレーム生成: 0/${totalFrames}</div>`;
            document.body.appendChild(progress);

            // 解像度を下げる（GIF用）
            const scale = Math.min(1, 640 / canvas.width);
            const gifWidth = Math.floor(canvas.width * scale);
            const gifHeight = Math.floor(canvas.height * scale);

            // 一時キャンバス
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = gifWidth;
            tempCanvas.height = gifHeight;
            const tempCtx = tempCanvas.getContext('2d');

            // フレームを収集
            const frames = [];
            for (let i = 0; i < totalFrames; i++) {
                animationTime = (i / fps);
                render();

                tempCtx.drawImage(canvas, 0, 0, gifWidth, gifHeight);
                const imageData = tempCtx.getImageData(0, 0, gifWidth, gifHeight);
                frames.push(imageData);

                document.getElementById('gifProgress').textContent = `フレーム生成: ${i + 1}/${totalFrames}`;
                await new Promise(r => setTimeout(r, 10));
            }

            // GIFエンコード
            document.getElementById('gifProgress').textContent = 'GIFエンコード中...';
            await new Promise(r => setTimeout(r, 100));

            try {
                const gif = encodeGIF(frames, gifWidth, gifHeight, Math.round(1000 / fps));

                // ダウンロード
                const blob = new Blob([gif], { type: 'image/gif' });
                const link = document.createElement('a');
                link.download = `telop_${Date.now()}.gif`;
                link.href = URL.createObjectURL(blob);
                link.click();
            } catch (e) {
                alert('GIFエンコードに失敗しました: ' + e.message);
            }

            // 状態を復元
            animationTime = 0;
            exportingTransparent = false;
            selectedObjId = prevSelectedIds.length > 0 ? prevSelectedIds[prevSelectedIds.length - 1] : null;
            selectedObjIds = prevSelectedIds;
            safeMarginCheckbox.checked = wasEnabled;
            render();
            document.body.removeChild(progress);
        }

        // WebMエクスポート（透過対応）
        async function exportWebM() {
            const fps = parseInt(document.getElementById('exportFps').value) || 30;
            const duration = parseFloat(document.getElementById('exportDuration').value) || 3;
            const transparent = document.getElementById('exportTransparent').checked;

            // VP9コーデック（透過性サポート）を確認
            const mimeType = 'video/webm;codecs=vp9';
            if (!MediaRecorder.isTypeSupported(mimeType)) {
                alert('お使いのブラウザはWebM(VP9)エクスポートに対応していません。\nChrome/Edgeの最新版をご利用ください。');
                return;
            }

            // 状態を保存
            if (isPlaying) toggleAnimation();
            const safeMarginCheckbox = document.getElementById('safeMarginEnabled');
            const wasEnabled = safeMarginCheckbox.checked;
            safeMarginCheckbox.checked = false;
            const prevExportingTransparent = exportingTransparent;
            exportingTransparent = transparent;
            const prevSelectedIds = [...selectedObjIds];
            selectedObjId = null;
            selectedObjIds = [];

            // 進捗表示
            const progress = document.createElement('div');
            progress.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:#333;color:#fff;padding:20px;border-radius:8px;z-index:10000;min-width:250px;text-align:center;';
            progress.innerHTML = `<div style="margin-bottom:10px;">WebMエクスポート中...</div><div id="webmProgress">準備中...</div>`;
            document.body.appendChild(progress);

            try {
                // canvasからMediaStreamを取得
                const stream = canvas.captureStream(fps);

                // MediaRecorderを設定
                const chunks = [];
                const recorder = new MediaRecorder(stream, {
                    mimeType: mimeType,
                    videoBitsPerSecond: 5000000 // 5Mbps
                });

                recorder.ondataavailable = (e) => {
                    if (e.data.size > 0) {
                        chunks.push(e.data);
                    }
                };

                recorder.onstop = () => {
                    const blob = new Blob(chunks, { type: mimeType });
                    const link = document.createElement('a');
                    link.download = `telop_${Date.now()}.webm`;
                    link.href = URL.createObjectURL(blob);
                    link.click();

                    // 状態を復元
                    animationTime = 0;
                    exportingTransparent = prevExportingTransparent;
                    selectedObjId = prevSelectedIds.length > 0 ? prevSelectedIds[prevSelectedIds.length - 1] : null;
                    selectedObjIds = prevSelectedIds;
                    safeMarginCheckbox.checked = wasEnabled;
                    render();
                    document.body.removeChild(progress);
                };

                // 録画開始
                recorder.start();
                document.getElementById('webmProgress').textContent = '録画中...';

                // アニメーションをループ
                const startTime = performance.now();
                const frameInterval = 1000 / fps;
                let frameCount = 0;
                const totalFrames = Math.ceil(fps * duration);

                const animate = () => {
                    const elapsed = (performance.now() - startTime) / 1000;

                    if (elapsed >= duration) {
                        // 録画終了
                        recorder.stop();
                        document.getElementById('webmProgress').textContent = 'エンコード中...';
                        return;
                    }

                    animationTime = elapsed;
                    render();
                    frameCount++;
                    document.getElementById('webmProgress').textContent = `録画中: ${frameCount}/${totalFrames} フレーム`;

                    // 次のフレームまで待機
                    setTimeout(animate, frameInterval);
                };

                animate();

            } catch (e) {
                alert('WebMエクスポートに失敗しました: ' + e.message);
                // 状態を復元
                animationTime = 0;
                exportingTransparent = prevExportingTransparent;
                selectedObjId = prevSelectedIds.length > 0 ? prevSelectedIds[prevSelectedIds.length - 1] : null;
                selectedObjIds = prevSelectedIds;
                safeMarginCheckbox.checked = wasEnabled;
                render();
                document.body.removeChild(progress);
            }
        }

        // 簡易GIFエンコーダー
        function encodeGIF(frames, width, height, delay) {
            const out = [];

            // GIF Header
            out.push(0x47, 0x49, 0x46, 0x38, 0x39, 0x61); // GIF89a

            // Logical Screen Descriptor
            out.push(width & 0xFF, (width >> 8) & 0xFF);
            out.push(height & 0xFF, (height >> 8) & 0xFF);
            out.push(0xF7, 0x00, 0x00); // Global color table, 256 colors

            // Global Color Table (256 colors)
            for (let i = 0; i < 256; i++) {
                const r = (i >> 5) * 36;
                const g = ((i >> 2) & 7) * 36;
                const b = (i & 3) * 85;
                out.push(r, g, b);
            }

            // Netscape Extension for looping
            out.push(0x21, 0xFF, 0x0B);
            out.push(0x4E, 0x45, 0x54, 0x53, 0x43, 0x41, 0x50, 0x45, 0x32, 0x2E, 0x30); // NETSCAPE2.0
            out.push(0x03, 0x01, 0x00, 0x00, 0x00);

            // Frames
            for (const frame of frames) {
                // Graphic Control Extension
                out.push(0x21, 0xF9, 0x04);
                out.push(0x04); // Disposal: restore to background
                out.push((delay / 10) & 0xFF, ((delay / 10) >> 8) & 0xFF);
                out.push(0x00, 0x00);

                // Image Descriptor
                out.push(0x2C);
                out.push(0x00, 0x00, 0x00, 0x00); // Position
                out.push(width & 0xFF, (width >> 8) & 0xFF);
                out.push(height & 0xFF, (height >> 8) & 0xFF);
                out.push(0x00); // No local color table

                // Image Data (LZW compressed)
                const pixels = [];
                for (let i = 0; i < frame.data.length; i += 4) {
                    const r = frame.data[i];
                    const g = frame.data[i + 1];
                    const b = frame.data[i + 2];
                    // Convert to 8-bit palette index
                    const index = ((r >> 5) << 5) | ((g >> 5) << 2) | (b >> 6);
                    pixels.push(index);
                }

                // LZW encode
                const lzwData = lzwEncode(pixels, 8);
                out.push(8); // LZW minimum code size

                // Output in sub-blocks
                let pos = 0;
                while (pos < lzwData.length) {
                    const size = Math.min(255, lzwData.length - pos);
                    out.push(size);
                    for (let i = 0; i < size; i++) {
                        out.push(lzwData[pos++]);
                    }
                }
                out.push(0x00); // Block terminator
            }

            // Trailer
            out.push(0x3B);

            return new Uint8Array(out);
        }

        // LZW圧縮
        function lzwEncode(pixels, minCodeSize) {
            const clearCode = 1 << minCodeSize;
            const eoiCode = clearCode + 1;
            let codeSize = minCodeSize + 1;
            let nextCode = eoiCode + 1;
            const maxCode = 4095;

            const dict = new Map();
            for (let i = 0; i < clearCode; i++) {
                dict.set(String.fromCharCode(i), i);
            }

            const out = [];
            let bits = 0;
            let bitCount = 0;

            function writeBits(code) {
                bits |= (code << bitCount);
                bitCount += codeSize;
                while (bitCount >= 8) {
                    out.push(bits & 0xFF);
                    bits >>= 8;
                    bitCount -= 8;
                }
            }

            writeBits(clearCode);

            let current = String.fromCharCode(pixels[0]);
            for (let i = 1; i < pixels.length; i++) {
                const c = String.fromCharCode(pixels[i]);
                const combined = current + c;

                if (dict.has(combined)) {
                    current = combined;
                } else {
                    writeBits(dict.get(current));

                    if (nextCode <= maxCode) {
                        dict.set(combined, nextCode++);
                        if (nextCode > (1 << codeSize) && codeSize < 12) {
                            codeSize++;
                        }
                    }

                    current = c;
                }
            }

            writeBits(dict.get(current));
            writeBits(eoiCode);

            if (bitCount > 0) {
                out.push(bits & 0xFF);
            }

            return out;
        }

        function saveProject() {
            // .telop形式でプロジェクトを保存
            const project = {
                version: '4.0',  // 新しいバージョン
                fileType: 'telop',
                metadata: {
                    createdAt: new Date().toISOString(),
                    appVersion: '1.0.0'
                },
                canvas: {
                    width: canvas.width,
                    height: canvas.height,
                    bgColor: canvasBgColor,
                    bgOpacity: canvasBgOpacity,
                    bgImage: bgImage  // base64またはnull
                },
                objects: JSON.parse(JSON.stringify(textObjects)),  // Deep copy
                animation: {
                    totalDuration: totalDuration,
                    currentTime: animationTime
                },
                // 下位互換性のため既存の形式も保持
                canvases: canvases.length > 0 ? canvases : [{
                    id: Date.now(),
                    name: 'Main',
                    objects: textObjects,
                    resolution: document.getElementById('resolution').value,
                    bgColor: canvasBgColor,
                    bgOpacity: canvasBgOpacity
                }],
                activeCanvasId: activeCanvasId || (canvases.length > 0 ? canvases[0].id : Date.now())
            };

            const jsonStr = JSON.stringify(project, null, 2);  // Pretty print
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const link = document.createElement('a');
            link.download = `telop_project_${Date.now()}.telop`;
            link.href = URL.createObjectURL(blob);
            link.click();
        }

        function loadProject() { document.getElementById('fileInput').click(); }

        // PRTL書き出し機能
        function exportPRTL() {
            exitEditMode(); selectedObjId = null; selectedObjIds = [];

            // ファイル名を入力
            const fileName = prompt('PRTL書き出しファイル名を入力してください（.prtl は自動で付きます）', 'title');
            if (!fileName) return;

            // PRTLGeneratorを使用して正しいPRTL構造を生成
            const generator = new PRTLGenerator();
            const canvasData = {
                resolution: `${canvas.width}x${canvas.height}`,
                objects: textObjects
            };
            const prtlXML = generator.generatePRTL(canvasData);

            // UTF-8（BOMなし）でエンコード
            // 参考PRTLファイルはUTF-8（BOMなし）で保存されているが、XMLヘッダーではUTF-16と宣言される
            const encoder = new TextEncoder(); // UTF-8エンコーディング
            const utf8Array = encoder.encode(prtlXML);

            const blob = new Blob([utf8Array], { type: 'application/octet-stream' });
            const link = document.createElement('a');
            link.download = `${fileName}.prtl`;
            link.href = URL.createObjectURL(blob);
            link.click();

            alert('PRTLファイルを書き出しました');
        }

        function escapeXml(unsafe) {
            if (!unsafe) return '';
            return unsafe.replace(/[<>&'"]/g, function (c) {
                switch (c) {
                    case '<': return '&lt;';
                    case '>': return '&gt;';
                    case '&': return '&amp;';
                    case '\'': return '&apos;';
                    case '"': return '&quot;';
                }
            });
        }

        // PRTL読み込み機能
        function importPRTL() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.prtl';
            input.onchange = handlePRTLLoad;
            input.click();
        }

        function handlePRTLLoad(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (ev) => {
                try {
                    // UTF-8からテキストに変換
                    // 参考PRTLファイルは実際にUTF-8（BOMなし）でエンコードされている
                    const arrayBuffer = ev.target.result;
                    const decoder = new TextDecoder('utf-8');
                    let xmlText = decoder.decode(arrayBuffer);

                    // BOMがある場合は除去（念のため）
                    if (xmlText.charCodeAt(0) === 0xFEFF) {
                        xmlText = xmlText.substring(1);
                    }

                    // XMLをパース
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(xmlText, 'text/xml');

                    // エラーチェック
                    if (xmlDoc.querySelector('parsererror')) {
                        throw new Error('XMLパースエラー');
                    }

                    // テキストオブジェクトを抽出（簡易版）
                    parsePRTLAndLoad(xmlDoc);

                    alert('PRTLファイルを読み込みました');
                    render();
                } catch (err) {
                    alert('エラー: ' + err.message);
                    console.error(err);
                }
            };
            reader.readAsArrayBuffer(file);
            e.target.value = '';
        }

        function parsePRTLAndLoad(xmlDoc) {
            // 簡易版: TextObjectsから読み込み
            const textObjs = xmlDoc.querySelectorAll('TextObject');

            if (textObjs.length > 0) {
                // 既存のテキストオブジェクトをクリア
                textObjects = [];

                textObjs.forEach((textObj) => {
                    const text = textObj.querySelector('text')?.textContent || '';
                    const x = parseFloat(textObj.querySelector('x')?.textContent) || canvas.width / 2;
                    const y = parseFloat(textObj.querySelector('y')?.textContent) || canvas.height / 2;
                    const fontSize = parseFloat(textObj.querySelector('fontSize')?.textContent) || 72;
                    const fontFamily = textObj.querySelector('fontFamily')?.textContent || 'Yu Gothic UI';
                    const color = textObj.querySelector('color')?.textContent || '#ffffff';

                    // 新しいテキストオブジェクトを作成
                    const obj = {
                        id: Date.now() + Math.random(),
                        type: 'text',
                        x: x,
                        y: y,
                        rotation: 0,
                        vertical: false,
                        textAlign: 'center',
                        opacity: 100,
                        animIn: 'none',
                        animInDelay: 0,
                        animInDuration: 0.5,
                        animOut: 'none',
                        animOutDelay: 0,
                        animOutDuration: 0.5,
                        chars: []
                    };

                    // 文字配列を作成
                    for (let i = 0; i < text.length; i++) {
                        obj.chars.push({
                            char: text[i],
                            fontFamily: fontFamily,
                            fontSize: fontSize,
                            color: color,
                            bold: true,
                            italic: false,
                            fillType: 'solid',
                            scaleX: 100,
                            kerning: 0,
                            tracking: 0,
                            baseline: 0,
                            slant: 0,
                            opacity: 100,
                            smallCaps: false,
                            smallCapsSize: 70,
                            strokes: [{ enabled: true, color: '#000000', width: 4, opacity: 100, type: 'edge', join: 'round' }],
                            shadow: { enabled: false, color: '#000000', blur: 10, offsetX: 5, offsetY: 5, opacity: 100 },
                            gloss: { enabled: false, color: '#ffffff', opacity: 50, height: 50, curve: 50 }
                        });
                    }

                    textObjects.push(obj);
                });

                saveState();
            }
        }

        // MOGRT書き出し機能（プレースホルダー）
        function exportMOGRT() {
            alert('MOGRT書き出し機能は現在開発中です。\nMOGRTはAdobe After Effectsの複雑なフォーマットのため、完全な実装には時間が必要です。\n\n代替案:\n1. PRTLとして書き出してPremiere Proで使用\n2. PNG/GIF/WebMとして書き出して使用');
        }

        // バッチPRTL書き出し機能（PRTL形式のみ、ZIP）
        async function batchExportPRTLOnly() {
            if (canvases.length === 0) {
                alert('キャンバスがありません');
                return;
            }

            exitEditMode(); selectedObjId = null; selectedObjIds = [];

            // ユーザーにZIPファイル名を入力してもらう
            const zipName = prompt('ZIPファイル名を入力してください', 'canvases-prtl');
            if (!zipName) return;

            // 現在のキャンバスを保存
            const currentCanvas = {
                objects: JSON.parse(JSON.stringify(textObjects)),
                bgColor: canvasBgColor,
                bgOpacity: canvasBgOpacity,
                bgImage: bgImage
            };

            const generator = new PRTLGenerator();
            const zip = new JSZip();

            // 各キャンバスを処理してZIPに追加
            for (let idx = 0; idx < canvases.length; idx++) {
                const cvs = canvases[idx];

                // キャンバスを切り替え
                textObjects = JSON.parse(JSON.stringify(cvs.objects || []));
                canvasBgColor = cvs.bgColor || '#1e1e1e';
                canvasBgOpacity = cvs.bgOpacity || 100;
                bgImage = cvs.bgImage || null;

                // PRTL生成
                const canvasData = {
                    resolution: `${canvas.width}x${canvas.height}`,
                    objects: textObjects
                };
                const prtlXML = generator.generatePRTL(canvasData);
                const encoder = new TextEncoder();
                const utf8Array = encoder.encode(prtlXML);

                const paddedIdx = String(idx).padStart(3, '0');
                zip.file(`${zipName}_${paddedIdx}.prtl`, utf8Array);

                // 進捗表示（10個ごと）
                if ((idx + 1) % 10 === 0 || idx === canvases.length - 1) {
                    console.log(`PRTL生成中: ${idx + 1}/${canvases.length}`);
                }
            }

            // ZIP生成とダウンロード
            const zipBlob = await zip.generateAsync({ type: 'blob' });
            const link = document.createElement('a');
            link.download = `${zipName}.zip`;
            link.href = URL.createObjectURL(zipBlob);
            link.click();
            setTimeout(() => URL.revokeObjectURL(link.href), 100);

            // 元のキャンバスに戻す
            textObjects = currentCanvas.objects;
            canvasBgColor = currentCanvas.bgColor;
            canvasBgOpacity = currentCanvas.bgOpacity;
            bgImage = currentCanvas.bgImage;
            render();

            alert(`${canvases.length}個のPRTLファイルをZIPで書き出しました`);
        }

        // バッチPNG書き出し機能（PNG形式のみ、ZIP）
        async function batchExportPNGOnly() {
            if (canvases.length === 0) {
                alert('キャンバスがありません');
                return;
            }

            exitEditMode(); selectedObjId = null; selectedObjIds = [];

            // ユーザーにZIPファイル名を入力してもらう
            const zipName = prompt('ZIPファイル名を入力してください', 'canvases-png');
            if (!zipName) return;

            // 現在のキャンバスを保存
            const currentCanvas = {
                objects: JSON.parse(JSON.stringify(textObjects)),
                bgColor: canvasBgColor,
                bgOpacity: canvasBgOpacity,
                bgImage: bgImage
            };

            const zip = new JSZip();

            // 各キャンバスを処理してZIPに追加
            for (let idx = 0; idx < canvases.length; idx++) {
                const cvs = canvases[idx];

                // キャンバスを切り替え
                textObjects = JSON.parse(JSON.stringify(cvs.objects || []));
                canvasBgColor = cvs.bgColor || '#1e1e1e';
                canvasBgOpacity = cvs.bgOpacity || 100;
                bgImage = cvs.bgImage || null;

                // レンダリング
                render();

                // PNGをBlobとして取得
                const blob = await new Promise(resolve => {
                    canvas.toBlob(resolve, 'image/png');
                });

                const paddedIdx = String(idx).padStart(3, '0');
                zip.file(`${zipName}_${paddedIdx}.png`, blob);

                // 進捗表示（10個ごと）
                if ((idx + 1) % 10 === 0 || idx === canvases.length - 1) {
                    console.log(`PNG生成中: ${idx + 1}/${canvases.length}`);
                }
            }

            // ZIP生成とダウンロード
            const zipBlob = await zip.generateAsync({ type: 'blob' });
            const link = document.createElement('a');
            link.download = `${zipName}.zip`;
            link.href = URL.createObjectURL(zipBlob);
            link.click();
            setTimeout(() => URL.revokeObjectURL(link.href), 100);

            // 元のキャンバスに戻す
            textObjects = currentCanvas.objects;
            canvasBgColor = currentCanvas.bgColor;
            canvasBgOpacity = currentCanvas.bgOpacity;
            bgImage = currentCanvas.bgImage;
            render();

            alert(`${canvases.length}個のPNGファイルをZIPで書き出しました`);
        }

        // PRSL読み込み機能
        let loadedPRSLStyles = [];
        let selectedPRSLIndex = -1;

        function importPRSL() { document.getElementById('prslInput').click(); }

        function handlePRSLLoad(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (ev) => {
                try {
                    // UTF-8からテキストに変換
                    // 参考PRTLファイルは実際にUTF-8（BOMなし）でエンコードされている
                    const arrayBuffer = ev.target.result;
                    const decoder = new TextDecoder('utf-8');
                    let xmlText = decoder.decode(arrayBuffer);

                    // BOMがある場合は除去（念のため）
                    if (xmlText.charCodeAt(0) === 0xFEFF) {
                        xmlText = xmlText.substring(1);
                    }

                    // XMLをパース
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(xmlText, 'text/xml');

                    // スタイルブロックを抽出
                    const styleBlocks = xmlDoc.querySelectorAll('styleblock');
                    loadedPRSLStyles = [];

                    styleBlocks.forEach(block => {
                        const style = parsePRSLStyle(block);
                        if (style) loadedPRSLStyles.push(style);
                    });

                    // UIにスタイル一覧を表示
                    selectedPRSLIndex = -1;
                    displayPRSLStyles();
                    document.getElementById('prslStatus').textContent = `${loadedPRSLStyles.length} スタイルを読み込みました`;
                } catch (err) {
                    document.getElementById('prslStatus').textContent = 'エラー: ' + err.message;
                    console.error(err);
                }
            };
            reader.readAsArrayBuffer(file);
            e.target.value = '';
        }

        function parsePRSLStyle(block) {
            const name = block.getAttribute('name') || 'Unknown';

            // フォント情報
            const fontFamily = block.querySelector('font > family')?.textContent || 'Yu Gothic UI';
            const fontSize = parseFloat(block.querySelector('text_specification > size')?.textContent) || 72;
            const fontStyle = block.querySelector('font > style')?.textContent || '';
            const isBold = fontStyle.toLowerCase().includes('bold') ||
                           block.querySelector('text_specification > bold')?.textContent === 'true';
            const isItalic = fontStyle.toLowerCase().includes('italic') ||
                             block.querySelector('text_specification > italic')?.textContent === 'true';

            // 字間・行間・その他
            const tracking = parseFloat(block.querySelector('text_specification > tracking')?.textContent) || 0;
            const leading = parseFloat(block.querySelector('text_specification > leading')?.textContent) || 0;
            const slant = parseFloat(block.querySelector('text_specification > slant')?.textContent) || 0;
            const scaleX = parseFloat(block.querySelector('text_specification > aspect')?.textContent) || 100;

            // ヘルパー関数: RGBAカラーを抽出
            function extractColor(elem) {
                if (!elem) return null;
                const r = Math.round((parseFloat(elem.querySelector('red')?.textContent) || 0) * 255);
                const g = Math.round((parseFloat(elem.querySelector('green')?.textContent) || 0) * 255);
                const b = Math.round((parseFloat(elem.querySelector('blue')?.textContent) || 0) * 255);
                const a = parseFloat(elem.querySelector('alpha')?.textContent);
                return {
                    hex: `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`,
                    opacity: isNaN(a) ? 100 : Math.round(a * 100)
                };
            }

            // 塗り情報を取得
            let fillColor = '#ffffff';
            let fillOpacity = 100;
            let gradient = null;

            const colouring = block.querySelector('face > shader > colouring');
            if (colouring) {
                // four_colour_ramp（上下2色グラデーション）
                const fourColourRamp = colouring.querySelector('four_colour_ramp');
                if (fourColourRamp) {
                    // 上側の色（top_left）と下側の色（bottom_left）を取得
                    const topLeft = fourColourRamp.querySelector('top_left');
                    const bottomLeft = fourColourRamp.querySelector('bottom_left');

                    const topColor = topLeft ? extractColor(topLeft) : null;
                    const bottomColor = bottomLeft ? extractColor(bottomLeft) : null;

                    if (topColor && bottomColor && topColor.hex && bottomColor.hex) {
                        gradient = {
                            type: 'linear',
                            angle: 90, // 上から下へ（90度 = 垂直方向）
                            stops: [
                                { position: 0, color: topColor.hex, opacity: topColor.opacity },
                                { position: 1, color: bottomColor.hex, opacity: bottomColor.opacity }
                            ]
                        };
                        fillColor = topColor.hex;
                    }
                }

                // two_colour_ramp（2色グラデーション）
                const twoColourRamp = colouring.querySelector('two_colour_ramp');
                if (!gradient && twoColourRamp) {
                    const top = twoColourRamp.querySelector('top');
                    const bottom = twoColourRamp.querySelector('bottom');

                    const topColor = top ? extractColor(top) : null;
                    const bottomColor = bottom ? extractColor(bottom) : null;

                    if (topColor && bottomColor && topColor.hex && bottomColor.hex) {
                        gradient = {
                            type: 'linear',
                            angle: 90, // 上から下へ（90度 = 垂直方向）
                            stops: [
                                { position: 0, color: topColor.hex, opacity: topColor.opacity },
                                { position: 1, color: bottomColor.hex, opacity: bottomColor.opacity }
                            ]
                        };
                        fillColor = topColor.hex;
                    }
                }

                // グラデーションチェック（linear_gradient）
                const linearGrad = colouring.querySelector('linear_gradient');
                if (linearGrad) {
                    const angle = parseFloat(linearGrad.querySelector('angle')?.textContent) || 0;
                    const stops = [];

                    // カラーストップを取得
                    linearGrad.querySelectorAll('stop').forEach(stop => {
                        const pos = parseFloat(stop.querySelector('position')?.textContent) || 0;
                        const colorElem = stop.querySelector('all');
                        if (colorElem) {
                            const col = extractColor(colorElem);
                            stops.push({ position: pos, color: col.hex, opacity: col.opacity });
                        }
                    });

                    // フォールバック: begin/end カラー
                    if (stops.length === 0) {
                        const beginColor = extractColor(linearGrad.querySelector('begin > all'));
                        const endColor = extractColor(linearGrad.querySelector('end > all'));
                        if (beginColor) stops.push({ position: 0, color: beginColor.hex, opacity: beginColor.opacity });
                        if (endColor) stops.push({ position: 1, color: endColor.hex, opacity: endColor.opacity });
                    }

                    if (stops.length >= 2) {
                        gradient = {
                            type: 'linear',
                            angle: angle,
                            stops: stops
                        };
                        fillColor = stops[0].color;
                    }
                }

                // グラデーションチェック（radial_gradient / four_colour_gradient）
                const radialGrad = colouring.querySelector('radial_gradient, four_colour_gradient');
                if (!gradient && radialGrad) {
                    const stops = [];
                    radialGrad.querySelectorAll('stop').forEach(stop => {
                        const pos = parseFloat(stop.querySelector('position')?.textContent) || 0;
                        const colorElem = stop.querySelector('all');
                        if (colorElem) {
                            const col = extractColor(colorElem);
                            stops.push({ position: pos, color: col.hex, opacity: col.opacity });
                        }
                    });

                    // フォールバック: begin/end カラー
                    if (stops.length === 0) {
                        const beginColor = extractColor(radialGrad.querySelector('begin > all'));
                        const endColor = extractColor(radialGrad.querySelector('end > all'));
                        if (beginColor) stops.push({ position: 0, color: beginColor.hex, opacity: beginColor.opacity });
                        if (endColor) stops.push({ position: 1, color: endColor.hex, opacity: endColor.opacity });
                    }

                    if (stops.length >= 2) {
                        gradient = {
                            type: 'radial',
                            stops: stops
                        };
                        fillColor = stops[0].color;
                    }
                }

                // ソリッドカラー
                if (!gradient) {
                    const solidColour = colouring.querySelector('solid_colour > all');
                    if (solidColour) {
                        const col = extractColor(solidColour);
                        fillColor = col.hex;
                        fillOpacity = col.opacity;
                    }
                }
            }

            // ストローク（embellishment）- 複数対応
            const strokes = [];
            for (let i = 11; i >= 0; i--) {  // 外側から内側へ（描画順）
                const emb = block.querySelector(`embellishment__${i}, embellishment_${i}`);
                if (!emb) continue;
                const existence = emb.querySelector('existence')?.textContent;
                if (existence !== '3') continue;  // 3 = active

                const embColouring = emb.querySelector('shader > colouring');
                let strokeColor = '#000000';
                let strokeOpacity = 100;
                let strokeGradient = null;

                if (embColouring) {
                    // ストロークの four_colour_ramp
                    const embFourRamp = embColouring.querySelector('four_colour_ramp');
                    if (embFourRamp) {
                        const topLeft = embFourRamp.querySelector('top_left');
                        const bottomLeft = embFourRamp.querySelector('bottom_left');
                        const topColor = topLeft ? extractColor(topLeft) : null;
                        const bottomColor = bottomLeft ? extractColor(bottomLeft) : null;
                        if (topColor && bottomColor && topColor.hex && bottomColor.hex) {
                            strokeGradient = {
                                type: 'linear',
                                angle: 90,
                                stops: [
                                    { position: 0, color: topColor.hex, opacity: topColor.opacity },
                                    { position: 1, color: bottomColor.hex, opacity: bottomColor.opacity }
                                ]
                            };
                            strokeColor = topColor.hex;
                        }
                    }

                    // ストロークの two_colour_ramp
                    const embTwoRamp = embColouring.querySelector('two_colour_ramp');
                    if (!strokeGradient && embTwoRamp) {
                        const top = embTwoRamp.querySelector('top');
                        const bottom = embTwoRamp.querySelector('bottom');
                        const topColor = top ? extractColor(top) : null;
                        const bottomColor = bottom ? extractColor(bottom) : null;
                        if (topColor && bottomColor && topColor.hex && bottomColor.hex) {
                            strokeGradient = {
                                type: 'linear',
                                angle: 90,
                                stops: [
                                    { position: 0, color: topColor.hex, opacity: topColor.opacity },
                                    { position: 1, color: bottomColor.hex, opacity: bottomColor.opacity }
                                ]
                            };
                            strokeColor = topColor.hex;
                        }
                    }

                    // ストロークのlinear_gradient
                    const embLinearGrad = embColouring.querySelector('linear_gradient');
                    if (!strokeGradient && embLinearGrad) {
                        const angle = parseFloat(embLinearGrad.querySelector('angle')?.textContent) || 0;
                        const stops = [];
                        embLinearGrad.querySelectorAll('stop').forEach(stop => {
                            const pos = parseFloat(stop.querySelector('position')?.textContent) || 0;
                            const colorElem = stop.querySelector('all');
                            if (colorElem) {
                                const col = extractColor(colorElem);
                                stops.push({ position: pos, color: col.hex, opacity: col.opacity });
                            }
                        });
                        if (stops.length === 0) {
                            const beginColor = extractColor(embLinearGrad.querySelector('begin > all'));
                            const endColor = extractColor(embLinearGrad.querySelector('end > all'));
                            if (beginColor) stops.push({ position: 0, color: beginColor.hex, opacity: beginColor.opacity });
                            if (endColor) stops.push({ position: 1, color: endColor.hex, opacity: endColor.opacity });
                        }
                        if (stops.length >= 2) {
                            strokeGradient = { type: 'linear', angle: angle, stops: stops };
                            strokeColor = stops[0].color;
                        }
                    }

                    // ソリッドカラー
                    if (!strokeGradient) {
                        const embSolid = embColouring.querySelector('solid_colour > all');
                        if (embSolid) {
                            const col = extractColor(embSolid);
                            strokeColor = col.hex;
                            strokeOpacity = col.opacity;
                        }
                    }
                }

                const width = parseFloat(emb.querySelector('geometry > edge > size')?.textContent) || 20;
                strokes.push({
                    color: strokeColor,
                    width: Math.max(1, Math.round(width / 10)),  // PRSLは10倍スケール
                    opacity: strokeOpacity,
                    gradient: strokeGradient
                });
            }

            // シャドウ
            let shadow = null;
            const shadowElem = block.querySelector('face > shader > shadow');
            if (shadowElem && shadowElem.querySelector('on')?.textContent === 'true') {
                const shadowColour = shadowElem.querySelector('colour');
                if (shadowColour) {
                    const col = extractColor(shadowColour);
                    const distance = parseFloat(shadowElem.querySelector('distance')?.textContent) || 5;
                    const angle = parseFloat(shadowElem.querySelector('angle')?.textContent) || 135;
                    const blur = parseFloat(shadowElem.querySelector('blur')?.textContent) || 0;
                    shadow = {
                        color: col.hex,
                        opacity: col.opacity,
                        distance: distance,
                        angle: angle,
                        blur: blur
                    };
                }
            }

            // 光沢（sheen）
            const sheen = block.querySelector('face > shader > sheen');
            let gloss = null;
            if (sheen && sheen.querySelector('on')?.textContent === 'true') {
                const sheenColour = sheen.querySelector('colour');
                if (sheenColour) {
                    const col = extractColor(sheenColour);
                    gloss = {
                        color: col.hex,
                        opacity: col.opacity,
                        size: parseFloat(sheen.querySelector('size')?.textContent) || 50
                    };
                }
            }

            return { name, fontFamily, fontSize, isBold, isItalic, tracking, leading, slant, scaleX, fillColor, fillOpacity, gradient, strokes, shadow, gloss };
        }

        function displayPRSLStyles() {
            const list = document.getElementById('prslStyleList');
            list.innerHTML = '';

            // グリッドレイアウトで表示
            list.style.cssText = 'display:grid;grid-template-columns:repeat(auto-fill,minmax(80px,1fr));gap:4px;max-height:300px;overflow-y:auto;margin-top:8px;padding:4px;';

            loadedPRSLStyles.forEach((style, i) => {
                const container = document.createElement('div');
                container.style.cssText = 'cursor:pointer;border:2px solid #444;border-radius:3px;overflow:hidden;transition:border-color 0.2s;';
                container.title = `${style.name}\n${style.fontFamily} ${style.fontSize}pt`;
                container.onclick = () => applyPRSLStyle(i);
                container.onmouseenter = () => container.style.borderColor = '#0066cc';
                container.onmouseleave = () => container.style.borderColor = '#444';

                // Canvasでプレビューを描画
                const canvas = document.createElement('canvas');
                canvas.width = 80;
                canvas.height = 60;
                const ctx = canvas.getContext('2d');

                // チェッカーボード背景（透明表示用）
                const checkerSize = 8;
                for (let cy = 0; cy < canvas.height; cy += checkerSize) {
                    for (let cx = 0; cx < canvas.width; cx += checkerSize) {
                        ctx.fillStyle = ((cx + cy) / checkerSize) % 2 === 0 ? '#555' : '#777';
                        ctx.fillRect(cx, cy, checkerSize, checkerSize);
                    }
                }

                // テキスト描画設定
                const previewFontSize = 24;
                const text = 'あa';
                const fontWeight = style.isBold ? 'bold' : 'normal';
                const fontStyleStr = style.isItalic ? 'italic' : 'normal';
                ctx.font = `${fontStyleStr} ${fontWeight} ${previewFontSize}px "${style.fontFamily}", "Yu Gothic UI", sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                const x = canvas.width / 2;
                const y = canvas.height / 2;

                // オフスクリーンキャンバスでテキストを描画（光沢用）
                const offCanvas = document.createElement('canvas');
                offCanvas.width = canvas.width;
                offCanvas.height = canvas.height;
                const offCtx = offCanvas.getContext('2d');
                offCtx.font = ctx.font;
                offCtx.textAlign = 'center';
                offCtx.textBaseline = 'middle';

                // シャドウ描画（メインキャンバスに直接）
                if (style.shadow) {
                    const rad = (style.shadow.angle - 90) * Math.PI / 180;
                    const dist = style.shadow.distance * 0.4;
                    ctx.save();
                    ctx.shadowColor = style.shadow.color;
                    ctx.shadowBlur = style.shadow.blur * 0.5;
                    ctx.shadowOffsetX = Math.cos(rad) * dist;
                    ctx.shadowOffsetY = Math.sin(rad) * dist;
                    ctx.globalAlpha = style.shadow.opacity / 100;
                    ctx.fillStyle = style.shadow.color;
                    ctx.fillText(text, x, y);
                    ctx.restore();
                }

                // ストローク描画（外側から内側へ）
                style.strokes.forEach(stroke => {
                    ctx.save();
                    offCtx.save();
                    ctx.globalAlpha = stroke.opacity / 100;

                    if (stroke.gradient && stroke.gradient.stops.length >= 2) {
                        const grad = createPreviewGradient(ctx, stroke.gradient, x, y - previewFontSize/2, previewFontSize);
                        ctx.strokeStyle = grad;
                        offCtx.strokeStyle = grad;
                    } else {
                        ctx.strokeStyle = stroke.color;
                        offCtx.strokeStyle = stroke.color;
                    }

                    ctx.lineWidth = stroke.width * 0.6;
                    ctx.lineJoin = 'round';
                    ctx.strokeText(text, x, y);
                    offCtx.lineWidth = stroke.width * 0.6;
                    offCtx.lineJoin = 'round';
                    offCtx.strokeText(text, x, y);
                    ctx.restore();
                    offCtx.restore();
                });

                // 塗り描画
                ctx.save();
                offCtx.save();
                ctx.globalAlpha = (style.fillOpacity || 100) / 100;

                if (style.gradient && style.gradient.stops.length >= 2) {
                    const grad = createPreviewGradient(ctx, style.gradient, x, y - previewFontSize/2, previewFontSize);
                    ctx.fillStyle = grad;
                    offCtx.fillStyle = grad;
                } else {
                    ctx.fillStyle = style.fillColor;
                    offCtx.fillStyle = style.fillColor;
                }

                ctx.fillText(text, x, y);
                offCtx.fillText(text, x, y);
                ctx.restore();
                offCtx.restore();

                // 光沢描画（横一線バンド＋ぼかし）
                if (style.gloss) {
                    // Parse color
                    const glossCol = style.gloss.color;
                    const gr = parseInt(glossCol.slice(1, 3), 16);
                    const gg = parseInt(glossCol.slice(3, 5), 16);
                    const gb = parseInt(glossCol.slice(5, 7), 16);
                    const glossOpacity = style.gloss.opacity / 100;

                    // サイズから幅とぼかしを計算
                    const glossWidth = Math.max(2, style.gloss.size * 0.15);
                    const glossBlurSize = Math.max(1, style.gloss.size * 0.1);
                    const totalHeight = glossWidth + glossBlurSize * 2;

                    // 光沢バンドの位置（中央）
                    const glossY = y;

                    // オフスクリーンキャンバスで光沢を適用
                    offCtx.save();
                    offCtx.globalCompositeOperation = 'source-atop';

                    // グラデーションで上下にぼかし
                    const glossGrad = offCtx.createLinearGradient(0, glossY - totalHeight/2, 0, glossY + totalHeight/2);
                    glossGrad.addColorStop(0, `rgba(${gr},${gg},${gb},0)`);
                    const fadeRatio = glossBlurSize / totalHeight;
                    glossGrad.addColorStop(fadeRatio, `rgba(${gr},${gg},${gb},${glossOpacity})`);
                    glossGrad.addColorStop(1 - fadeRatio, `rgba(${gr},${gg},${gb},${glossOpacity})`);
                    glossGrad.addColorStop(1, `rgba(${gr},${gg},${gb},0)`);

                    offCtx.fillStyle = glossGrad;
                    offCtx.fillRect(0, glossY - totalHeight/2, offCanvas.width, totalHeight);
                    offCtx.restore();

                    // メインキャンバスにオフスクリーンの結果を合成
                    ctx.drawImage(offCanvas, 0, 0);
                }

                container.appendChild(canvas);
                list.appendChild(container);
            });
        }

        // プレビュー用グラデーション生成
        function createPreviewGradient(ctx, gradientDef, x, y, height) {
            let grad;
            if (gradientDef.type === 'linear') {
                // 90度 = 垂直（上から下）で主レンダリングと一致
                const angle = (gradientDef.angle || 0) * Math.PI / 180;
                const len = height;
                const dx = Math.cos(angle) * len/2;
                const dy = Math.sin(angle) * len/2;
                grad = ctx.createLinearGradient(
                    x - dx, y + len/2 - dy,
                    x + dx, y + len/2 + dy
                );
            } else {
                grad = ctx.createRadialGradient(x, y + height/2, 0, x, y + height/2, height);
            }

            gradientDef.stops.forEach(stop => {
                grad.addColorStop(stop.position, stop.color);
            });

            return grad;
        }

        function applyPRSLStyle(index) {
            const statusEl = document.getElementById('prslStatus');
            if (!selectedObjId) {
                if (statusEl) statusEl.textContent = 'テキストオブジェクトを選択してください';
                return;
            }
            const obj = textObjects.find(o => o.id === selectedObjId);
            if (!obj || obj.type !== 'text') {
                if (statusEl) statusEl.textContent = 'テキストオブジェクトを選択してください';
                return;
            }

            const style = loadedPRSLStyles[index];
            if (!style) return;

            saveState();

            // 全文字にスタイルを適用
            obj.chars.forEach(c => {
                c.fontFamily = style.fontFamily;
                c.fontSize = style.fontSize;
                c.bold = style.isBold !== false;  // デフォルトはtrue
                c.italic = style.isItalic || false;
                c.opacity = style.fillOpacity || 100;
                c.tracking = style.tracking || 0;
                c.slant = style.slant || 0;
                c.scaleX = style.scaleX || 100;

                // グラデーション/塗り
                if (style.gradient && style.gradient.stops && style.gradient.stops.length >= 2) {
                    c.fillType = style.gradient.type;  // 'linear' or 'radial'
                    c.color = style.gradient.stops[0].color;
                    c.color2 = style.gradient.stops[style.gradient.stops.length - 1].color;
                    c.gradientAngle = style.gradient.angle || 0;
                    c.gradientBlur = 0;

                    // 中間ストップがある場合
                    if (style.gradient.stops.length > 2) {
                        c.gradientStops = style.gradient.stops.map(s => ({
                            color: s.color,
                            pos: s.position * 100,
                            endPos: s.position * 100
                        }));
                    } else {
                        c.gradientStops = [
                            { color: c.color, pos: 0, endPos: 0 },
                            { color: c.color2, pos: 100, endPos: 100 }
                        ];
                    }
                } else {
                    c.fillType = 'solid';
                    c.color = style.fillColor;
                    c.color2 = style.fillColor;
                    c.gradientStops = [
                        { color: style.fillColor, pos: 0, endPos: 0 },
                        { color: style.fillColor, pos: 100, endPos: 100 }
                    ];
                    c.gradientAngle = 0;
                    c.gradientBlur = 0;
                }

                // ストローク
                if (style.strokes && style.strokes.length > 0) {
                    c.strokes = style.strokes.map(s => {
                        const stroke = {
                            enabled: true,
                            type: 'edge',
                            color: s.color,
                            width: s.width,
                            opacity: s.opacity || 100,
                            angle: 45,
                            join: 'round'
                        };
                        // ストロークグラデーション
                        if (s.gradient && s.gradient.stops && s.gradient.stops.length >= 2) {
                            stroke.gradientEnabled = true;
                            stroke.gradientType = s.gradient.type;
                            stroke.color2 = s.gradient.stops[s.gradient.stops.length - 1].color;
                            stroke.gradientAngle = s.gradient.angle || 90;
                            stroke.gradientStops = s.gradient.stops.map(gs => ({
                                color: gs.color,
                                pos: gs.position * 100,
                                endPos: gs.position * 100
                            }));
                        }
                        return stroke;
                    });
                } else {
                    c.strokes = [];
                }

                // シャドウ（個別プロパティとして設定）
                if (style.shadow) {
                    c.shadowEnabled = true;
                    c.shadowColor = style.shadow.color;
                    c.shadowOpacity = style.shadow.opacity;
                    c.shadowDistance = style.shadow.distance;
                    c.shadowAngle = style.shadow.angle;
                    c.shadowBlur = style.shadow.blur;
                    c.shadowSize = 0;
                } else {
                    c.shadowEnabled = false;
                }

                // 光沢（個別プロパティとして設定）
                if (style.gloss) {
                    c.glossEnabled = true;
                    c.glossColor = style.gloss.color;
                    c.glossOpacity = style.gloss.opacity;
                    // PRSLのsizeからwidth/blurを計算（fontSize比率で調整）
                    const sizeRatio = style.gloss.size / 100;
                    c.glossWidth = Math.max(3, style.fontSize * sizeRatio * 0.15);
                    c.glossBlur = Math.max(2, style.fontSize * sizeRatio * 0.1);
                } else {
                    c.glossEnabled = false;
                }
            });

            render();
            updateLayerProps();

            // 選択スタイルをハイライト
            selectedPRSLIndex = index;
            updatePRSLHighlight();

            // 成功メッセージ
            if (statusEl) statusEl.textContent = `スタイル「${style.name}」を適用しました`;
        }

        function updatePRSLHighlight() {
            const list = document.getElementById('prslStyleList');
            if (!list) return;
            Array.from(list.children).forEach((container, i) => {
                if (i === selectedPRSLIndex) {
                    container.style.borderColor = '#0066cc';
                    container.style.boxShadow = '0 0 5px rgba(0,120,212,0.5)';
                } else {
                    container.style.borderColor = '#444';
                    container.style.boxShadow = 'none';
                }
            });
        }

        // 字幕ファイル読み込み機能
        let loadedSubtitles = [];

        // BatchProcessor クラス - SRT/XML パーサー
        const BatchProcessor = {
            // SRTファイルをパース
            parseSRT(text) {
                const subtitles = [];
                const blocks = text.trim().split(/\n\s*\n/);

                for (const block of blocks) {
                    const lines = block.trim().split('\n');
                    if (lines.length < 3) continue;

                    // 1行目: 番号（スキップ）
                    // 2行目: タイムコード
                    const timeMatch = lines[1].match(/(\d{2}):(\d{2}):(\d{2}),(\d{3})\s*-->\s*(\d{2}):(\d{2}):(\d{2}),(\d{3})/);
                    if (!timeMatch) continue;

                    const startTime = parseInt(timeMatch[1]) * 3600 +
                                     parseInt(timeMatch[2]) * 60 +
                                     parseInt(timeMatch[3]) +
                                     parseInt(timeMatch[4]) / 1000;
                    const endTime = parseInt(timeMatch[5]) * 3600 +
                                   parseInt(timeMatch[6]) * 60 +
                                   parseInt(timeMatch[7]) +
                                   parseInt(timeMatch[8]) / 1000;

                    // 3行目以降: テキスト
                    const text = lines.slice(2).join('\n');

                    subtitles.push({
                        start: startTime,
                        end: endTime,
                        text: text
                    });
                }

                return subtitles;
            },

            // Premiere XMLファイルをパース
            parsePremiereXML(xmlText) {
                const subtitles = [];
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlText, 'text/xml');

                // パースエラーチェック
                const parserError = xmlDoc.querySelector('parsererror');
                if (parserError) {
                    throw new Error('XMLパースエラー: ' + parserError.textContent);
                }

                // <subtitle> タグを探す
                const subtitleElements = xmlDoc.querySelectorAll('subtitle');

                if (subtitleElements.length === 0) {
                    // 別の形式を試す（例：<text> タグ）
                    const textElements = xmlDoc.querySelectorAll('text');
                    textElements.forEach(el => {
                        const startAttr = el.getAttribute('start') || el.getAttribute('in');
                        const endAttr = el.getAttribute('end') || el.getAttribute('out');
                        const text = el.textContent || el.getAttribute('value') || '';

                        if (startAttr && endAttr) {
                            subtitles.push({
                                start: parseFloat(startAttr),
                                end: parseFloat(endAttr),
                                text: text.trim()
                            });
                        }
                    });
                } else {
                    subtitleElements.forEach(el => {
                        const startAttr = el.getAttribute('start') || el.getAttribute('in');
                        const endAttr = el.getAttribute('end') || el.getAttribute('out');
                        const text = el.textContent || el.getAttribute('text') || '';

                        if (startAttr && endAttr) {
                            subtitles.push({
                                start: parseFloat(startAttr),
                                end: parseFloat(endAttr),
                                text: text.trim()
                            });
                        }
                    });
                }

                if (subtitles.length === 0) {
                    throw new Error('XML内に字幕データが見つかりませんでした');
                }

                return subtitles;
            }
        };

        // 文字起こし編集ウィンドウを開く
        function openTranscriptionEditor() {
            // モーダルウィンドウを作成
            const modal = document.createElement('div');
            modal.id = 'transcriptionEditorModal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
            `;

            const editorWindow = document.createElement('div');
            editorWindow.style.cssText = `
                background: #1a1a1a;
                border: 2px solid #444;
                border-radius: 8px;
                width: 90%;
                max-width: 1200px;
                height: 80%;
                display: flex;
                flex-direction: column;
                padding: 20px;
                color: #fff;
            `;

            editorWindow.innerHTML = `
                <h2 style="margin: 0 0 15px 0; font-size: 18px;">文字起こしファイル編集</h2>

                <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                    <button id="loadFileBtn" class="btn btn-primary">ファイルを開く (SRT/XML)</button>
                    <input type="file" id="transcriptionFileInput" accept=".srt,.xml" style="display:none">
                    <span id="fileStatus" style="color: #888; line-height: 32px; font-size: 12px;"></span>
                </div>

                <div style="flex: 1; display: flex; gap: 15px; overflow: hidden;">
                    <div style="flex: 1; display: flex; flex-direction: column;">
                        <label style="margin-bottom: 5px; font-size: 14px; font-weight: bold;">文字起こしテキスト編集</label>
                        <textarea id="transcriptionText" style="
                            flex: 1;
                            background: #2a2a2a;
                            border: 1px solid #444;
                            border-radius: 4px;
                            color: #fff;
                            padding: 10px;
                            font-family: monospace;
                            font-size: 14px;
                            resize: none;
                            line-height: 1.8;
                        " placeholder="ここにファイルを読み込むか、直接テキストを入力してください。&#10;&#10;各キャンバスのテキストは空白行で区切ってください。"></textarea>
                    </div>

                    <div style="flex: 1; display: flex; flex-direction: column;">
                        <label style="margin-bottom: 5px; font-size: 14px; font-weight: bold;">プレビュー (キャンバス割り当て)</label>
                        <div id="canvasPreview" style="
                            flex: 1;
                            background: #2a2a2a;
                            border: 1px solid #444;
                            border-radius: 4px;
                            padding: 10px;
                            overflow-y: auto;
                            font-size: 13px;
                        "></div>
                    </div>
                </div>

                <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #444;">
                    <div style="margin-bottom: 10px;">
                        <label style="font-size: 12px; color: #aaa;">
                            空白行で区切られたブロックがそれぞれ1つのキャンバスになります。
                        </label>
                    </div>
                    <div style="display: flex; gap: 10px; justify-content: flex-end;">
                        <button id="cancelBtn" class="btn btn-secondary">キャンセル</button>
                        <button id="applyBtn" class="btn btn-primary">キャンバスに展開</button>
                    </div>
                </div>
            `;

            modal.appendChild(editorWindow);
            document.body.appendChild(modal);

            // イベントリスナー設定
            const fileInput = document.getElementById('transcriptionFileInput');
            const fileStatus = document.getElementById('fileStatus');
            const transcriptionText = document.getElementById('transcriptionText');
            const canvasPreview = document.getElementById('canvasPreview');

            // テキスト変更時にプレビューを更新
            function updatePreview() {
                const text = transcriptionText.value;
                const blocks = text.split(/\n\s*\n/).filter(block => block.trim());

                canvasPreview.innerHTML = '';
                if (blocks.length === 0) {
                    canvasPreview.innerHTML = '<div style="color:#888;text-align:center;margin-top:20px;">テキストを入力するとプレビューが表示されます</div>';
                    return;
                }

                blocks.forEach((block, index) => {
                    const previewItem = document.createElement('div');
                    previewItem.style.cssText = `
                        background: #333;
                        border: 1px solid #555;
                        border-radius: 4px;
                        padding: 10px;
                        margin-bottom: 10px;
                    `;
                    previewItem.innerHTML = `
                        <div style="color: #0078d4; font-weight: bold; margin-bottom: 5px;">キャンバス ${index + 1}</div>
                        <div style="white-space: pre-wrap; line-height: 1.6;">${block.trim()}</div>
                    `;
                    canvasPreview.appendChild(previewItem);
                });
            }

            transcriptionText.addEventListener('input', updatePreview);

            // ファイル読み込み
            document.getElementById('loadFileBtn').addEventListener('click', () => {
                fileInput.click();
            });

            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (ev) => {
                    try {
                        const text = ev.target.result;
                        const ext = file.name.toLowerCase().split('.').pop();

                        let subtitles = [];
                        if (ext === 'srt') {
                            subtitles = BatchProcessor.parseSRT(text);
                            fileStatus.textContent = `✓ ${file.name} を読み込みました (${subtitles.length}個の字幕)`;
                            fileStatus.style.color = '#0f0';
                        } else if (ext === 'xml') {
                            console.log('XMLファイルを解析中:', file.name);
                            console.log('ファイルサイズ:', text.length, '文字');
                            subtitles = BatchProcessor.parsePremiereXML(text);
                            fileStatus.textContent = `✓ ${file.name} を読み込みました (${subtitles.length}個の字幕)`;
                            fileStatus.style.color = '#0f0';
                        } else {
                            fileStatus.textContent = '✗ サポートされていない形式です';
                            fileStatus.style.color = '#f44';
                            return;
                        }

                        // 字幕をテキストエリアに表示（1行につき1つの字幕、空白行で区切る）
                        transcriptionText.value = subtitles.map(sub => sub.text).join('\n\n');
                        loadedSubtitles = subtitles;
                        updatePreview();
                    } catch (err) {
                        fileStatus.textContent = `✗ エラー: ${err.message}`;
                        fileStatus.style.color = '#f44';
                        console.error('ファイル読み込みエラー:', err);
                        console.error('エラー詳細:', err.stack);
                        alert(`ファイル読み込みエラー:\n${err.message}\n\n詳細はコンソールを確認してください。`);
                    }
                };
                reader.onerror = (err) => {
                    fileStatus.textContent = '✗ ファイル読み込みに失敗しました';
                    fileStatus.style.color = '#f44';
                    console.error('FileReader エラー:', err);
                };
                reader.readAsText(file, 'UTF-8');
                e.target.value = '';
            });

            // キャンセルボタン
            document.getElementById('cancelBtn').addEventListener('click', () => {
                document.body.removeChild(modal);
            });

            // キャンバスに展開ボタン
            document.getElementById('applyBtn').addEventListener('click', () => {
                const text = transcriptionText.value;
                const blocks = text.split(/\n\s*\n/).filter(block => block.trim());

                if (blocks.length === 0) {
                    alert('テキストが入力されていません');
                    return;
                }

                // プログレスバーを表示
                const progressOverlay = document.createElement('div');
                progressOverlay.style.cssText = `
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.9);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    flex-direction: column;
                    z-index: 1;
                `;
                progressOverlay.innerHTML = `
                    <div style="color: #fff; font-size: 18px; margin-bottom: 20px;">キャンバスを生成中...</div>
                    <div style="width: 400px; height: 30px; background: #333; border-radius: 15px; overflow: hidden; border: 1px solid #555;">
                        <div id="progressBar" style="height: 100%; background: linear-gradient(90deg, #0078d4, #00bcf2); width: 0%; transition: width 0.3s;"></div>
                    </div>
                    <div id="progressText" style="color: #aaa; margin-top: 10px; font-size: 14px;">0 / ${blocks.length}</div>
                `;
                editorWindow.appendChild(progressOverlay);

                const progressBar = document.getElementById('progressBar');
                const progressText = document.getElementById('progressText');

                // 現在選択されているオブジェクトをテンプレートとして使用
                let template = null;
                if (selectedObjId) {
                    template = textObjects.find(o => o.id === selectedObjId);
                }

                // テンプレートがない場合はデフォルトのテキストオブジェクトを作成
                if (!template) {
                    template = {
                        type: 'text',
                        chars: [],
                        x: 960,
                        y: 950,
                        fontSize: 72,
                        fontFamily: 'Yu Gothic UI',
                        color: '#ffffff'
                    };
                }

                // 非同期でキャンバスを生成（UIをブロックしないため）
                let currentIndex = 0;
                function processNextCanvas() {
                    if (currentIndex >= blocks.length) {
                        // 完了
                        editorWindow.removeChild(progressOverlay);

                        // 最初に作成したキャンバスに切り替え
                        if (canvases.length > 0) {
                            const firstNewCanvas = canvases[canvases.length - blocks.length];
                            if (firstNewCanvas) {
                                switchCanvas(firstNewCanvas.id);
                            }
                        }

                        updateCanvasList();
                        document.body.removeChild(modal);
                        alert(`${blocks.length} 個のキャンバスを生成しました`);
                        return;
                    }

                    const block = blocks[currentIndex];
                    const canvasName = `字幕_${currentIndex + 1}`;
                    const newCanvas = createCanvasData(canvasName);

                    // テンプレートをクローン
                    const newObj = JSON.parse(JSON.stringify(template));
                    newObj.id = Date.now() + currentIndex;
                    newObj.name = `字幕${currentIndex + 1}`;

                    // テキストを設定
                    const chars = block.trim().split('').map(char => ({
                        char: char,
                        fontSize: template.fontSize || 72,
                        fontFamily: template.fontFamily || 'Yu Gothic UI',
                        color: template.color || '#ffffff',
                        bold: template.bold || false,
                        italic: template.italic || false,
                        opacity: 100,
                        tracking: 0,
                        fillType: 'solid',
                        strokes: []
                    }));
                    newObj.chars = chars;

                    // 横中央揃えを適用
                    const [canvasWidth, canvasHeight] = (newCanvas.resolution || '1920x1080').split('x').map(Number);
                    const bounds = getObjectBounds(newObj);
                    const offsetX = newObj.x - bounds.x;
                    newObj.x = (canvasWidth - bounds.w) / 2 + offsetX;

                    // キャンバスにオブジェクトを追加
                    newCanvas.objects = [newObj];

                    // タイミング情報があれば保存
                    if (loadedSubtitles[currentIndex]) {
                        newCanvas.metadata = {
                            startTime: loadedSubtitles[currentIndex].start,
                            endTime: loadedSubtitles[currentIndex].end,
                            duration: loadedSubtitles[currentIndex].end - loadedSubtitles[currentIndex].start
                        };
                    }

                    // サムネイルを生成
                    const thumbCanvas = document.createElement('canvas');
                    thumbCanvas.width = canvasWidth;
                    thumbCanvas.height = canvasHeight;
                    const thumbCtx = thumbCanvas.getContext('2d');

                    // 背景を描画
                    thumbCtx.fillStyle = '#1a1a1a';
                    thumbCtx.fillRect(0, 0, canvasWidth, canvasHeight);

                    // テキストオブジェクトを描画
                    thumbCtx.save();
                    drawTextObject(thumbCtx, newObj);
                    thumbCtx.restore();

                    // サムネイルをBase64で保存
                    newCanvas.thumbnail = thumbCanvas.toDataURL('image/png');

                    canvases.push(newCanvas);

                    // プログレスバー更新
                    currentIndex++;
                    const progress = (currentIndex / blocks.length) * 100;
                    progressBar.style.width = progress + '%';
                    progressText.textContent = `${currentIndex} / ${blocks.length}`;

                    // 次のキャンバスを処理
                    setTimeout(processNextCanvas, 10);
                }

                processNextCanvas();
            });
        }

        function handleFileLoad(e) {
            const file = e.target.files[0]; if (!file) return;
            const reader = new FileReader();
            reader.onload = (ev) => {
                try {
                    const p = JSON.parse(ev.target.result);

                    // v4.0形式（.telop形式）
                    if (p.version === '4.0' && p.fileType === 'telop') {
                        // キャンバス設定を復元
                        if (p.canvas) {
                            canvas.width = p.canvas.width || 1920;
                            canvas.height = p.canvas.height || 1080;
                            canvasBgColor = p.canvas.bgColor || '#000000';
                            canvasBgOpacity = p.canvas.bgOpacity || 0;
                            bgImage = p.canvas.bgImage || null;
                            // 解像度セレクタを更新
                            const resValue = `${canvas.width}x${canvas.height}`;
                            const resSelect = document.getElementById('resolution');
                            if ([...resSelect.options].some(opt => opt.value === resValue)) {
                                resSelect.value = resValue;
                            }
                        }
                        // オブジェクトを復元
                        textObjects = p.objects || [];
                        window.textObjects = textObjects;
                        migrateObjects(textObjects);

                        // アニメーション設定を復元
                        if (p.animation) {
                            totalDuration = p.animation.totalDuration || 5;
                            animationTime = p.animation.currentTime || 0;
                        }

                        // 下位互換性のため既存のcanvases形式も復元
                        if (p.canvases) {
                            canvases = p.canvases;
                            window.canvases = p.canvases;
                            activeCanvasId = p.activeCanvasId;
                            window.activeCanvasId = p.activeCanvasId;
                        }
                    }
                    // v3.0形式（複数キャンバス）
                    else if (p.version === '3.0' && p.canvases) {
                        canvases = p.canvases;
                        window.canvases = p.canvases;
                        activeCanvasId = p.activeCanvasId || canvases[0].id;
                        window.activeCanvasId = p.activeCanvasId || canvases[0].id;
                        // オブジェクトのマイグレーション
                        canvases.forEach(canvasData => {
                            migrateObjects(canvasData.objects);
                        });
                        loadCurrentCanvas();
                        updateCanvasList();
                    }
                    // v2.x形式（単一キャンバス）- 後方互換性
                    else {
                        const imported = createCanvasData('キャンバス 1');
                        if (p.resolution) imported.resolution = p.resolution;
                        imported.objects = p.objects || [];
                        migrateObjects(imported.objects);
                        canvases = [imported];
                        window.canvases = [imported];
                        activeCanvasId = imported.id;
                        window.activeCanvasId = imported.id;
                        loadCurrentCanvas();
                        updateCanvasList();
                    }

                    selectedObjId = null; selectedObjIds = []; editingObjId = null;
                    updateLayerList(); updateLayerProps(); render();
                } catch (err) {
                    console.error('Load error:', err);
                    alert('読込失敗: ' + err.message);
                }
            };
            reader.readAsText(file);
            e.target.value = '';
        }

        // オブジェクトの後方互換性マイグレーション
        function migrateObjects(objects) {
            if (!objects) return;
            objects.forEach(obj => {
                if (!obj.name) obj.name = 'テキスト';
                if (!obj.textAlign) obj.textAlign = 'left';
                if (!obj.verticalAlign) obj.verticalAlign = 'middle';
                if (obj.opacity === undefined) obj.opacity = 100;
                if (obj.rotation === undefined) obj.rotation = 0;
                if (obj.lineHeight === undefined) obj.lineHeight = 1.2;
                // Initialize name tag properties
                if (!obj.nameTag) {
                    obj.nameTag = {
                        enabled: false, text: '', font: 'Yu Gothic UI', position: 'top-left', gap: 10,
                        color: '#ffffff', size: 36, bgEnabled: true, bgShape: 'rounded',
                        bgRadius: 5, bgColor: '#0066cc', bgOpacity: 100, padX: 10, padY: 5,
                        strokeEnabled: false, strokeColor: '#ffffff', strokeWidth: 2
                    };
                }
                if (obj.nameTag && !obj.nameTag.font) {
                    obj.nameTag.font = 'Yu Gothic UI';
                }
                // Initialize balloon properties
                if (!obj.balloon) {
                    obj.balloon = {
                        enabled: false, shape: 'rounded', radius: 20, padX: 30, padY: 20,
                        fill: '#ffffff', fillOpacity: 100, strokeEnabled: true,
                        strokeColor: '#000000', strokeWidth: 3, tailEnabled: true,
                        tailDir: 'bottom', tailPos: 50, tailWidth: 20, tailLength: 30
                    };
                }
                if (obj.chars) {
                    obj.chars.forEach(c => {
                        if (c.scaleX === undefined) c.scaleX = 100;
                        if (c.opacity === undefined) c.opacity = 100;
                        if (c.fillType === undefined) c.fillType = 'solid';
                        if (!c.strokes) c.strokes = [{ enabled: true, type: 'edge', color: '#000', width: 4, opacity: 100 }];
                    });
                }
            });
        }

        // ========== カスタムスタイル管理 ==========

        /**
         * 新規カスタムスタイルを保存
         */
        function saveNewCustomStyle() {
            const statusEl = document.getElementById('customStyleStatus');

            // 選択中のテキストオブジェクトを取得
            if (!selectedObjId) {
                if (statusEl) statusEl.textContent = 'テキストオブジェクトを選択してください';
                return;
            }

            const obj = textObjects.find(o => o.id === selectedObjId);
            if (!obj || obj.type !== 'text' || !obj.chars || obj.chars.length === 0) {
                if (statusEl) statusEl.textContent = 'テキストオブジェクトを選択してください';
                return;
            }

            // 複数選択時は左端の文字を取得（X座標が最小の文字）
            let targetChar = obj.chars[0];
            if (obj.chars.length > 1) {
                // 選択された文字インデックスがある場合はそれを使用
                if (typeof selectedCharIndices !== 'undefined' && selectedCharIndices.length > 0) {
                    // 選択された文字の中で最も左にあるもの
                    const selectedChars = selectedCharIndices.map(i => obj.chars[i]).filter(c => c);
                    if (selectedChars.length > 0) {
                        targetChar = selectedChars[0]; // 配列の最初（左端）
                    }
                }
            }

            // スタイル名を入力
            const styleName = prompt('スタイル名を入力してください:', '新しいスタイル');
            if (!styleName || !styleName.trim()) {
                return; // キャンセル
            }

            // スタイルを抽出して保存
            if (window.CustomStyleManager) {
                const styleData = window.CustomStyleManager.extractStyleFromChar(targetChar);
                const result = window.CustomStyleManager.saveStyle(styleName.trim(), styleData);

                if (result.success) {
                    if (statusEl) statusEl.textContent = `スタイル「${result.name}」を保存しました`;
                } else {
                    if (statusEl) statusEl.textContent = 'スタイルの保存に失敗しました';
                }
            } else {
                if (statusEl) statusEl.textContent = 'CustomStyleManagerが読み込まれていません';
            }
        }

        /**
         * カスタムスタイルを適用
         * @param {string} styleId - スタイルID
         */
        function applyCustomStyle(styleId) {
            const statusEl = document.getElementById('customStyleStatus');

            if (!selectedObjId) {
                if (statusEl) statusEl.textContent = 'テキストオブジェクトを選択してください';
                return;
            }

            const obj = textObjects.find(o => o.id === selectedObjId);
            if (!obj || obj.type !== 'text') {
                if (statusEl) statusEl.textContent = 'テキストオブジェクトを選択してください';
                return;
            }

            if (!window.CustomStyleManager) {
                if (statusEl) statusEl.textContent = 'CustomStyleManagerが読み込まれていません';
                return;
            }

            const styleEntry = window.CustomStyleManager.getStyle(styleId);
            if (!styleEntry) {
                if (statusEl) statusEl.textContent = 'スタイルが見つかりません';
                return;
            }

            saveState(); // Undo用

            // 全文字にスタイルを適用
            obj.chars.forEach(c => {
                window.CustomStyleManager.applyStyleToChar(styleId, c);
            });

            render();
            updateLayerProps();

            if (statusEl) statusEl.textContent = `スタイル「${styleEntry.name}」を適用しました`;
        }

        /**
         * 全カスタムスタイルをエクスポート
         */
        function exportAllCustomStyles() {
            const statusEl = document.getElementById('customStyleStatus');

            if (window.CustomStyleManager) {
                const result = window.CustomStyleManager.exportStyles();
                if (result.success) {
                    if (statusEl) statusEl.textContent = `${result.count}個のスタイルをエクスポートしました`;
                } else {
                    if (statusEl) statusEl.textContent = result.error || 'エクスポートに失敗しました';
                }
            }
        }

        /**
         * カスタムスタイルをインポート
         */
        function importCustomStyles() {
            document.getElementById('customStyleImportInput').click();
        }

        /**
         * カスタムスタイルインポートのハンドラ
         * @param {Event} e - イベント
         */
        function handleCustomStyleImport(e) {
            const file = e.target.files[0];
            if (!file) return;

            const statusEl = document.getElementById('customStyleStatus');

            if (window.CustomStyleManager) {
                window.CustomStyleManager.importStyles(file)
                    .then(result => {
                        if (statusEl) statusEl.textContent = `${result.count}個のスタイルをインポートしました`;
                    })
                    .catch(err => {
                        if (statusEl) statusEl.textContent = 'インポートエラー: ' + err.message;
                    });
            }

            e.target.value = ''; // リセット
        }

        /**
         * CustomStyleManagerの初期化
         */
        function initCustomStyleManager() {
            if (window.CustomStyleManager) {
                // CEP環境の場合、スタイルディレクトリを設定
                if (typeof csInterface !== 'undefined' && csInterface) {
                    const basePath = csInterface.getSystemPath(SystemPath.EXTENSION);
                    window.CustomStyleManager.setStylesDirectory(basePath);
                }

                window.CustomStyleManager.init();
            }
        }

        // ========== ツールバーサイズ切り替え ==========

        let currentToolbarSize = 'm';

        function setToolbarSize(size) {
            const toolbar = document.querySelector('.bottom-toolbar');
            if (!toolbar) return;

            // クラスを切り替え
            toolbar.classList.remove('toolbar-size-s', 'toolbar-size-m', 'toolbar-size-l');
            toolbar.classList.add('toolbar-size-' + size);

            // ボタンのアクティブ状態を更新
            document.querySelectorAll('.tool-group:last-child .tool-icon').forEach(btn => {
                btn.classList.remove('active');
            });
            const sizeBtn = document.querySelector(`.tool-group:last-child .tool-icon:nth-child(${size === 's' ? 1 : size === 'm' ? 2 : 3})`);
            if (sizeBtn) sizeBtn.classList.add('active');

            currentToolbarSize = size;
            localStorage.setItem('toolbarSize', size);
        }

        // ========== パネルリサイズ機能 ==========

        function initPanelResize() {
            const container = document.querySelector('.container');
            const leftHandle = document.getElementById('leftResizeHandle');
            const rightHandle = document.getElementById('rightResizeHandle');

            if (!container || !leftHandle || !rightHandle) return;

            let isResizing = false;
            let currentHandle = null;

            const startResize = (e, handle) => {
                isResizing = true;
                currentHandle = handle;
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
                e.preventDefault();
            };

            const doResize = (e) => {
                if (!isResizing) return;

                const containerRect = container.getBoundingClientRect();

                if (currentHandle === 'left') {
                    let newWidth = e.clientX - containerRect.left;
                    newWidth = Math.max(180, Math.min(400, newWidth));
                    container.style.setProperty('--left-panel-width', newWidth + 'px');
                    localStorage.setItem('leftPanelWidth', newWidth);
                } else if (currentHandle === 'right') {
                    let newWidth = containerRect.right - e.clientX;
                    newWidth = Math.max(250, Math.min(500, newWidth));
                    container.style.setProperty('--right-panel-width', newWidth + 'px');
                    localStorage.setItem('rightPanelWidth', newWidth);
                }
            };

            const stopResize = () => {
                isResizing = false;
                currentHandle = null;
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
            };

            leftHandle.addEventListener('mousedown', (e) => startResize(e, 'left'));
            rightHandle.addEventListener('mousedown', (e) => startResize(e, 'right'));
            document.addEventListener('mousemove', doResize);
            document.addEventListener('mouseup', stopResize);

            // 保存された値を復元
            const savedLeft = localStorage.getItem('leftPanelWidth');
            const savedRight = localStorage.getItem('rightPanelWidth');
            if (savedLeft) container.style.setProperty('--left-panel-width', savedLeft + 'px');
            if (savedRight) container.style.setProperty('--right-panel-width', savedRight + 'px');
        }

        // 初期化
        initCanvases();
        render();

        // DOM読み込み後の初期化
        document.addEventListener('DOMContentLoaded', function() {
            // ツールバーサイズを復元
            const savedSize = localStorage.getItem('toolbarSize');
            if (savedSize) setToolbarSize(savedSize);

            // パネルリサイズ初期化
            initPanelResize();
        });

        // フォールバック: window.onload
        window.addEventListener('load', function() {
            // パネルリサイズ初期化（フォールバック）
            initPanelResize();

            // CustomStyleManager初期化（style-manager.js読み込み後）
            setTimeout(function() {
                if (window.CustomStyleManager) {
                    initCustomStyleManager();
                } else {
                    console.warn('CustomStyleManager not loaded');
                }
            }, 100);

            // プリセット初期化とチェック
            setTimeout(function() {
                // プリセットを初期化
                initAnimationPresets();
                initStylePresets();

                // プリセット読み込み状態をチェック
                if (window.AnimationPresets && window.StylePresets) {
                    console.log('All presets loaded successfully');
                } else {
                    console.warn('Preset modules not loaded properly');
                }
            }, 200);
        });

        // ========== アニメーションプリセット機能 ==========
        let currentAnimPresetType = 'in';
        let currentAnimPresetCategory = 'all';
        let selectedAnimPresetId = null;

        function switchAnimPresetType(type) {
            currentAnimPresetType = type;
            document.getElementById('animPresetInBtn').className = type === 'in' ? 'btn btn-small' : 'btn btn-small btn-secondary';
            document.getElementById('animPresetInBtn').style.background = type === 'in' ? '#4a9eff' : '';
            document.getElementById('animPresetOutBtn').className = type === 'out' ? 'btn btn-small' : 'btn btn-small btn-secondary';
            document.getElementById('animPresetOutBtn').style.background = type === 'out' ? '#4a9eff' : '';
            renderAnimPresetList();
        }

        function filterAnimPresets(category) {
            currentAnimPresetCategory = category;
            const btns = document.querySelectorAll('#animPresetCategories button');
            btns.forEach((btn, i) => {
                const cats = ['all', 'simple', 'modern', 'dynamic', 'elastic', 'creative'];
                btn.className = cats[i] === category ? 'btn btn-small' : 'btn btn-small btn-secondary';
            });
            renderAnimPresetList();
        }

        function initAnimationPresets() {
            if (!window.AnimationPresets) {
                console.warn('AnimationPresets not loaded');
                return;
            }
            renderAnimPresetList();
        }

        function renderAnimPresetList() {
            const listEl = document.getElementById('animPresetList');
            if (!window.AnimationPresets) {
                listEl.innerHTML = '<div style="color:#888;text-align:center;padding:20px;">プリセットが読み込まれていません</div>';
                return;
            }

            const presets = window.AnimationPresets.getPresetsByCategory(currentAnimPresetCategory, currentAnimPresetType);
            if (presets.length === 0) {
                listEl.innerHTML = '<div style="color:#888;text-align:center;padding:10px;">プリセットがありません</div>';
                return;
            }

            listEl.innerHTML = presets.map(p => `
                <div class="preset-item ${selectedAnimPresetId === p.id ? 'selected' : ''}"
                     onclick="selectAnimPreset('${p.id}')"
                     ondblclick="applyAnimPreset()"
                     style="padding:6px;margin:2px 0;cursor:pointer;border-radius:4px;background:${selectedAnimPresetId === p.id ? '#4a9eff' : '#333'};display:flex;justify-content:space-between;align-items:center;">
                    <span>${p.name}</span>
                    <span style="font-size:10px;color:#aaa;">${p.category}</span>
                </div>
            `).join('');
        }

        function selectAnimPreset(id) {
            selectedAnimPresetId = id;
            renderAnimPresetList();
        }

        function applyAnimPreset() {
            // プリセットモジュールの読み込みチェック
            if (!window.AnimationPresets) {
                alert('アニメーションプリセットが読み込まれていません。\n\nページを再読み込みしてください。');
                console.error('AnimationPresets module not loaded');
                return;
            }

            // プリセット選択チェック
            if (!selectedAnimPresetId) {
                alert('アニメーションプリセットが選択されていません。\n\nプリセットリストからプリセットを選択してください。');
                console.error('No animation preset selected');
                return;
            }

            const preset = window.AnimationPresets.getPreset(selectedAnimPresetId);
            if (!preset) {
                alert('選択されたプリセットが見つかりませんでした。');
                console.error('Preset not found:', selectedAnimPresetId);
                return;
            }

            // オブジェクト選択チェック
            const obj = textObjects.find(o => o.id === selectedObjId);
            if (!obj) {
                alert('オブジェクトが選択されていません。\n\nキャンバス上のオブジェクトをクリックして選択してください。');
                console.error('No object selected');
                return;
            }

            saveState();

            // プリセートのkeyframesと設定を保存
            obj.presetKeyframes = JSON.parse(JSON.stringify(preset.keyframes));
            obj.presetUnit = preset.unit || 'all';
            obj.presetStagger = preset.stagger || 0;

            // アニメーション設定を適用
            obj.animation = {
                type: 'preset',  // プリセート専用タイプ
                duration: (preset.duration || 500) / 1000,  // ミリ秒→秒
                delay: obj.animation?.delay || 0,
                speed: obj.animation?.speed || 100,
                easing: preset.easing || 'easeOutQuad',
                loop: obj.animation?.loop || false
            };

            // UIを更新
            document.getElementById('animType').value = 'preset';
            document.getElementById('animDuration').value = obj.animation.duration;
            document.getElementById('animEasing').value = obj.animation.easing;
            document.getElementById('animDelay').value = obj.animation.delay;
            document.getElementById('animSpeed').value = obj.animation.speed;
            document.getElementById('animLoop').checked = obj.animation.loop;

            // アニメーションをリセットしてプレビュー表示
            resetAnimation();
            render();

            console.log('Animation preset applied:', preset.name, '| unit:', preset.unit, '| keyframes:', preset.keyframes.length);

            // 成功メッセージ
            const statusEl = document.getElementById('animPresetStatus');
            if (statusEl) {
                statusEl.style.color = '#4caf50';
                statusEl.innerHTML = `✓ ${preset.name}を適用<br><span style="font-size:9px;color:#888;">Spaceキーで再生</span>`;
                setTimeout(() => { statusEl.textContent = ''; }, 5000);
            }

            // Note: アニメーションはSpaceキーまたはプレビューボタンで再生できます
        }

        function previewAnimPreset() {
            if (!selectedAnimPresetId) return;

            const statusEl = document.getElementById('animPresetStatus');
            if (statusEl) {
                statusEl.style.color = '#4a9eff';
                statusEl.innerHTML = 'プレビュー再生中...';
            }

            applyAnimPreset();

            // アニメーションを最初から再生
            setTimeout(() => {
                resetAnimation();
                if (!isPlaying) {
                    toggleAnimation();
                }

                if (statusEl) {
                    setTimeout(() => {
                        statusEl.innerHTML = `✓ プレビュー完了<br><span style="font-size:9px;color:#888;">「適用」で確定</span>`;
                        setTimeout(() => { statusEl.textContent = ''; }, 3000);
                    }, 100);
                }
            }, 100);
        }

        // ========== スタイルプリセット機能 ==========
        let currentStylePresetCategory = 'all';
        let selectedStylePresetId = null;

        function filterStylePresets(category) {
            currentStylePresetCategory = category;
            const btns = document.querySelectorAll('#stylePresetCategories button');
            const cats = ['all', 'cartoon', 'cinematic', 'modern', 'simple', 'news', 'variety'];
            btns.forEach((btn, i) => {
                btn.className = cats[i] === category ? 'btn btn-small' : 'btn btn-small btn-secondary';
            });
            renderStylePresetList();
        }

        function initStylePresets() {
            if (!window.StylePresets) {
                console.warn('StylePresets not loaded');
                return;
            }
            renderStylePresetList();
        }

        function renderStylePresetList() {
            const listEl = document.getElementById('stylePresetList');
            if (!window.StylePresets) {
                listEl.innerHTML = '<div style="color:#888;text-align:center;padding:20px;">プリセットが読み込まれていません</div>';
                return;
            }

            const presets = window.StylePresets.getPresetsByCategory(currentStylePresetCategory);
            if (presets.length === 0) {
                listEl.innerHTML = '<div style="color:#888;text-align:center;padding:10px;">プリセットがありません</div>';
                return;
            }

            listEl.innerHTML = presets.map(p => `
                <div class="preset-item ${selectedStylePresetId === p.id ? 'selected' : ''}"
                     onclick="selectStylePreset('${p.id}')"
                     ondblclick="applyStylePreset('selected')"
                     style="padding:6px;margin:2px 0;cursor:pointer;border-radius:4px;background:${selectedStylePresetId === p.id ? '#4a9eff' : '#333'};display:flex;justify-content:space-between;align-items:center;">
                    <span>${p.name}</span>
                    <span style="font-size:10px;color:#aaa;">${window.StylePresets.getCategoryName(p.category)}</span>
                </div>
            `).join('');
        }

        function selectStylePreset(id) {
            selectedStylePresetId = id;
            renderStylePresetList();
        }

        function applyStylePreset(mode) {
            // プリセットモジュールの読み込みチェック
            if (!window.StylePresets) {
                alert('スタイルプリセットが読み込まれていません。\n\nページを再読み込みしてください。');
                console.error('StylePresets module not loaded');
                return;
            }

            // プリセット選択チェック
            if (!selectedStylePresetId) {
                alert('スタイルプリセットが選択されていません。\n\nプリセットリストからプリセットを選択してください。');
                console.error('No style preset selected');
                return;
            }

            const preset = window.StylePresets.getPreset(selectedStylePresetId);
            if (!preset || !preset.style) {
                alert('選択されたプリセットが見つかりませんでした。');
                console.error('Preset not found:', selectedStylePresetId);
                return;
            }

            // テキストオブジェクト選択チェック
            const obj = textObjects.find(o => o.id === selectedObjId);
            if (!obj) {
                alert('テキストオブジェクトが選択されていません。\n\nキャンバス上のテキストをクリックして選択してください。');
                console.error('No text object selected');
                return;
            }

            if (obj.type !== 'text') {
                alert('選択されたオブジェクトはテキストではありません。');
                console.error('Selected object is not text:', obj.type);
                return;
            }

            // 文字データの存在チェック
            if (!obj.chars || obj.chars.length === 0) {
                alert('テキストに文字データがありません。\n\nテキストを入力してから再度お試しください。');
                console.error('No chars data in text object');
                return;
            }

            saveState();

            const style = preset.style;
            console.log('[StylePreset] Applying preset:', preset.name, 'Mode:', mode);
            console.log('[StylePreset] Preset style:', style);

            // スタイルを適用する関数
            const applyToChar = (c) => {
                // 基本テキストプロパティ
                if (style.fontFamily !== undefined) c.fontFamily = style.fontFamily;
                if (style.fontSize !== undefined) c.fontSize = style.fontSize;
                if (style.fontWeight !== undefined) c.fontWeight = style.fontWeight;
                if (style.fontStyle !== undefined) c.fontStyle = style.fontStyle;

                // 塗りとグラデーション
                if (style.fillType !== undefined) c.fillType = style.fillType;
                if (style.color !== undefined) c.color = style.color;
                if (style.opacity !== undefined) c.opacity = style.opacity;

                // グラデーション設定
                if (style.gradientStops !== undefined) {
                    c.gradientStops = JSON.parse(JSON.stringify(style.gradientStops));
                    // 最初と最後の色をcolor/color2にも設定
                    if (style.gradientStops.length > 0) {
                        c.color = style.gradientStops[0].color;
                        if (style.gradientStops.length > 1) {
                            c.color2 = style.gradientStops[style.gradientStops.length - 1].color;
                        }
                    }
                }
                if (style.gradientAngle !== undefined) c.gradientAngle = style.gradientAngle;
                if (style.gradientBlur !== undefined) c.gradientBlur = style.gradientBlur;

                // ストローク
                if (style.strokes !== undefined) {
                    c.strokes = JSON.parse(JSON.stringify(style.strokes));
                }

                // 影
                if (style.shadowEnabled !== undefined) c.shadowEnabled = style.shadowEnabled;
                if (style.shadowColor !== undefined) c.shadowColor = style.shadowColor;
                if (style.shadowOpacity !== undefined) c.shadowOpacity = style.shadowOpacity;
                if (style.shadowAngle !== undefined) c.shadowAngle = style.shadowAngle;
                if (style.shadowDistance !== undefined) c.shadowDistance = style.shadowDistance;
                if (style.shadowSize !== undefined) c.shadowSize = style.shadowSize;
                if (style.shadowBlur !== undefined) c.shadowBlur = style.shadowBlur;

                // 光沢
                if (style.glossEnabled !== undefined) c.glossEnabled = style.glossEnabled;
                if (style.glossWidth !== undefined) c.glossWidth = style.glossWidth;
                if (style.glossBlur !== undefined) c.glossBlur = style.glossBlur;
                if (style.glossColor !== undefined) c.glossColor = style.glossColor;
                if (style.glossOpacity !== undefined) c.glossOpacity = style.glossOpacity;
                // Note: glossHeight is handled by glossOpacity in the rendering
            };

            if (mode === 'all') {
                // 全文字に適用
                if (obj.chars) {
                    obj.chars.forEach((c, i) => {
                        applyToChar(c);
                        if (i === 0) {
                            console.log('[StylePreset] First char after apply:', c);
                        }
                    });
                }
            } else {
                // 選択文字に適用
                if (obj.chars && selectedCharStart >= 0 && selectedCharEnd >= selectedCharStart) {
                    for (let i = selectedCharStart; i <= selectedCharEnd && i < obj.chars.length; i++) {
                        applyToChar(obj.chars[i]);
                    }
                } else {
                    // 選択がない場合は全文字に適用
                    console.log('[StylePreset] No selection, applying to all');
                    applyStylePreset('all');
                    return;
                }
            }

            console.log('[StylePreset] Calling render');
            render();

            // 成功メッセージ
            const appliedCount = mode === 'all' ? obj.chars.length :
                (selectedCharEnd - selectedCharStart + 1);
            console.log('Style preset applied:', preset.name, 'mode:', mode, 'chars:', appliedCount);

            // ステータス表示（一時的）
            const statusEl = document.getElementById('stylePresetStatus');
            if (statusEl) {
                statusEl.style.color = '#4caf50';
                statusEl.textContent = `✓ ${preset.name} (${appliedCount}文字)`;
                setTimeout(() => { statusEl.textContent = ''; }, 3000);
            }
        }

        function saveCurrentStyle() {
            const obj = textObjects.find(o => o.id === selectedObjId);
            if (!obj || obj.type !== 'text' || !obj.chars || obj.chars.length === 0) {
                alert('テキストオブジェクトを選択してください');
                return;
            }

            const name = prompt('スタイル名を入力してください:');
            if (!name) return;

            // 最初の文字のスタイルを保存
            const c = obj.chars[0];
            const style = {
                fontFamily: c.fontFamily,
                fontSize: c.fontSize,
                fontWeight: c.fontWeight,
                fontStyle: c.fontStyle,
                color: c.color,
                opacity: c.opacity,
                strokes: c.strokes ? JSON.parse(JSON.stringify(c.strokes)) : [],
                shadow: c.shadow ? JSON.parse(JSON.stringify(c.shadow)) : null,
                gradient: c.gradient ? JSON.parse(JSON.stringify(c.gradient)) : null
            };

            if (window.StylePresets) {
                const preset = {
                    id: 'custom-' + Date.now(),
                    name: name,
                    category: 'custom',
                    style: style
                };
                window.StylePresets.addCustomPreset(preset);
                renderStylePresetList();
                alert('スタイルを保存しました: ' + name);
            }
        }
    </script>
    <script src="style-manager.js" onload="initCustomStyleManager()"></script>
    <script src="batch.js"></script>
    <script src="prtl-generator.js"></script>
    <script src="prtl-export.js"></script>
    <script src="prtl-import.js"></script>
    <script src="morgt-generator.js"></script>
    <script src="morgt-export.js"></script>

    <!-- Animation Presets (embedded) -->
    <script>
/**
 * Animation Presets System
 * テロップアニメーションプリセット管理
 * 参考: textylepremiere
 */

window.AnimationPresets = (function() {
    'use strict';

    // プリセットカテゴリ
    const CATEGORIES = {
        SIMPLE: { id: 'simple', name: 'シンプル', icon: 'opacity.png' },
        MODERN: { id: 'modern', name: 'モダン', icon: 'magic-wand.png' },
        DYNAMIC: { id: 'dynamic', name: 'ダイナミック', icon: 'shuffle.png' },
        ELASTIC: { id: 'elastic', name: 'エラスティック', icon: 'speed.png' },
        CREATIVE: { id: 'creative', name: 'クリエイティブ', icon: 'creative.png' }
    };

    // アニメーションタイプ
    const ANIMATION_TYPES = {
        IN: 'in',      // 登場アニメーション
        OUT: 'out',    // 退場アニメーション
        LOOP: 'loop'   // ループアニメーション
    };

    // 適用単位
    const APPLY_UNITS = {
        ALL: 'all',           // 全体
        CHARACTER: 'character', // 文字単位
        WORD: 'word',         // 単語単位
        LINE: 'line'          // 行単位
    };

    // イージング関数
    const EASINGS = {
        linear: t => t,
        easeInQuad: t => t * t,
        easeOutQuad: t => t * (2 - t),
        easeInOutQuad: t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t,
        easeInCubic: t => t * t * t,
        easeOutCubic: t => (--t) * t * t + 1,
        easeInOutCubic: t => t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1,
        easeInElastic: t => {
            if (t === 0 || t === 1) return t;
            return -Math.pow(2, 10 * (t - 1)) * Math.sin((t - 1.1) * 5 * Math.PI);
        },
        easeOutElastic: t => {
            if (t === 0 || t === 1) return t;
            return Math.pow(2, -10 * t) * Math.sin((t - 0.1) * 5 * Math.PI) + 1;
        },
        easeOutBounce: t => {
            if (t < 1 / 2.75) return 7.5625 * t * t;
            if (t < 2 / 2.75) return 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;
            if (t < 2.5 / 2.75) return 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;
            return 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
        }
    };

    // ビルトインプリセット
    const BUILTIN_PRESETS = {
        // シンプル - IN
        'simple-fade-in': {
            id: 'simple-fade-in',
            name: 'フェードイン',
            category: 'simple',
            type: 'in',
            unit: 'all',
            duration: 500,
            easing: 'easeOutQuad',
            keyframes: [
                { time: 0, opacity: 0 },
                { time: 1, opacity: 1 }
            ]
        },
        'simple-slide-up-in': {
            id: 'simple-slide-up-in',
            name: 'スライドアップ',
            category: 'simple',
            type: 'in',
            unit: 'all',
            duration: 500,
            easing: 'easeOutCubic',
            keyframes: [
                { time: 0, opacity: 0, translateY: 50 },
                { time: 1, opacity: 1, translateY: 0 }
            ]
        },
        'simple-slide-down-in': {
            id: 'simple-slide-down-in',
            name: 'スライドダウン',
            category: 'simple',
            type: 'in',
            unit: 'all',
            duration: 500,
            easing: 'easeOutCubic',
            keyframes: [
                { time: 0, opacity: 0, translateY: -50 },
                { time: 1, opacity: 1, translateY: 0 }
            ]
        },
        'simple-slide-left-in': {
            id: 'simple-slide-left-in',
            name: 'スライド左から',
            category: 'simple',
            type: 'in',
            unit: 'all',
            duration: 500,
            easing: 'easeOutCubic',
            keyframes: [
                { time: 0, opacity: 0, translateX: -100 },
                { time: 1, opacity: 1, translateX: 0 }
            ]
        },
        'simple-slide-right-in': {
            id: 'simple-slide-right-in',
            name: 'スライド右から',
            category: 'simple',
            type: 'in',
            unit: 'all',
            duration: 500,
            easing: 'easeOutCubic',
            keyframes: [
                { time: 0, opacity: 0, translateX: 100 },
                { time: 1, opacity: 1, translateX: 0 }
            ]
        },
        'simple-scale-in': {
            id: 'simple-scale-in',
            name: 'スケールイン',
            category: 'simple',
            type: 'in',
            unit: 'all',
            duration: 500,
            easing: 'easeOutCubic',
            keyframes: [
                { time: 0, opacity: 0, scale: 0.5 },
                { time: 1, opacity: 1, scale: 1 }
            ]
        },

        // シンプル - OUT
        'simple-fade-out': {
            id: 'simple-fade-out',
            name: 'フェードアウト',
            category: 'simple',
            type: 'out',
            unit: 'all',
            duration: 500,
            easing: 'easeInQuad',
            keyframes: [
                { time: 0, opacity: 1 },
                { time: 1, opacity: 0 }
            ]
        },
        'simple-slide-up-out': {
            id: 'simple-slide-up-out',
            name: 'スライドアップ',
            category: 'simple',
            type: 'out',
            unit: 'all',
            duration: 500,
            easing: 'easeInCubic',
            keyframes: [
                { time: 0, opacity: 1, translateY: 0 },
                { time: 1, opacity: 0, translateY: -50 }
            ]
        },
        'simple-slide-down-out': {
            id: 'simple-slide-down-out',
            name: 'スライドダウン',
            category: 'simple',
            type: 'out',
            unit: 'all',
            duration: 500,
            easing: 'easeInCubic',
            keyframes: [
                { time: 0, opacity: 1, translateY: 0 },
                { time: 1, opacity: 0, translateY: 50 }
            ]
        },

        // モダン - IN (文字単位)
        'modern-typewriter-in': {
            id: 'modern-typewriter-in',
            name: 'タイプライター',
            category: 'modern',
            type: 'in',
            unit: 'character',
            duration: 100,
            stagger: 50,
            easing: 'linear',
            keyframes: [
                { time: 0, opacity: 0 },
                { time: 1, opacity: 1 }
            ]
        },
        'modern-wave-in': {
            id: 'modern-wave-in',
            name: 'ウェーブ',
            category: 'modern',
            type: 'in',
            unit: 'character',
            duration: 400,
            stagger: 30,
            easing: 'easeOutCubic',
            keyframes: [
                { time: 0, opacity: 0, translateY: 30 },
                { time: 0.6, translateY: -10 },
                { time: 1, opacity: 1, translateY: 0 }
            ]
        },
        'modern-cascade-in': {
            id: 'modern-cascade-in',
            name: 'カスケード',
            category: 'modern',
            type: 'in',
            unit: 'character',
            duration: 300,
            stagger: 40,
            easing: 'easeOutQuad',
            keyframes: [
                { time: 0, opacity: 0, translateY: -20, translateX: -10 },
                { time: 1, opacity: 1, translateY: 0, translateX: 0 }
            ]
        },

        // ダイナミック - IN
        'dynamic-bounce-in': {
            id: 'dynamic-bounce-in',
            name: 'バウンス',
            category: 'dynamic',
            type: 'in',
            unit: 'all',
            duration: 800,
            easing: 'easeOutBounce',
            keyframes: [
                { time: 0, opacity: 0, scale: 0.3, translateY: -100 },
                { time: 1, opacity: 1, scale: 1, translateY: 0 }
            ]
        },
        'dynamic-zoom-in': {
            id: 'dynamic-zoom-in',
            name: 'ズームイン',
            category: 'dynamic',
            type: 'in',
            unit: 'all',
            duration: 600,
            easing: 'easeOutCubic',
            keyframes: [
                { time: 0, opacity: 0, scale: 2.5 },
                { time: 1, opacity: 1, scale: 1 }
            ]
        },
        'dynamic-rotate-in': {
            id: 'dynamic-rotate-in',
            name: '回転イン',
            category: 'dynamic',
            type: 'in',
            unit: 'all',
            duration: 700,
            easing: 'easeOutCubic',
            keyframes: [
                { time: 0, opacity: 0, rotate: -180, scale: 0.5 },
                { time: 1, opacity: 1, rotate: 0, scale: 1 }
            ]
        },

        // エラスティック - IN
        'elastic-pop-in': {
            id: 'elastic-pop-in',
            name: 'ポップイン',
            category: 'elastic',
            type: 'in',
            unit: 'all',
            duration: 600,
            easing: 'easeOutElastic',
            keyframes: [
                { time: 0, opacity: 0, scale: 0.5 },
                { time: 1, opacity: 1, scale: 1 }
            ]
        },
        'elastic-spring-in': {
            id: 'elastic-spring-in',
            name: 'スプリング',
            category: 'elastic',
            type: 'in',
            unit: 'character',
            duration: 500,
            stagger: 50,
            easing: 'easeOutElastic',
            keyframes: [
                { time: 0, opacity: 0, translateY: 50, scale: 0.8 },
                { time: 1, opacity: 1, translateY: 0, scale: 1 }
            ]
        },

        // クリエイティブ - IN
        'creative-glitch-in': {
            id: 'creative-glitch-in',
            name: 'グリッチ',
            category: 'creative',
            type: 'in',
            unit: 'all',
            duration: 400,
            easing: 'linear',
            keyframes: [
                { time: 0, opacity: 0, translateX: -5 },
                { time: 0.2, opacity: 1, translateX: 5 },
                { time: 0.4, translateX: -3 },
                { time: 0.6, translateX: 3 },
                { time: 0.8, translateX: -1 },
                { time: 1, translateX: 0 }
            ]
        },
        'creative-blur-in': {
            id: 'creative-blur-in',
            name: 'ブラーイン',
            category: 'creative',
            type: 'in',
            unit: 'all',
            duration: 500,
            easing: 'easeOutQuad',
            keyframes: [
                { time: 0, opacity: 0, blur: 20 },
                { time: 1, opacity: 1, blur: 0 }
            ]
        }
    };

    // ユーザーカスタムプリセット（LocalStorageから読み込み）
    let customPresets = {};

    /**
     * 初期化
     */
    function init() {
        loadCustomPresets();
        console.log('[AnimationPresets] Initialized with', Object.keys(BUILTIN_PRESETS).length, 'builtin presets');
    }

    /**
     * カスタムプリセットをLocalStorageから読み込み
     */
    function loadCustomPresets() {
        try {
            const saved = localStorage.getItem('telopEditor_animationPresets');
            if (saved) {
                customPresets = JSON.parse(saved);
            }
        } catch (e) {
            console.error('[AnimationPresets] Failed to load custom presets:', e);
        }
    }

    /**
     * カスタムプリセットをLocalStorageに保存
     */
    function saveCustomPresets() {
        try {
            localStorage.setItem('telopEditor_animationPresets', JSON.stringify(customPresets));
        } catch (e) {
            console.error('[AnimationPresets] Failed to save custom presets:', e);
        }
    }

    /**
     * プリセット取得
     * @param {string} id - プリセットID
     * @returns {Object|null} プリセットデータ
     */
    function getPreset(id) {
        return BUILTIN_PRESETS[id] || customPresets[id] || null;
    }

    /**
     * カテゴリ別プリセット取得
     * @param {string} category - カテゴリID
     * @param {string} type - アニメーションタイプ (in/out/loop)
     * @returns {Array} プリセット配列
     */
    function getPresetsByCategory(category, type) {
        const allPresets = { ...BUILTIN_PRESETS, ...customPresets };
        return Object.values(allPresets).filter(p => {
            const categoryMatch = !category || category === 'all' || p.category === category;
            const typeMatch = !type || p.type === type;
            return categoryMatch && typeMatch;
        });
    }

    /**
     * 全カテゴリ取得
     * @returns {Object} カテゴリオブジェクト
     */
    function getCategories() {
        return CATEGORIES;
    }

    /**
     * カスタムプリセット追加
     * @param {Object} preset - プリセットデータ
     * @returns {boolean} 成功/失敗
     */
    function addCustomPreset(preset) {
        if (!preset.id || !preset.name) {
            console.error('[AnimationPresets] Invalid preset: missing id or name');
            return false;
        }
        preset.id = 'custom-' + preset.id;
        customPresets[preset.id] = preset;
        saveCustomPresets();
        return true;
    }

    /**
     * カスタムプリセット削除
     * @param {string} id - プリセットID
     * @returns {boolean} 成功/失敗
     */
    function removeCustomPreset(id) {
        if (customPresets[id]) {
            delete customPresets[id];
            saveCustomPresets();
            return true;
        }
        return false;
    }

    /**
     * アニメーション値を補間
     * @param {Array} keyframes - キーフレーム配列
     * @param {number} progress - 進捗 (0-1)
     * @param {string} easingName - イージング名
     * @returns {Object} 補間された値
     */
    function interpolate(keyframes, progress, easingName) {
        const easing = EASINGS[easingName] || EASINGS.linear;
        const easedProgress = easing(Math.max(0, Math.min(1, progress)));

        // 該当するキーフレーム区間を見つける
        let prevFrame = keyframes[0];
        let nextFrame = keyframes[keyframes.length - 1];

        for (let i = 0; i < keyframes.length - 1; i++) {
            if (easedProgress >= keyframes[i].time && easedProgress <= keyframes[i + 1].time) {
                prevFrame = keyframes[i];
                nextFrame = keyframes[i + 1];
                break;
            }
        }

        // 区間内での進捗を計算
        const segmentProgress = (nextFrame.time === prevFrame.time) ? 1 :
            (easedProgress - prevFrame.time) / (nextFrame.time - prevFrame.time);

        // 各プロパティを補間
        const result = { time: easedProgress };
        const properties = ['opacity', 'translateX', 'translateY', 'scale', 'rotate', 'blur'];

        properties.forEach(prop => {
            const prevVal = prevFrame[prop];
            const nextVal = nextFrame[prop];
            if (prevVal !== undefined || nextVal !== undefined) {
                const pv = prevVal !== undefined ? prevVal : (prop === 'opacity' || prop === 'scale' ? 1 : 0);
                const nv = nextVal !== undefined ? nextVal : (prop === 'opacity' || prop === 'scale' ? 1 : 0);
                result[prop] = pv + (nv - pv) * segmentProgress;
            }
        });

        return result;
    }

    /**
     * アニメーションをCanvasに適用
     * @param {CanvasRenderingContext2D} ctx - Canvasコンテキスト
     * @param {Object} preset - プリセット
     * @param {number} progress - 進捗 (0-1)
     * @param {Object} bounds - 描画範囲 {x, y, width, height}
     */
    function applyToCanvas(ctx, preset, progress, bounds) {
        const values = interpolate(preset.keyframes, progress, preset.easing);

        ctx.save();

        // 透明度
        if (values.opacity !== undefined) {
            ctx.globalAlpha *= values.opacity;
        }

        // 変形の中心点
        const centerX = bounds.x + bounds.width / 2;
        const centerY = bounds.y + bounds.height / 2;

        ctx.translate(centerX, centerY);

        // 回転
        if (values.rotate) {
            ctx.rotate(values.rotate * Math.PI / 180);
        }

        // スケール
        if (values.scale !== undefined) {
            ctx.scale(values.scale, values.scale);
        }

        ctx.translate(-centerX, -centerY);

        // 移動
        if (values.translateX || values.translateY) {
            ctx.translate(values.translateX || 0, values.translateY || 0);
        }

        ctx.restore();

        return values;
    }

    /**
     * プリセットをエクスポート
     * @returns {string} JSON文字列
     */
    function exportPresets() {
        return JSON.stringify(customPresets, null, 2);
    }

    /**
     * プリセットをインポート
     * @param {string} jsonString - JSON文字列
     * @returns {boolean} 成功/失敗
     */
    function importPresets(jsonString) {
        try {
            const imported = JSON.parse(jsonString);
            Object.assign(customPresets, imported);
            saveCustomPresets();
            return true;
        } catch (e) {
            console.error('[AnimationPresets] Import failed:', e);
            return false;
        }
    }

    // 初期化
    init();

    // Public API
    return {
        CATEGORIES,
        ANIMATION_TYPES,
        APPLY_UNITS,
        EASINGS,
        getPreset,
        getPresetsByCategory,
        getCategories,
        addCustomPreset,
        removeCustomPreset,
        interpolate,
        applyToCanvas,
        exportPresets,
        importPresets
    };
})();

// 初期化を実行
if (typeof initAnimationPresets === 'function') {
    initAnimationPresets();
}
console.log('[AnimationPresets] Module loaded and initialized');
    </script>

    <!-- Style Presets (embedded) -->
    <script>
/**
 * Style Presets System
 * テロップスタイルプリセット管理
 * 参考: textylepremiere のスタイルカテゴリ
 */

window.StylePresets = (function() {
    'use strict';

    // スタイルカテゴリ（textylepremiere参考）
    const CATEGORIES = {
        CARTOON: {
            id: 'cartoon',
            name: 'カートゥーン',
            description: 'ポップで楽しいスタイル',
            icon: 'Cartoon.png',
            color: '#FF6B6B'
        },
        CINEMATIC: {
            id: 'cinematic',
            name: 'シネマティック',
            description: '映画的で高級感のあるスタイル',
            icon: 'Cinematic.png',
            color: '#4A4A4A'
        },
        MODERN: {
            id: 'modern',
            name: 'モダン',
            description: '現代的でスタイリッシュ',
            icon: 'Modern.png',
            color: '#00D9FF'
        },
        SIMPLE: {
            id: 'simple',
            name: 'シンプル',
            description: 'シンプルで使いやすい',
            icon: 'Simple.png',
            color: '#FFFFFF'
        },
        NEWS: {
            id: 'news',
            name: 'ニュース',
            description: 'ニュース番組風',
            icon: 'News.png',
            color: '#0066CC'
        },
        VARIETY: {
            id: 'variety',
            name: 'バラエティ',
            description: 'バラエティ番組風',
            icon: 'Variety.png',
            color: '#FFD700'
        }
    };

    // ビルトインスタイルプリセット
    const BUILTIN_PRESETS = {
        // カートゥーン
        'cartoon-pop': {
            id: 'cartoon-pop',
            name: 'ポップ',
            category: 'cartoon',
            style: {
                fontFamily: 'Rounded Mplus 1c',
                fontSize: 72,
                color: '#FFFFFF',
                fillType: 'linear',
                gradientStops: [
                    { pos: 0, color: '#FF6B6B' },
                    { pos: 100, color: '#FFE66D' }
                ],
                gradientAngle: 90,
                strokes: [
                    { enabled: true, type: 'edge', color: '#FFFFFF', width: 4, opacity: 100, join: 'round' },
                    { enabled: true, type: 'edge', color: '#333333', width: 8, opacity: 100, join: 'round' }
                ],
                shadowEnabled: true,
                shadowColor: '#000000',
                shadowOpacity: 50,
                shadowAngle: 135,
                shadowDistance: 5,
                shadowBlur: 10
            }
        },
        'cartoon-bubble': {
            id: 'cartoon-bubble',
            name: 'バブル',
            category: 'cartoon',
            style: {
                fontFamily: 'Hiragino Maru Gothic Pro',
                fontSize: 72,
                color: '#00BFFF',
                fillType: 'solid',
                strokes: [
                    { enabled: true, type: 'edge', color: '#FFFFFF', width: 6, opacity: 100, join: 'round' },
                    { enabled: true, type: 'edge', color: '#0088CC', width: 10, opacity: 100, join: 'round' }
                ],
                glossEnabled: true,
                glossOpacity: 60,
                glossHeight: 40
            }
        },
        'cartoon-comic': {
            id: 'cartoon-comic',
            name: 'コミック',
            category: 'cartoon',
            style: {
                fontFamily: 'Impact',
                fontSize: 80,
                color: '#FFFF00',
                fillType: 'solid',
                strokes: [
                    { enabled: true, type: 'edge', color: '#000000', width: 6, opacity: 100, join: 'miter' }
                ],
                shadowEnabled: true,
                shadowColor: '#FF0000',
                shadowOpacity: 100,
                shadowAngle: 135,
                shadowDistance: 8,
                shadowBlur: 0
            }
        },

        // シネマティック
        'cinematic-gold': {
            id: 'cinematic-gold',
            name: 'ゴールド',
            category: 'cinematic',
            style: {
                fontFamily: 'Times New Roman',
                fontSize: 72,
                fillType: 'linear',
                gradientStops: [
                    { pos: 0, color: '#FFD700' },
                    { pos: 30, color: '#FFF8DC' },
                    { pos: 50, color: '#FFD700' },
                    { pos: 70, color: '#B8860B' },
                    { pos: 100, color: '#8B4513' }
                ],
                gradientAngle: 90,
                strokes: [
                    { enabled: true, type: 'edge', color: '#8B4513', width: 2, opacity: 100, join: 'round' }
                ],
                shadowEnabled: true,
                shadowColor: '#000000',
                shadowOpacity: 80,
                shadowDistance: 4,
                shadowBlur: 8
            }
        },
        'cinematic-silver': {
            id: 'cinematic-silver',
            name: 'シルバー',
            category: 'cinematic',
            style: {
                fontFamily: 'Arial',
                fontSize: 72,
                fillType: 'linear',
                gradientStops: [
                    { pos: 0, color: '#C0C0C0' },
                    { pos: 30, color: '#FFFFFF' },
                    { pos: 50, color: '#C0C0C0' },
                    { pos: 70, color: '#808080' },
                    { pos: 100, color: '#404040' }
                ],
                gradientAngle: 90,
                strokes: [
                    { enabled: true, type: 'edge', color: '#2F2F2F', width: 2, opacity: 100, join: 'round' }
                ],
                shadowEnabled: true,
                shadowColor: '#000000',
                shadowOpacity: 60,
                shadowDistance: 3,
                shadowBlur: 6
            }
        },
        'cinematic-dark': {
            id: 'cinematic-dark',
            name: 'ダーク',
            category: 'cinematic',
            style: {
                fontFamily: 'Georgia',
                fontSize: 72,
                color: '#CCCCCC',
                fillType: 'solid',
                strokes: [
                    { enabled: true, type: 'edge', color: '#1A1A1A', width: 4, opacity: 100, join: 'round' }
                ],
                shadowEnabled: true,
                shadowColor: '#000000',
                shadowOpacity: 100,
                shadowDistance: 0,
                shadowBlur: 20
            }
        },

        // モダン
        'modern-neon': {
            id: 'modern-neon',
            name: 'ネオン',
            category: 'modern',
            style: {
                fontFamily: 'Helvetica Neue',
                fontSize: 72,
                color: '#00FFFF',
                fillType: 'solid',
                strokes: [
                    { enabled: true, type: 'edge', color: '#00FFFF', width: 2, opacity: 80, join: 'round', blur: true, blurAmount: 10 },
                    { enabled: true, type: 'edge', color: '#00FFFF', width: 8, opacity: 40, join: 'round', blur: true, blurAmount: 20 }
                ],
                shadowEnabled: true,
                shadowColor: '#00FFFF',
                shadowOpacity: 60,
                shadowDistance: 0,
                shadowBlur: 30
            }
        },
        'modern-gradient': {
            id: 'modern-gradient',
            name: 'グラデーション',
            category: 'modern',
            style: {
                fontFamily: 'Yu Gothic UI',
                fontSize: 72,
                fillType: 'linear',
                gradientStops: [
                    { pos: 0, color: '#667eea' },
                    { pos: 100, color: '#764ba2' }
                ],
                gradientAngle: 45,
                strokes: [
                    { enabled: true, type: 'edge', color: '#FFFFFF', width: 3, opacity: 100, join: 'round' }
                ]
            }
        },
        'modern-glass': {
            id: 'modern-glass',
            name: 'ガラス',
            category: 'modern',
            style: {
                fontFamily: 'Segoe UI',
                fontSize: 72,
                fillType: 'linear',
                gradientStops: [
                    { pos: 0, color: 'rgba(255,255,255,0.9)' },
                    { pos: 50, color: 'rgba(255,255,255,0.5)' },
                    { pos: 100, color: 'rgba(255,255,255,0.8)' }
                ],
                gradientAngle: 90,
                strokes: [
                    { enabled: true, type: 'edge', color: 'rgba(255,255,255,0.5)', width: 2, opacity: 100, join: 'round' }
                ],
                glossEnabled: true,
                glossOpacity: 80,
                glossHeight: 50
            }
        },

        // シンプル
        'simple-white': {
            id: 'simple-white',
            name: '白文字',
            category: 'simple',
            style: {
                fontFamily: 'Yu Gothic UI',
                fontSize: 72,
                color: '#FFFFFF',
                fillType: 'solid',
                strokes: [
                    { enabled: true, type: 'edge', color: '#000000', width: 4, opacity: 100, join: 'round' }
                ],
                shadowEnabled: true,
                shadowColor: '#000000',
                shadowOpacity: 50,
                shadowDistance: 2,
                shadowBlur: 4
            }
        },
        'simple-black': {
            id: 'simple-black',
            name: '黒文字',
            category: 'simple',
            style: {
                fontFamily: 'Yu Gothic UI',
                fontSize: 72,
                color: '#000000',
                fillType: 'solid',
                strokes: [
                    { enabled: true, type: 'edge', color: '#FFFFFF', width: 4, opacity: 100, join: 'round' }
                ]
            }
        },
        'simple-yellow': {
            id: 'simple-yellow',
            name: '黄色文字',
            category: 'simple',
            style: {
                fontFamily: 'Yu Gothic UI',
                fontSize: 72,
                color: '#FFFF00',
                fillType: 'solid',
                strokes: [
                    { enabled: true, type: 'edge', color: '#000000', width: 4, opacity: 100, join: 'round' }
                ],
                shadowEnabled: true,
                shadowColor: '#000000',
                shadowOpacity: 60,
                shadowDistance: 2,
                shadowBlur: 4
            }
        },

        // ニュース
        'news-headline': {
            id: 'news-headline',
            name: 'ヘッドライン',
            category: 'news',
            style: {
                fontFamily: 'Hiragino Kaku Gothic Pro',
                fontSize: 64,
                color: '#FFFFFF',
                fillType: 'solid',
                strokes: [
                    { enabled: true, type: 'edge', color: '#003366', width: 3, opacity: 100, join: 'miter' }
                ],
                shadowEnabled: false
            }
        },
        'news-breaking': {
            id: 'news-breaking',
            name: '速報',
            category: 'news',
            style: {
                fontFamily: 'Hiragino Kaku Gothic Pro',
                fontSize: 72,
                color: '#FFFFFF',
                fillType: 'solid',
                strokes: [
                    { enabled: true, type: 'edge', color: '#CC0000', width: 4, opacity: 100, join: 'miter' },
                    { enabled: true, type: 'edge', color: '#FFFFFF', width: 6, opacity: 100, join: 'miter' }
                ]
            }
        },
        'news-ticker': {
            id: 'news-ticker',
            name: 'ティッカー',
            category: 'news',
            style: {
                fontFamily: 'Meiryo',
                fontSize: 48,
                color: '#FFFFFF',
                fillType: 'solid',
                strokes: [
                    { enabled: true, type: 'edge', color: '#1A1A1A', width: 2, opacity: 100, join: 'round' }
                ]
            }
        },

        // バラエティ
        'variety-impact': {
            id: 'variety-impact',
            name: 'インパクト',
            category: 'variety',
            style: {
                fontFamily: 'Hiragino Sans',
                fontSize: 80,
                color: '#FF0000',
                fillType: 'solid',
                strokes: [
                    { enabled: true, type: 'edge', color: '#FFFF00', width: 6, opacity: 100, join: 'miter' },
                    { enabled: true, type: 'edge', color: '#000000', width: 10, opacity: 100, join: 'miter' }
                ],
                shadowEnabled: true,
                shadowColor: '#000000',
                shadowOpacity: 80,
                shadowDistance: 5,
                shadowBlur: 0
            }
        },
        'variety-cute': {
            id: 'variety-cute',
            name: 'キュート',
            category: 'variety',
            style: {
                fontFamily: 'Rounded Mplus 1c',
                fontSize: 72,
                fillType: 'linear',
                gradientStops: [
                    { pos: 0, color: '#FF69B4' },
                    { pos: 100, color: '#FFB6C1' }
                ],
                gradientAngle: 90,
                strokes: [
                    { enabled: true, type: 'edge', color: '#FFFFFF', width: 4, opacity: 100, join: 'round' },
                    { enabled: true, type: 'edge', color: '#FF1493', width: 8, opacity: 100, join: 'round' }
                ],
                glossEnabled: true,
                glossOpacity: 50,
                glossHeight: 40
            }
        },
        'variety-powerful': {
            id: 'variety-powerful',
            name: 'パワフル',
            category: 'variety',
            style: {
                fontFamily: 'Impact',
                fontSize: 84,
                color: '#FFD700',
                fillType: 'solid',
                strokes: [
                    { enabled: true, type: 'edge', color: '#FF4500', width: 5, opacity: 100, join: 'miter' },
                    { enabled: true, type: 'edge', color: '#000000', width: 10, opacity: 100, join: 'miter' }
                ],
                shadowEnabled: true,
                shadowColor: '#FF4500',
                shadowOpacity: 60,
                shadowDistance: 4,
                shadowBlur: 8
            }
        }
    };

    // ユーザーカスタムプリセット
    let customPresets = {};

    /**
     * 初期化
     */
    function init() {
        loadCustomPresets();
        console.log('[StylePresets] Initialized with', Object.keys(BUILTIN_PRESETS).length, 'builtin presets');
    }

    /**
     * カスタムプリセット読み込み
     */
    function loadCustomPresets() {
        try {
            const saved = localStorage.getItem('telopEditor_stylePresets');
            if (saved) {
                customPresets = JSON.parse(saved);
            }
        } catch (e) {
            console.error('[StylePresets] Failed to load:', e);
        }
    }

    /**
     * カスタムプリセット保存
     */
    function saveCustomPresets() {
        try {
            localStorage.setItem('telopEditor_stylePresets', JSON.stringify(customPresets));
        } catch (e) {
            console.error('[StylePresets] Failed to save:', e);
        }
    }

    /**
     * プリセット取得
     */
    function getPreset(id) {
        return BUILTIN_PRESETS[id] || customPresets[id] || null;
    }

    /**
     * カテゴリ別プリセット取得
     */
    function getPresetsByCategory(category) {
        const all = { ...BUILTIN_PRESETS, ...customPresets };
        if (!category || category === 'all') return Object.values(all);
        return Object.values(all).filter(p => p.category === category);
    }

    /**
     * 全カテゴリ取得
     */
    function getCategories() {
        return CATEGORIES;
    }

    /**
     * カスタムプリセット追加
     */
    function addCustomPreset(preset) {
        if (!preset.id || !preset.name || !preset.style) {
            console.error('[StylePresets] Invalid preset');
            return false;
        }
        preset.id = 'custom-' + Date.now();
        customPresets[preset.id] = preset;
        saveCustomPresets();
        return preset.id;
    }

    /**
     * カスタムプリセット削除
     */
    function removeCustomPreset(id) {
        if (customPresets[id]) {
            delete customPresets[id];
            saveCustomPresets();
            return true;
        }
        return false;
    }

    /**
     * スタイルを文字データに適用
     * @param {Object} charData - 文字データ
     * @param {Object} style - スタイルデータ
     * @returns {Object} 適用後の文字データ
     */
    function applyStyleToChar(charData, style) {
        return {
            ...charData,
            fontFamily: style.fontFamily || charData.fontFamily,
            fontSize: style.fontSize || charData.fontSize,
            color: style.color || charData.color,
            fillType: style.fillType || charData.fillType,
            gradientStops: style.gradientStops || charData.gradientStops,
            gradientAngle: style.gradientAngle !== undefined ? style.gradientAngle : charData.gradientAngle,
            strokes: style.strokes || charData.strokes,
            shadowEnabled: style.shadowEnabled !== undefined ? style.shadowEnabled : charData.shadowEnabled,
            shadowColor: style.shadowColor || charData.shadowColor,
            shadowOpacity: style.shadowOpacity !== undefined ? style.shadowOpacity : charData.shadowOpacity,
            shadowAngle: style.shadowAngle !== undefined ? style.shadowAngle : charData.shadowAngle,
            shadowDistance: style.shadowDistance !== undefined ? style.shadowDistance : charData.shadowDistance,
            shadowBlur: style.shadowBlur !== undefined ? style.shadowBlur : charData.shadowBlur,
            glossEnabled: style.glossEnabled !== undefined ? style.glossEnabled : charData.glossEnabled,
            glossOpacity: style.glossOpacity !== undefined ? style.glossOpacity : charData.glossOpacity,
            glossHeight: style.glossHeight !== undefined ? style.glossHeight : charData.glossHeight
        };
    }

    /**
     * エクスポート
     */
    function exportPresets() {
        return JSON.stringify(customPresets, null, 2);
    }

    /**
     * インポート
     */
    function importPresets(jsonString) {
        try {
            const imported = JSON.parse(jsonString);
            Object.assign(customPresets, imported);
            saveCustomPresets();
            return true;
        } catch (e) {
            console.error('[StylePresets] Import failed:', e);
            return false;
        }
    }

    // 初期化
    init();

    // カテゴリ名取得
    function getCategoryName(categoryId) {
        const categoryMap = {
            'cartoon': 'カートゥーン',
            'cinematic': 'シネマティック',
            'modern': 'モダン',
            'simple': 'シンプル',
            'news': 'ニュース',
            'variety': 'バラエティ',
            'custom': 'カスタム'
        };
        return categoryMap[categoryId] || categoryId;
    }

    return {
        CATEGORIES,
        getPreset,
        getPresetsByCategory,
        getCategories,
        getCategoryName,
        addCustomPreset,
        removeCustomPreset,
        applyStyleToChar,
        exportPresets,
        importPresets
    };
})();

// 初期化を実行
if (typeof initStylePresets === 'function') {
    initStylePresets();
}
console.log('[StylePresets] Module loaded and initialized');
    </script>
</body>
</html>
